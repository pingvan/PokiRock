// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_game_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_game_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_game_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_game_2eproto;
namespace game {
class CreateGameRequest;
struct CreateGameRequestDefaultTypeInternal;
extern CreateGameRequestDefaultTypeInternal _CreateGameRequest_default_instance_;
class CreateGameResponse;
struct CreateGameResponseDefaultTypeInternal;
extern CreateGameResponseDefaultTypeInternal _CreateGameResponse_default_instance_;
class ErrorMessage;
struct ErrorMessageDefaultTypeInternal;
extern ErrorMessageDefaultTypeInternal _ErrorMessage_default_instance_;
class GameParameters;
struct GameParametersDefaultTypeInternal;
extern GameParametersDefaultTypeInternal _GameParameters_default_instance_;
class GameRequests;
struct GameRequestsDefaultTypeInternal;
extern GameRequestsDefaultTypeInternal _GameRequests_default_instance_;
class GameResponses;
struct GameResponsesDefaultTypeInternal;
extern GameResponsesDefaultTypeInternal _GameResponses_default_instance_;
class LobbyRequests;
struct LobbyRequestsDefaultTypeInternal;
extern LobbyRequestsDefaultTypeInternal _LobbyRequests_default_instance_;
class LobbyResponses;
struct LobbyResponsesDefaultTypeInternal;
extern LobbyResponsesDefaultTypeInternal _LobbyResponses_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginRequestFirst;
struct LoginRequestFirstDefaultTypeInternal;
extern LoginRequestFirstDefaultTypeInternal _LoginRequestFirst_default_instance_;
class LoginRequestSecond;
struct LoginRequestSecondDefaultTypeInternal;
extern LoginRequestSecondDefaultTypeInternal _LoginRequestSecond_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class LoginResponseFirst;
struct LoginResponseFirstDefaultTypeInternal;
extern LoginResponseFirstDefaultTypeInternal _LoginResponseFirst_default_instance_;
class LoginResponseSecond;
struct LoginResponseSecondDefaultTypeInternal;
extern LoginResponseSecondDefaultTypeInternal _LoginResponseSecond_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class SaltHash;
struct SaltHashDefaultTypeInternal;
extern SaltHashDefaultTypeInternal _SaltHash_default_instance_;
class SearchGameRequest;
struct SearchGameRequestDefaultTypeInternal;
extern SearchGameRequestDefaultTypeInternal _SearchGameRequest_default_instance_;
class SearchGameResponse;
struct SearchGameResponseDefaultTypeInternal;
extern SearchGameResponseDefaultTypeInternal _SearchGameResponse_default_instance_;
class StatusMessage;
struct StatusMessageDefaultTypeInternal;
extern StatusMessageDefaultTypeInternal _StatusMessage_default_instance_;
class make_move_request;
struct make_move_requestDefaultTypeInternal;
extern make_move_requestDefaultTypeInternal _make_move_request_default_instance_;
class make_move_response;
struct make_move_responseDefaultTypeInternal;
extern make_move_responseDefaultTypeInternal _make_move_response_default_instance_;
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> ::game::CreateGameRequest* Arena::CreateMaybeMessage<::game::CreateGameRequest>(Arena*);
template<> ::game::CreateGameResponse* Arena::CreateMaybeMessage<::game::CreateGameResponse>(Arena*);
template<> ::game::ErrorMessage* Arena::CreateMaybeMessage<::game::ErrorMessage>(Arena*);
template<> ::game::GameParameters* Arena::CreateMaybeMessage<::game::GameParameters>(Arena*);
template<> ::game::GameRequests* Arena::CreateMaybeMessage<::game::GameRequests>(Arena*);
template<> ::game::GameResponses* Arena::CreateMaybeMessage<::game::GameResponses>(Arena*);
template<> ::game::LobbyRequests* Arena::CreateMaybeMessage<::game::LobbyRequests>(Arena*);
template<> ::game::LobbyResponses* Arena::CreateMaybeMessage<::game::LobbyResponses>(Arena*);
template<> ::game::LoginRequest* Arena::CreateMaybeMessage<::game::LoginRequest>(Arena*);
template<> ::game::LoginRequestFirst* Arena::CreateMaybeMessage<::game::LoginRequestFirst>(Arena*);
template<> ::game::LoginRequestSecond* Arena::CreateMaybeMessage<::game::LoginRequestSecond>(Arena*);
template<> ::game::LoginResponse* Arena::CreateMaybeMessage<::game::LoginResponse>(Arena*);
template<> ::game::LoginResponseFirst* Arena::CreateMaybeMessage<::game::LoginResponseFirst>(Arena*);
template<> ::game::LoginResponseSecond* Arena::CreateMaybeMessage<::game::LoginResponseSecond>(Arena*);
template<> ::game::Player* Arena::CreateMaybeMessage<::game::Player>(Arena*);
template<> ::game::PlayerInfo* Arena::CreateMaybeMessage<::game::PlayerInfo>(Arena*);
template<> ::game::RegisterRequest* Arena::CreateMaybeMessage<::game::RegisterRequest>(Arena*);
template<> ::game::RegisterResponse* Arena::CreateMaybeMessage<::game::RegisterResponse>(Arena*);
template<> ::game::SaltHash* Arena::CreateMaybeMessage<::game::SaltHash>(Arena*);
template<> ::game::SearchGameRequest* Arena::CreateMaybeMessage<::game::SearchGameRequest>(Arena*);
template<> ::game::SearchGameResponse* Arena::CreateMaybeMessage<::game::SearchGameResponse>(Arena*);
template<> ::game::StatusMessage* Arena::CreateMaybeMessage<::game::StatusMessage>(Arena*);
template<> ::game::make_move_request* Arena::CreateMaybeMessage<::game::make_move_request>(Arena*);
template<> ::game::make_move_response* Arena::CreateMaybeMessage<::game::make_move_response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace game {

enum error : int {
  ERROR_NO_USER_WITH_THIS_LOGIN = 0,
  ERROR_USER_WITH_THIS_LOGIN_ALREADY_EXISTS = 1,
  ERROR_UNCORRECT_PASSWORD = 2,
  ERROR_EXCEPTION = 3,
  error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool error_IsValid(int value);
constexpr error error_MIN = ERROR_NO_USER_WITH_THIS_LOGIN;
constexpr error error_MAX = ERROR_EXCEPTION;
constexpr int error_ARRAYSIZE = error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* error_descriptor();
template<typename T>
inline const std::string& error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    error_descriptor(), enum_t_value);
}
inline bool error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<error>(
    error_descriptor(), name, value);
}
enum PlayerStatus : int {
  PLAYER_STATUS_FOLD = 0,
  PLAYER_STATUS_PLAYING = 1,
  PLAYER_STATUS_WIN = 2,
  PlayerStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerStatus_IsValid(int value);
constexpr PlayerStatus PlayerStatus_MIN = PLAYER_STATUS_FOLD;
constexpr PlayerStatus PlayerStatus_MAX = PLAYER_STATUS_WIN;
constexpr int PlayerStatus_ARRAYSIZE = PlayerStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerStatus_descriptor();
template<typename T>
inline const std::string& PlayerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerStatus_descriptor(), enum_t_value);
}
inline bool PlayerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerStatus>(
    PlayerStatus_descriptor(), name, value);
}
// ===================================================================

class StatusMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.StatusMessage) */ {
 public:
  inline StatusMessage() : StatusMessage(nullptr) {}
  ~StatusMessage() override;
  explicit PROTOBUF_CONSTEXPR StatusMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusMessage(const StatusMessage& from);
  StatusMessage(StatusMessage&& from) noexcept
    : StatusMessage() {
    *this = ::std::move(from);
  }

  inline StatusMessage& operator=(const StatusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusMessage& operator=(StatusMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusMessage* internal_default_instance() {
    return reinterpret_cast<const StatusMessage*>(
               &_StatusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StatusMessage& a, StatusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusMessage& from) {
    StatusMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.StatusMessage";
  }
  protected:
  explicit StatusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool status = 1;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:game.StatusMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class ErrorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.ErrorMessage) */ {
 public:
  inline ErrorMessage() : ErrorMessage(nullptr) {}
  ~ErrorMessage() override;
  explicit PROTOBUF_CONSTEXPR ErrorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorMessage(const ErrorMessage& from);
  ErrorMessage(ErrorMessage&& from) noexcept
    : ErrorMessage() {
    *this = ::std::move(from);
  }

  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorMessage& operator=(ErrorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorMessage* internal_default_instance() {
    return reinterpret_cast<const ErrorMessage*>(
               &_ErrorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ErrorMessage& a, ErrorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorMessage& from) {
    ErrorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.ErrorMessage";
  }
  protected:
  explicit ErrorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageStringFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // optional string message_string = 2;
  bool has_message_string() const;
  private:
  bool _internal_has_message_string() const;
  public:
  void clear_message_string();
  const std::string& message_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_string();
  PROTOBUF_NODISCARD std::string* release_message_string();
  void set_allocated_message_string(std::string* message_string);
  private:
  const std::string& _internal_message_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_string(const std::string& value);
  std::string* _internal_mutable_message_string();
  public:

  // .game.error error = 1;
  void clear_error();
  ::game::error error() const;
  void set_error(::game::error value);
  private:
  ::game::error _internal_error() const;
  void _internal_set_error(::game::error value);
  public:

  // @@protoc_insertion_point(class_scope:game.ErrorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_string_;
    int error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  enum LoginRequestsCase {
    kLoginRequestFirst = 1,
    kLoginRequestSecond = 2,
    LOGIN_REQUESTS_NOT_SET = 0,
  };

  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginRequestFirstFieldNumber = 1,
    kLoginRequestSecondFieldNumber = 2,
  };
  // .game.LoginRequestFirst login_request_first = 1;
  bool has_login_request_first() const;
  private:
  bool _internal_has_login_request_first() const;
  public:
  void clear_login_request_first();
  const ::game::LoginRequestFirst& login_request_first() const;
  PROTOBUF_NODISCARD ::game::LoginRequestFirst* release_login_request_first();
  ::game::LoginRequestFirst* mutable_login_request_first();
  void set_allocated_login_request_first(::game::LoginRequestFirst* login_request_first);
  private:
  const ::game::LoginRequestFirst& _internal_login_request_first() const;
  ::game::LoginRequestFirst* _internal_mutable_login_request_first();
  public:
  void unsafe_arena_set_allocated_login_request_first(
      ::game::LoginRequestFirst* login_request_first);
  ::game::LoginRequestFirst* unsafe_arena_release_login_request_first();

  // .game.LoginRequestSecond login_request_second = 2;
  bool has_login_request_second() const;
  private:
  bool _internal_has_login_request_second() const;
  public:
  void clear_login_request_second();
  const ::game::LoginRequestSecond& login_request_second() const;
  PROTOBUF_NODISCARD ::game::LoginRequestSecond* release_login_request_second();
  ::game::LoginRequestSecond* mutable_login_request_second();
  void set_allocated_login_request_second(::game::LoginRequestSecond* login_request_second);
  private:
  const ::game::LoginRequestSecond& _internal_login_request_second() const;
  ::game::LoginRequestSecond* _internal_mutable_login_request_second();
  public:
  void unsafe_arena_set_allocated_login_request_second(
      ::game::LoginRequestSecond* login_request_second);
  ::game::LoginRequestSecond* unsafe_arena_release_login_request_second();

  void clear_login_requests();
  LoginRequestsCase login_requests_case() const;
  // @@protoc_insertion_point(class_scope:game.LoginRequest)
 private:
  class _Internal;
  void set_has_login_request_first();
  void set_has_login_request_second();

  inline bool has_login_requests() const;
  inline void clear_has_login_requests();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LoginRequestsUnion {
      constexpr LoginRequestsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::LoginRequestFirst* login_request_first_;
      ::game::LoginRequestSecond* login_request_second_;
    } login_requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  enum LoginResponsesCase {
    kLoginResponseFirst = 1,
    kLoginResponseSecond = 2,
    LOGIN_RESPONSES_NOT_SET = 0,
  };

  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginResponseFirstFieldNumber = 1,
    kLoginResponseSecondFieldNumber = 2,
  };
  // .game.LoginResponseFirst login_response_first = 1;
  bool has_login_response_first() const;
  private:
  bool _internal_has_login_response_first() const;
  public:
  void clear_login_response_first();
  const ::game::LoginResponseFirst& login_response_first() const;
  PROTOBUF_NODISCARD ::game::LoginResponseFirst* release_login_response_first();
  ::game::LoginResponseFirst* mutable_login_response_first();
  void set_allocated_login_response_first(::game::LoginResponseFirst* login_response_first);
  private:
  const ::game::LoginResponseFirst& _internal_login_response_first() const;
  ::game::LoginResponseFirst* _internal_mutable_login_response_first();
  public:
  void unsafe_arena_set_allocated_login_response_first(
      ::game::LoginResponseFirst* login_response_first);
  ::game::LoginResponseFirst* unsafe_arena_release_login_response_first();

  // .game.LoginResponseSecond login_response_second = 2;
  bool has_login_response_second() const;
  private:
  bool _internal_has_login_response_second() const;
  public:
  void clear_login_response_second();
  const ::game::LoginResponseSecond& login_response_second() const;
  PROTOBUF_NODISCARD ::game::LoginResponseSecond* release_login_response_second();
  ::game::LoginResponseSecond* mutable_login_response_second();
  void set_allocated_login_response_second(::game::LoginResponseSecond* login_response_second);
  private:
  const ::game::LoginResponseSecond& _internal_login_response_second() const;
  ::game::LoginResponseSecond* _internal_mutable_login_response_second();
  public:
  void unsafe_arena_set_allocated_login_response_second(
      ::game::LoginResponseSecond* login_response_second);
  ::game::LoginResponseSecond* unsafe_arena_release_login_response_second();

  void clear_login_responses();
  LoginResponsesCase login_responses_case() const;
  // @@protoc_insertion_point(class_scope:game.LoginResponse)
 private:
  class _Internal;
  void set_has_login_response_first();
  void set_has_login_response_second();

  inline bool has_login_responses() const;
  inline void clear_has_login_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LoginResponsesUnion {
      constexpr LoginResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::LoginResponseFirst* login_response_first_;
      ::game::LoginResponseSecond* login_response_second_;
    } login_responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginRequestFirst final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginRequestFirst) */ {
 public:
  inline LoginRequestFirst() : LoginRequestFirst(nullptr) {}
  ~LoginRequestFirst() override;
  explicit PROTOBUF_CONSTEXPR LoginRequestFirst(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequestFirst(const LoginRequestFirst& from);
  LoginRequestFirst(LoginRequestFirst&& from) noexcept
    : LoginRequestFirst() {
    *this = ::std::move(from);
  }

  inline LoginRequestFirst& operator=(const LoginRequestFirst& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequestFirst& operator=(LoginRequestFirst&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequestFirst& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequestFirst* internal_default_instance() {
    return reinterpret_cast<const LoginRequestFirst*>(
               &_LoginRequestFirst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginRequestFirst& a, LoginRequestFirst& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequestFirst* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequestFirst* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequestFirst* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequestFirst>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequestFirst& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequestFirst& from) {
    LoginRequestFirst::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequestFirst* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginRequestFirst";
  }
  protected:
  explicit LoginRequestFirst(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:game.LoginRequestFirst)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginRequestSecond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginRequestSecond) */ {
 public:
  inline LoginRequestSecond() : LoginRequestSecond(nullptr) {}
  ~LoginRequestSecond() override;
  explicit PROTOBUF_CONSTEXPR LoginRequestSecond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequestSecond(const LoginRequestSecond& from);
  LoginRequestSecond(LoginRequestSecond&& from) noexcept
    : LoginRequestSecond() {
    *this = ::std::move(from);
  }

  inline LoginRequestSecond& operator=(const LoginRequestSecond& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequestSecond& operator=(LoginRequestSecond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequestSecond& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequestSecond* internal_default_instance() {
    return reinterpret_cast<const LoginRequestSecond*>(
               &_LoginRequestSecond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginRequestSecond& a, LoginRequestSecond& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequestSecond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequestSecond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequestSecond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequestSecond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequestSecond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequestSecond& from) {
    LoginRequestSecond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequestSecond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginRequestSecond";
  }
  protected:
  explicit LoginRequestSecond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kHashedFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string hashed = 2;
  void clear_hashed();
  const std::string& hashed() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hashed(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hashed();
  PROTOBUF_NODISCARD std::string* release_hashed();
  void set_allocated_hashed(std::string* hashed);
  private:
  const std::string& _internal_hashed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hashed(const std::string& value);
  std::string* _internal_mutable_hashed();
  public:

  // @@protoc_insertion_point(class_scope:game.LoginRequestSecond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginResponseFirst final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginResponseFirst) */ {
 public:
  inline LoginResponseFirst() : LoginResponseFirst(nullptr) {}
  ~LoginResponseFirst() override;
  explicit PROTOBUF_CONSTEXPR LoginResponseFirst(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponseFirst(const LoginResponseFirst& from);
  LoginResponseFirst(LoginResponseFirst&& from) noexcept
    : LoginResponseFirst() {
    *this = ::std::move(from);
  }

  inline LoginResponseFirst& operator=(const LoginResponseFirst& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponseFirst& operator=(LoginResponseFirst&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponseFirst& default_instance() {
    return *internal_default_instance();
  }
  enum LoginResponsesFirstCase {
    kSalt = 1,
    kMsg = 2,
    LOGIN_RESPONSES_FIRST_NOT_SET = 0,
  };

  static inline const LoginResponseFirst* internal_default_instance() {
    return reinterpret_cast<const LoginResponseFirst*>(
               &_LoginResponseFirst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginResponseFirst& a, LoginResponseFirst& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponseFirst* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponseFirst* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponseFirst* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponseFirst>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponseFirst& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponseFirst& from) {
    LoginResponseFirst::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponseFirst* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginResponseFirst";
  }
  protected:
  explicit LoginResponseFirst(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaltFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // string salt = 1;
  bool has_salt() const;
  private:
  bool _internal_has_salt() const;
  public:
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  void clear_login_responses_first();
  LoginResponsesFirstCase login_responses_first_case() const;
  // @@protoc_insertion_point(class_scope:game.LoginResponseFirst)
 private:
  class _Internal;
  void set_has_salt();
  void set_has_msg();

  inline bool has_login_responses_first() const;
  inline void clear_has_login_responses_first();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LoginResponsesFirstUnion {
      constexpr LoginResponsesFirstUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
      ::game::ErrorMessage* msg_;
    } login_responses_first_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginResponseSecond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginResponseSecond) */ {
 public:
  inline LoginResponseSecond() : LoginResponseSecond(nullptr) {}
  ~LoginResponseSecond() override;
  explicit PROTOBUF_CONSTEXPR LoginResponseSecond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponseSecond(const LoginResponseSecond& from);
  LoginResponseSecond(LoginResponseSecond&& from) noexcept
    : LoginResponseSecond() {
    *this = ::std::move(from);
  }

  inline LoginResponseSecond& operator=(const LoginResponseSecond& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponseSecond& operator=(LoginResponseSecond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponseSecond& default_instance() {
    return *internal_default_instance();
  }
  enum LoginResponsesSecondCase {
    kPlayerInfo = 1,
    kMsg = 2,
    LOGIN_RESPONSES_SECOND_NOT_SET = 0,
  };

  static inline const LoginResponseSecond* internal_default_instance() {
    return reinterpret_cast<const LoginResponseSecond*>(
               &_LoginResponseSecond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoginResponseSecond& a, LoginResponseSecond& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponseSecond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponseSecond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponseSecond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponseSecond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponseSecond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponseSecond& from) {
    LoginResponseSecond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponseSecond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginResponseSecond";
  }
  protected:
  explicit LoginResponseSecond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // .game.PlayerInfo player_info = 1;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::game::PlayerInfo& player_info() const;
  PROTOBUF_NODISCARD ::game::PlayerInfo* release_player_info();
  ::game::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::game::PlayerInfo* player_info);
  private:
  const ::game::PlayerInfo& _internal_player_info() const;
  ::game::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::game::PlayerInfo* player_info);
  ::game::PlayerInfo* unsafe_arena_release_player_info();

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  void clear_login_responses_second();
  LoginResponsesSecondCase login_responses_second_case() const;
  // @@protoc_insertion_point(class_scope:game.LoginResponseSecond)
 private:
  class _Internal;
  void set_has_player_info();
  void set_has_msg();

  inline bool has_login_responses_second() const;
  inline void clear_has_login_responses_second();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LoginResponsesSecondUnion {
      constexpr LoginResponsesSecondUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::PlayerInfo* player_info_;
      ::game::ErrorMessage* msg_;
    } login_responses_second_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSaltHashFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .game.SaltHash salt_hash = 2;
  bool has_salt_hash() const;
  private:
  bool _internal_has_salt_hash() const;
  public:
  void clear_salt_hash();
  const ::game::SaltHash& salt_hash() const;
  PROTOBUF_NODISCARD ::game::SaltHash* release_salt_hash();
  ::game::SaltHash* mutable_salt_hash();
  void set_allocated_salt_hash(::game::SaltHash* salt_hash);
  private:
  const ::game::SaltHash& _internal_salt_hash() const;
  ::game::SaltHash* _internal_mutable_salt_hash();
  public:
  void unsafe_arena_set_allocated_salt_hash(
      ::game::SaltHash* salt_hash);
  ::game::SaltHash* unsafe_arena_release_salt_hash();

  // @@protoc_insertion_point(class_scope:game.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::game::SaltHash* salt_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  enum RegisterResponsesCase {
    kPlayerInfo = 1,
    kMsg = 2,
    REGISTER_RESPONSES_NOT_SET = 0,
  };

  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterResponse& from) {
    RegisterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // .game.PlayerInfo player_info = 1;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::game::PlayerInfo& player_info() const;
  PROTOBUF_NODISCARD ::game::PlayerInfo* release_player_info();
  ::game::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::game::PlayerInfo* player_info);
  private:
  const ::game::PlayerInfo& _internal_player_info() const;
  ::game::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::game::PlayerInfo* player_info);
  ::game::PlayerInfo* unsafe_arena_release_player_info();

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  void clear_register_responses();
  RegisterResponsesCase register_responses_case() const;
  // @@protoc_insertion_point(class_scope:game.RegisterResponse)
 private:
  class _Internal;
  void set_has_player_info();
  void set_has_msg();

  inline bool has_register_responses() const;
  inline void clear_has_register_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RegisterResponsesUnion {
      constexpr RegisterResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::PlayerInfo* player_info_;
      ::game::ErrorMessage* msg_;
    } register_responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class SaltHash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SaltHash) */ {
 public:
  inline SaltHash() : SaltHash(nullptr) {}
  ~SaltHash() override;
  explicit PROTOBUF_CONSTEXPR SaltHash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaltHash(const SaltHash& from);
  SaltHash(SaltHash&& from) noexcept
    : SaltHash() {
    *this = ::std::move(from);
  }

  inline SaltHash& operator=(const SaltHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaltHash& operator=(SaltHash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaltHash& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaltHash* internal_default_instance() {
    return reinterpret_cast<const SaltHash*>(
               &_SaltHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SaltHash& a, SaltHash& b) {
    a.Swap(&b);
  }
  inline void Swap(SaltHash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaltHash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaltHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaltHash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaltHash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaltHash& from) {
    SaltHash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaltHash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SaltHash";
  }
  protected:
  explicit SaltHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaltFieldNumber = 1,
    kHashFieldNumber = 2,
  };
  // string salt = 1;
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // string hash = 2;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:game.SaltHash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  explicit PROTOBUF_CONSTEXPR Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kStatusFieldNumber = 2,
    kBalanceFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .game.PlayerStatus status = 2;
  void clear_status();
  ::game::PlayerStatus status() const;
  void set_status(::game::PlayerStatus value);
  private:
  ::game::PlayerStatus _internal_status() const;
  void _internal_set_status(::game::PlayerStatus value);
  public:

  // int32 balance = 3;
  void clear_balance();
  int32_t balance() const;
  void set_balance(int32_t value);
  private:
  int32_t _internal_balance() const;
  void _internal_set_balance(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int status_;
    int32_t balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LobbyRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LobbyRequests) */ {
 public:
  inline LobbyRequests() : LobbyRequests(nullptr) {}
  ~LobbyRequests() override;
  explicit PROTOBUF_CONSTEXPR LobbyRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyRequests(const LobbyRequests& from);
  LobbyRequests(LobbyRequests&& from) noexcept
    : LobbyRequests() {
    *this = ::std::move(from);
  }

  inline LobbyRequests& operator=(const LobbyRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyRequests& operator=(LobbyRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyRequests& default_instance() {
    return *internal_default_instance();
  }
  enum RequestsCase {
    kCreateGameRequest = 1,
    kSearchGameRequest = 2,
    REQUESTS_NOT_SET = 0,
  };

  static inline const LobbyRequests* internal_default_instance() {
    return reinterpret_cast<const LobbyRequests*>(
               &_LobbyRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LobbyRequests& a, LobbyRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LobbyRequests& from) {
    LobbyRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LobbyRequests";
  }
  protected:
  explicit LobbyRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateGameRequestFieldNumber = 1,
    kSearchGameRequestFieldNumber = 2,
  };
  // .game.CreateGameRequest create_game_request = 1;
  bool has_create_game_request() const;
  private:
  bool _internal_has_create_game_request() const;
  public:
  void clear_create_game_request();
  const ::game::CreateGameRequest& create_game_request() const;
  PROTOBUF_NODISCARD ::game::CreateGameRequest* release_create_game_request();
  ::game::CreateGameRequest* mutable_create_game_request();
  void set_allocated_create_game_request(::game::CreateGameRequest* create_game_request);
  private:
  const ::game::CreateGameRequest& _internal_create_game_request() const;
  ::game::CreateGameRequest* _internal_mutable_create_game_request();
  public:
  void unsafe_arena_set_allocated_create_game_request(
      ::game::CreateGameRequest* create_game_request);
  ::game::CreateGameRequest* unsafe_arena_release_create_game_request();

  // .game.SearchGameRequest search_game_request = 2;
  bool has_search_game_request() const;
  private:
  bool _internal_has_search_game_request() const;
  public:
  void clear_search_game_request();
  const ::game::SearchGameRequest& search_game_request() const;
  PROTOBUF_NODISCARD ::game::SearchGameRequest* release_search_game_request();
  ::game::SearchGameRequest* mutable_search_game_request();
  void set_allocated_search_game_request(::game::SearchGameRequest* search_game_request);
  private:
  const ::game::SearchGameRequest& _internal_search_game_request() const;
  ::game::SearchGameRequest* _internal_mutable_search_game_request();
  public:
  void unsafe_arena_set_allocated_search_game_request(
      ::game::SearchGameRequest* search_game_request);
  ::game::SearchGameRequest* unsafe_arena_release_search_game_request();

  void clear_requests();
  RequestsCase requests_case() const;
  // @@protoc_insertion_point(class_scope:game.LobbyRequests)
 private:
  class _Internal;
  void set_has_create_game_request();
  void set_has_search_game_request();

  inline bool has_requests() const;
  inline void clear_has_requests();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestsUnion {
      constexpr RequestsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::CreateGameRequest* create_game_request_;
      ::game::SearchGameRequest* search_game_request_;
    } requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LobbyResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LobbyResponses) */ {
 public:
  inline LobbyResponses() : LobbyResponses(nullptr) {}
  ~LobbyResponses() override;
  explicit PROTOBUF_CONSTEXPR LobbyResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyResponses(const LobbyResponses& from);
  LobbyResponses(LobbyResponses&& from) noexcept
    : LobbyResponses() {
    *this = ::std::move(from);
  }

  inline LobbyResponses& operator=(const LobbyResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyResponses& operator=(LobbyResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyResponses& default_instance() {
    return *internal_default_instance();
  }
  enum ResponsesCase {
    kCreateGameResponse = 1,
    kSearchGameResponse = 2,
    RESPONSES_NOT_SET = 0,
  };

  static inline const LobbyResponses* internal_default_instance() {
    return reinterpret_cast<const LobbyResponses*>(
               &_LobbyResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LobbyResponses& a, LobbyResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LobbyResponses& from) {
    LobbyResponses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LobbyResponses";
  }
  protected:
  explicit LobbyResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateGameResponseFieldNumber = 1,
    kSearchGameResponseFieldNumber = 2,
  };
  // .game.CreateGameResponse create_game_response = 1;
  bool has_create_game_response() const;
  private:
  bool _internal_has_create_game_response() const;
  public:
  void clear_create_game_response();
  const ::game::CreateGameResponse& create_game_response() const;
  PROTOBUF_NODISCARD ::game::CreateGameResponse* release_create_game_response();
  ::game::CreateGameResponse* mutable_create_game_response();
  void set_allocated_create_game_response(::game::CreateGameResponse* create_game_response);
  private:
  const ::game::CreateGameResponse& _internal_create_game_response() const;
  ::game::CreateGameResponse* _internal_mutable_create_game_response();
  public:
  void unsafe_arena_set_allocated_create_game_response(
      ::game::CreateGameResponse* create_game_response);
  ::game::CreateGameResponse* unsafe_arena_release_create_game_response();

  // .game.SearchGameResponse search_game_response = 2;
  bool has_search_game_response() const;
  private:
  bool _internal_has_search_game_response() const;
  public:
  void clear_search_game_response();
  const ::game::SearchGameResponse& search_game_response() const;
  PROTOBUF_NODISCARD ::game::SearchGameResponse* release_search_game_response();
  ::game::SearchGameResponse* mutable_search_game_response();
  void set_allocated_search_game_response(::game::SearchGameResponse* search_game_response);
  private:
  const ::game::SearchGameResponse& _internal_search_game_response() const;
  ::game::SearchGameResponse* _internal_mutable_search_game_response();
  public:
  void unsafe_arena_set_allocated_search_game_response(
      ::game::SearchGameResponse* search_game_response);
  ::game::SearchGameResponse* unsafe_arena_release_search_game_response();

  void clear_responses();
  ResponsesCase responses_case() const;
  // @@protoc_insertion_point(class_scope:game.LobbyResponses)
 private:
  class _Internal;
  void set_has_create_game_response();
  void set_has_search_game_response();

  inline bool has_responses() const;
  inline void clear_has_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponsesUnion {
      constexpr ResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::CreateGameResponse* create_game_response_;
      ::game::SearchGameResponse* search_game_response_;
    } responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class CreateGameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CreateGameRequest) */ {
 public:
  inline CreateGameRequest() : CreateGameRequest(nullptr) {}
  ~CreateGameRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGameRequest(const CreateGameRequest& from);
  CreateGameRequest(CreateGameRequest&& from) noexcept
    : CreateGameRequest() {
    *this = ::std::move(from);
  }

  inline CreateGameRequest& operator=(const CreateGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGameRequest& operator=(CreateGameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGameRequest* internal_default_instance() {
    return reinterpret_cast<const CreateGameRequest*>(
               &_CreateGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateGameRequest& a, CreateGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateGameRequest& from) {
    CreateGameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CreateGameRequest";
  }
  protected:
  explicit CreateGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameOwnerFieldNumber = 1,
    kPlayerInfoFieldNumber = 2,
    kGameParametersFieldNumber = 3,
  };
  // string game_owner = 1;
  void clear_game_owner();
  const std::string& game_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_owner();
  PROTOBUF_NODISCARD std::string* release_game_owner();
  void set_allocated_game_owner(std::string* game_owner);
  private:
  const std::string& _internal_game_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_owner(const std::string& value);
  std::string* _internal_mutable_game_owner();
  public:

  // .game.PlayerInfo player_info = 2;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::game::PlayerInfo& player_info() const;
  PROTOBUF_NODISCARD ::game::PlayerInfo* release_player_info();
  ::game::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::game::PlayerInfo* player_info);
  private:
  const ::game::PlayerInfo& _internal_player_info() const;
  ::game::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::game::PlayerInfo* player_info);
  ::game::PlayerInfo* unsafe_arena_release_player_info();

  // .game.GameParameters game_parameters = 3;
  bool has_game_parameters() const;
  private:
  bool _internal_has_game_parameters() const;
  public:
  void clear_game_parameters();
  const ::game::GameParameters& game_parameters() const;
  PROTOBUF_NODISCARD ::game::GameParameters* release_game_parameters();
  ::game::GameParameters* mutable_game_parameters();
  void set_allocated_game_parameters(::game::GameParameters* game_parameters);
  private:
  const ::game::GameParameters& _internal_game_parameters() const;
  ::game::GameParameters* _internal_mutable_game_parameters();
  public:
  void unsafe_arena_set_allocated_game_parameters(
      ::game::GameParameters* game_parameters);
  ::game::GameParameters* unsafe_arena_release_game_parameters();

  // @@protoc_insertion_point(class_scope:game.CreateGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_owner_;
    ::game::PlayerInfo* player_info_;
    ::game::GameParameters* game_parameters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class CreateGameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CreateGameResponse) */ {
 public:
  inline CreateGameResponse() : CreateGameResponse(nullptr) {}
  ~CreateGameResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateGameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGameResponse(const CreateGameResponse& from);
  CreateGameResponse(CreateGameResponse&& from) noexcept
    : CreateGameResponse() {
    *this = ::std::move(from);
  }

  inline CreateGameResponse& operator=(const CreateGameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGameResponse& operator=(CreateGameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGameResponse* internal_default_instance() {
    return reinterpret_cast<const CreateGameResponse*>(
               &_CreateGameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CreateGameResponse& a, CreateGameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateGameResponse& from) {
    CreateGameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CreateGameResponse";
  }
  protected:
  explicit CreateGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kStatusMessageFieldNumber = 1,
  };
  // repeated .game.Player players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::game::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >*
      mutable_players();
  private:
  const ::game::Player& _internal_players(int index) const;
  ::game::Player* _internal_add_players();
  public:
  const ::game::Player& players(int index) const;
  ::game::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >&
      players() const;

  // .game.StatusMessage status_message = 1;
  bool has_status_message() const;
  private:
  bool _internal_has_status_message() const;
  public:
  void clear_status_message();
  const ::game::StatusMessage& status_message() const;
  PROTOBUF_NODISCARD ::game::StatusMessage* release_status_message();
  ::game::StatusMessage* mutable_status_message();
  void set_allocated_status_message(::game::StatusMessage* status_message);
  private:
  const ::game::StatusMessage& _internal_status_message() const;
  ::game::StatusMessage* _internal_mutable_status_message();
  public:
  void unsafe_arena_set_allocated_status_message(
      ::game::StatusMessage* status_message);
  ::game::StatusMessage* unsafe_arena_release_status_message();

  // @@protoc_insertion_point(class_scope:game.CreateGameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player > players_;
    ::game::StatusMessage* status_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class SearchGameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SearchGameRequest) */ {
 public:
  inline SearchGameRequest() : SearchGameRequest(nullptr) {}
  ~SearchGameRequest() override;
  explicit PROTOBUF_CONSTEXPR SearchGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchGameRequest(const SearchGameRequest& from);
  SearchGameRequest(SearchGameRequest&& from) noexcept
    : SearchGameRequest() {
    *this = ::std::move(from);
  }

  inline SearchGameRequest& operator=(const SearchGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchGameRequest& operator=(SearchGameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchGameRequest* internal_default_instance() {
    return reinterpret_cast<const SearchGameRequest*>(
               &_SearchGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SearchGameRequest& a, SearchGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchGameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchGameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchGameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchGameRequest& from) {
    SearchGameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchGameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SearchGameRequest";
  }
  protected:
  explicit SearchGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPlayerInfoFieldNumber = 2,
    kGameParametersFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .game.PlayerInfo player_info = 2;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::game::PlayerInfo& player_info() const;
  PROTOBUF_NODISCARD ::game::PlayerInfo* release_player_info();
  ::game::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::game::PlayerInfo* player_info);
  private:
  const ::game::PlayerInfo& _internal_player_info() const;
  ::game::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::game::PlayerInfo* player_info);
  ::game::PlayerInfo* unsafe_arena_release_player_info();

  // .game.GameParameters game_parameters = 3;
  bool has_game_parameters() const;
  private:
  bool _internal_has_game_parameters() const;
  public:
  void clear_game_parameters();
  const ::game::GameParameters& game_parameters() const;
  PROTOBUF_NODISCARD ::game::GameParameters* release_game_parameters();
  ::game::GameParameters* mutable_game_parameters();
  void set_allocated_game_parameters(::game::GameParameters* game_parameters);
  private:
  const ::game::GameParameters& _internal_game_parameters() const;
  ::game::GameParameters* _internal_mutable_game_parameters();
  public:
  void unsafe_arena_set_allocated_game_parameters(
      ::game::GameParameters* game_parameters);
  ::game::GameParameters* unsafe_arena_release_game_parameters();

  // @@protoc_insertion_point(class_scope:game.SearchGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::game::PlayerInfo* player_info_;
    ::game::GameParameters* game_parameters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class SearchGameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SearchGameResponse) */ {
 public:
  inline SearchGameResponse() : SearchGameResponse(nullptr) {}
  ~SearchGameResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchGameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchGameResponse(const SearchGameResponse& from);
  SearchGameResponse(SearchGameResponse&& from) noexcept
    : SearchGameResponse() {
    *this = ::std::move(from);
  }

  inline SearchGameResponse& operator=(const SearchGameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchGameResponse& operator=(SearchGameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchGameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchGameResponse* internal_default_instance() {
    return reinterpret_cast<const SearchGameResponse*>(
               &_SearchGameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SearchGameResponse& a, SearchGameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchGameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchGameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchGameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchGameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchGameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchGameResponse& from) {
    SearchGameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchGameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SearchGameResponse";
  }
  protected:
  explicit SearchGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kStatusMessageFieldNumber = 1,
  };
  // repeated .game.Player players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::game::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >*
      mutable_players();
  private:
  const ::game::Player& _internal_players(int index) const;
  ::game::Player* _internal_add_players();
  public:
  const ::game::Player& players(int index) const;
  ::game::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >&
      players() const;

  // .game.StatusMessage status_message = 1;
  bool has_status_message() const;
  private:
  bool _internal_has_status_message() const;
  public:
  void clear_status_message();
  const ::game::StatusMessage& status_message() const;
  PROTOBUF_NODISCARD ::game::StatusMessage* release_status_message();
  ::game::StatusMessage* mutable_status_message();
  void set_allocated_status_message(::game::StatusMessage* status_message);
  private:
  const ::game::StatusMessage& _internal_status_message() const;
  ::game::StatusMessage* _internal_mutable_status_message();
  public:
  void unsafe_arena_set_allocated_status_message(
      ::game::StatusMessage* status_message);
  ::game::StatusMessage* unsafe_arena_release_status_message();

  // @@protoc_insertion_point(class_scope:game.SearchGameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player > players_;
    ::game::StatusMessage* status_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.GameRequests) */ {
 public:
  inline GameRequests() : GameRequests(nullptr) {}
  ~GameRequests() override;
  explicit PROTOBUF_CONSTEXPR GameRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameRequests(const GameRequests& from);
  GameRequests(GameRequests&& from) noexcept
    : GameRequests() {
    *this = ::std::move(from);
  }

  inline GameRequests& operator=(const GameRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameRequests& operator=(GameRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameRequests& default_instance() {
    return *internal_default_instance();
  }
  enum RequestsCase {
    kMakeMoveRequest = 1,
    REQUESTS_NOT_SET = 0,
  };

  static inline const GameRequests* internal_default_instance() {
    return reinterpret_cast<const GameRequests*>(
               &_GameRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GameRequests& a, GameRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(GameRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameRequests& from) {
    GameRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.GameRequests";
  }
  protected:
  explicit GameRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakeMoveRequestFieldNumber = 1,
  };
  // .game.MakeMoveRequest MakeMoveRequest = 1;
  bool has_make_move_request() const;
  private:
  bool _internal_has_make_move_request() const;
  public:
  void clear_make_move_request();
  const ::game::make_move_request& make_move_request() const;
  PROTOBUF_NODISCARD ::game::make_move_request* release_make_move_request();
  ::game::make_move_request* mutable_make_move_request();
  void set_allocated_make_move_request(::game::make_move_request* make_move_request);
  private:
  const ::game::make_move_request& _internal_make_move_request() const;
  ::game::make_move_request* _internal_mutable_make_move_request();
  public:
  void unsafe_arena_set_allocated_make_move_request(
      ::game::make_move_request* make_move_request);
  ::game::make_move_request* unsafe_arena_release_make_move_request();

  void clear_requests();
  RequestsCase requests_case() const;
  // @@protoc_insertion_point(class_scope:game.GameRequests)
 private:
  class _Internal;
  void set_has_make_move_request();

  inline bool has_requests() const;
  inline void clear_has_requests();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestsUnion {
      constexpr RequestsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::make_move_request* make_move_request_;
    } requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.GameResponses) */ {
 public:
  inline GameResponses() : GameResponses(nullptr) {}
  ~GameResponses() override;
  explicit PROTOBUF_CONSTEXPR GameResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameResponses(const GameResponses& from);
  GameResponses(GameResponses&& from) noexcept
    : GameResponses() {
    *this = ::std::move(from);
  }

  inline GameResponses& operator=(const GameResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameResponses& operator=(GameResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameResponses& default_instance() {
    return *internal_default_instance();
  }
  enum ResponsesCase {
    kMakeMoveResponse = 1,
    RESPONSES_NOT_SET = 0,
  };

  static inline const GameResponses* internal_default_instance() {
    return reinterpret_cast<const GameResponses*>(
               &_GameResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GameResponses& a, GameResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(GameResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameResponses& from) {
    GameResponses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.GameResponses";
  }
  protected:
  explicit GameResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakeMoveResponseFieldNumber = 1,
  };
  // .game.MakeMoveResponse MakeMoveResponse = 1;
  bool has_make_move_response() const;
  private:
  bool _internal_has_make_move_response() const;
  public:
  void clear_make_move_response();
  const ::game::make_move_response& make_move_response() const;
  PROTOBUF_NODISCARD ::game::make_move_response* release_make_move_response();
  ::game::make_move_response* mutable_make_move_response();
  void set_allocated_make_move_response(::game::make_move_response* make_move_response);
  private:
  const ::game::make_move_response& _internal_make_move_response() const;
  ::game::make_move_response* _internal_mutable_make_move_response();
  public:
  void unsafe_arena_set_allocated_make_move_response(
      ::game::make_move_response* make_move_response);
  ::game::make_move_response* unsafe_arena_release_make_move_response();

  void clear_responses();
  ResponsesCase responses_case() const;
  // @@protoc_insertion_point(class_scope:game.GameResponses)
 private:
  class _Internal;
  void set_has_make_move_response();

  inline bool has_responses() const;
  inline void clear_has_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponsesUnion {
      constexpr ResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::make_move_response* make_move_response_;
    } responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class make_move_request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.MakeMoveRequest) */ {
 public:
  inline make_move_request() : make_move_request(nullptr) {}
  ~make_move_request() override;
  explicit PROTOBUF_CONSTEXPR make_move_request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  make_move_request(const make_move_request& from);
  make_move_request(make_move_request&& from) noexcept
    : make_move_request() {
    *this = ::std::move(from);
  }

  inline make_move_request& operator=(const make_move_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline make_move_request& operator=(make_move_request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const make_move_request& default_instance() {
    return *internal_default_instance();
  }
  static inline const make_move_request* internal_default_instance() {
    return reinterpret_cast<const make_move_request*>(
               &_make_move_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(make_move_request& a, make_move_request& b) {
    a.Swap(&b);
  }
  inline void Swap(make_move_request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(make_move_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  make_move_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<make_move_request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const make_move_request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const make_move_request& from) {
    make_move_request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(make_move_request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.MakeMoveRequest";
  }
  protected:
  explicit make_move_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kMakeBlindFieldNumber = 2,
    kFoldFieldNumber = 3,
  };
  // string client_name = 1;
  void clear_client_name();
  const std::string& client_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // int32 make_blind = 2;
  void clear_make_blind();
  int32_t make_blind() const;
  void set_make_blind(int32_t value);
  private:
  int32_t _internal_make_blind() const;
  void _internal_set_make_blind(int32_t value);
  public:

  // bool fold = 3;
  void clear_fold();
  bool fold() const;
  void set_fold(bool value);
  private:
  bool _internal_fold() const;
  void _internal_set_fold(bool value);
  public:

  // @@protoc_insertion_point(class_scope:game.MakeMoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
    int32_t make_blind_;
    bool fold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class make_move_response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.MakeMoveResponse) */ {
 public:
  inline make_move_response() : make_move_response(nullptr) {}
  ~make_move_response() override;
  explicit PROTOBUF_CONSTEXPR make_move_response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  make_move_response(const make_move_response& from);
  make_move_response(make_move_response&& from) noexcept
    : make_move_response() {
    *this = ::std::move(from);
  }

  inline make_move_response& operator=(const make_move_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline make_move_response& operator=(make_move_response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const make_move_response& default_instance() {
    return *internal_default_instance();
  }
  static inline const make_move_response* internal_default_instance() {
    return reinterpret_cast<const make_move_response*>(
               &_make_move_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(make_move_response& a, make_move_response& b) {
    a.Swap(&b);
  }
  inline void Swap(make_move_response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(make_move_response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  make_move_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<make_move_response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const make_move_response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const make_move_response& from) {
    make_move_response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(make_move_response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.MakeMoveResponse";
  }
  protected:
  explicit make_move_response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .game.Player players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::game::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >*
      mutable_players();
  private:
  const ::game::Player& _internal_players(int index) const;
  ::game::Player* _internal_add_players();
  public:
  const ::game::Player& players(int index) const;
  ::game::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >&
      players() const;

  // @@protoc_insertion_point(class_scope:game.MakeMoveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player > players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.GameParameters) */ {
 public:
  inline GameParameters() : GameParameters(nullptr) {}
  ~GameParameters() override;
  explicit PROTOBUF_CONSTEXPR GameParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameParameters(const GameParameters& from);
  GameParameters(GameParameters&& from) noexcept
    : GameParameters() {
    *this = ::std::move(from);
  }

  inline GameParameters& operator=(const GameParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameParameters& operator=(GameParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameParameters* internal_default_instance() {
    return reinterpret_cast<const GameParameters*>(
               &_GameParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GameParameters& a, GameParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(GameParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameParameters& from) {
    GameParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.GameParameters";
  }
  protected:
  explicit GameParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameNameFieldNumber = 1,
    kNumberOfPlayersFieldNumber = 2,
    kMinimalBetFieldNumber = 3,
    kGameEnterBalanceFieldNumber = 4,
  };
  // string game_name = 1;
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // int32 number_of_players = 2;
  void clear_number_of_players();
  int32_t number_of_players() const;
  void set_number_of_players(int32_t value);
  private:
  int32_t _internal_number_of_players() const;
  void _internal_set_number_of_players(int32_t value);
  public:

  // int32 minimal_bet = 3;
  void clear_minimal_bet();
  int32_t minimal_bet() const;
  void set_minimal_bet(int32_t value);
  private:
  int32_t _internal_minimal_bet() const;
  void _internal_set_minimal_bet(int32_t value);
  public:

  // int32 game_enter_balance = 4;
  void clear_game_enter_balance();
  int32_t game_enter_balance() const;
  void set_game_enter_balance(int32_t value);
  private:
  int32_t _internal_game_enter_balance() const;
  void _internal_set_game_enter_balance(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.GameParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
    int32_t number_of_players_;
    int32_t minimal_bet_;
    int32_t game_enter_balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kClientGamesFieldNumber = 2,
    kClientWinsFieldNumber = 3,
    kClientBalanceFieldNumber = 4,
  };
  // int32 client_id = 1;
  void clear_client_id();
  int32_t client_id() const;
  void set_client_id(int32_t value);
  private:
  int32_t _internal_client_id() const;
  void _internal_set_client_id(int32_t value);
  public:

  // int32 client_games = 2;
  void clear_client_games();
  int32_t client_games() const;
  void set_client_games(int32_t value);
  private:
  int32_t _internal_client_games() const;
  void _internal_set_client_games(int32_t value);
  public:

  // int32 client_wins = 3;
  void clear_client_wins();
  int32_t client_wins() const;
  void set_client_wins(int32_t value);
  private:
  int32_t _internal_client_wins() const;
  void _internal_set_client_wins(int32_t value);
  public:

  // int32 client_balance = 4;
  void clear_client_balance();
  int32_t client_balance() const;
  void set_client_balance(int32_t value);
  private:
  int32_t _internal_client_balance() const;
  void _internal_set_client_balance(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t client_id_;
    int32_t client_games_;
    int32_t client_wins_;
    int32_t client_balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StatusMessage

// bool status = 1;
inline void StatusMessage::clear_status() {
  _impl_.status_ = false;
}
inline bool StatusMessage::_internal_status() const {
  return _impl_.status_;
}
inline bool StatusMessage::status() const {
  // @@protoc_insertion_point(field_get:game.StatusMessage.status)
  return _internal_status();
}
inline void StatusMessage::_internal_set_status(bool value) {
  
  _impl_.status_ = value;
}
inline void StatusMessage::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:game.StatusMessage.status)
}

// string message = 2;
inline void StatusMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& StatusMessage::message() const {
  // @@protoc_insertion_point(field_get:game.StatusMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.StatusMessage.message)
}
inline std::string* StatusMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:game.StatusMessage.message)
  return _s;
}
inline const std::string& StatusMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void StatusMessage::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusMessage::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusMessage::release_message() {
  // @@protoc_insertion_point(field_release:game.StatusMessage.message)
  return _impl_.message_.Release();
}
inline void StatusMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.StatusMessage.message)
}

// -------------------------------------------------------------------

// ErrorMessage

// .game.error error = 1;
inline void ErrorMessage::clear_error() {
  _impl_.error_ = 0;
}
inline ::game::error ErrorMessage::_internal_error() const {
  return static_cast< ::game::error >(_impl_.error_);
}
inline ::game::error ErrorMessage::error() const {
  // @@protoc_insertion_point(field_get:game.ErrorMessage.error)
  return _internal_error();
}
inline void ErrorMessage::_internal_set_error(::game::error value) {
  
  _impl_.error_ = value;
}
inline void ErrorMessage::set_error(::game::error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:game.ErrorMessage.error)
}

// optional string message_string = 2;
inline bool ErrorMessage::_internal_has_message_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErrorMessage::has_message_string() const {
  return _internal_has_message_string();
}
inline void ErrorMessage::clear_message_string() {
  _impl_.message_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorMessage::message_string() const {
  // @@protoc_insertion_point(field_get:game.ErrorMessage.message_string)
  return _internal_message_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorMessage::set_message_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.ErrorMessage.message_string)
}
inline std::string* ErrorMessage::mutable_message_string() {
  std::string* _s = _internal_mutable_message_string();
  // @@protoc_insertion_point(field_mutable:game.ErrorMessage.message_string)
  return _s;
}
inline const std::string& ErrorMessage::_internal_message_string() const {
  return _impl_.message_string_.Get();
}
inline void ErrorMessage::_internal_set_message_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorMessage::_internal_mutable_message_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_string_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorMessage::release_message_string() {
  // @@protoc_insertion_point(field_release:game.ErrorMessage.message_string)
  if (!_internal_has_message_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_string_.IsDefault()) {
    _impl_.message_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ErrorMessage::set_allocated_message_string(std::string* message_string) {
  if (message_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_string_.SetAllocated(message_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_string_.IsDefault()) {
    _impl_.message_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.ErrorMessage.message_string)
}

// -------------------------------------------------------------------

// LoginRequest

// .game.LoginRequestFirst login_request_first = 1;
inline bool LoginRequest::_internal_has_login_request_first() const {
  return login_requests_case() == kLoginRequestFirst;
}
inline bool LoginRequest::has_login_request_first() const {
  return _internal_has_login_request_first();
}
inline void LoginRequest::set_has_login_request_first() {
  _impl_._oneof_case_[0] = kLoginRequestFirst;
}
inline void LoginRequest::clear_login_request_first() {
  if (_internal_has_login_request_first()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_requests_.login_request_first_;
    }
    clear_has_login_requests();
  }
}
inline ::game::LoginRequestFirst* LoginRequest::release_login_request_first() {
  // @@protoc_insertion_point(field_release:game.LoginRequest.login_request_first)
  if (_internal_has_login_request_first()) {
    clear_has_login_requests();
    ::game::LoginRequestFirst* temp = _impl_.login_requests_.login_request_first_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_requests_.login_request_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginRequestFirst& LoginRequest::_internal_login_request_first() const {
  return _internal_has_login_request_first()
      ? *_impl_.login_requests_.login_request_first_
      : reinterpret_cast< ::game::LoginRequestFirst&>(::game::_LoginRequestFirst_default_instance_);
}
inline const ::game::LoginRequestFirst& LoginRequest::login_request_first() const {
  // @@protoc_insertion_point(field_get:game.LoginRequest.login_request_first)
  return _internal_login_request_first();
}
inline ::game::LoginRequestFirst* LoginRequest::unsafe_arena_release_login_request_first() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginRequest.login_request_first)
  if (_internal_has_login_request_first()) {
    clear_has_login_requests();
    ::game::LoginRequestFirst* temp = _impl_.login_requests_.login_request_first_;
    _impl_.login_requests_.login_request_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginRequest::unsafe_arena_set_allocated_login_request_first(::game::LoginRequestFirst* login_request_first) {
  clear_login_requests();
  if (login_request_first) {
    set_has_login_request_first();
    _impl_.login_requests_.login_request_first_ = login_request_first;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginRequest.login_request_first)
}
inline ::game::LoginRequestFirst* LoginRequest::_internal_mutable_login_request_first() {
  if (!_internal_has_login_request_first()) {
    clear_login_requests();
    set_has_login_request_first();
    _impl_.login_requests_.login_request_first_ = CreateMaybeMessage< ::game::LoginRequestFirst >(GetArenaForAllocation());
  }
  return _impl_.login_requests_.login_request_first_;
}
inline ::game::LoginRequestFirst* LoginRequest::mutable_login_request_first() {
  ::game::LoginRequestFirst* _msg = _internal_mutable_login_request_first();
  // @@protoc_insertion_point(field_mutable:game.LoginRequest.login_request_first)
  return _msg;
}

// .game.LoginRequestSecond login_request_second = 2;
inline bool LoginRequest::_internal_has_login_request_second() const {
  return login_requests_case() == kLoginRequestSecond;
}
inline bool LoginRequest::has_login_request_second() const {
  return _internal_has_login_request_second();
}
inline void LoginRequest::set_has_login_request_second() {
  _impl_._oneof_case_[0] = kLoginRequestSecond;
}
inline void LoginRequest::clear_login_request_second() {
  if (_internal_has_login_request_second()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_requests_.login_request_second_;
    }
    clear_has_login_requests();
  }
}
inline ::game::LoginRequestSecond* LoginRequest::release_login_request_second() {
  // @@protoc_insertion_point(field_release:game.LoginRequest.login_request_second)
  if (_internal_has_login_request_second()) {
    clear_has_login_requests();
    ::game::LoginRequestSecond* temp = _impl_.login_requests_.login_request_second_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_requests_.login_request_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginRequestSecond& LoginRequest::_internal_login_request_second() const {
  return _internal_has_login_request_second()
      ? *_impl_.login_requests_.login_request_second_
      : reinterpret_cast< ::game::LoginRequestSecond&>(::game::_LoginRequestSecond_default_instance_);
}
inline const ::game::LoginRequestSecond& LoginRequest::login_request_second() const {
  // @@protoc_insertion_point(field_get:game.LoginRequest.login_request_second)
  return _internal_login_request_second();
}
inline ::game::LoginRequestSecond* LoginRequest::unsafe_arena_release_login_request_second() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginRequest.login_request_second)
  if (_internal_has_login_request_second()) {
    clear_has_login_requests();
    ::game::LoginRequestSecond* temp = _impl_.login_requests_.login_request_second_;
    _impl_.login_requests_.login_request_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginRequest::unsafe_arena_set_allocated_login_request_second(::game::LoginRequestSecond* login_request_second) {
  clear_login_requests();
  if (login_request_second) {
    set_has_login_request_second();
    _impl_.login_requests_.login_request_second_ = login_request_second;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginRequest.login_request_second)
}
inline ::game::LoginRequestSecond* LoginRequest::_internal_mutable_login_request_second() {
  if (!_internal_has_login_request_second()) {
    clear_login_requests();
    set_has_login_request_second();
    _impl_.login_requests_.login_request_second_ = CreateMaybeMessage< ::game::LoginRequestSecond >(GetArenaForAllocation());
  }
  return _impl_.login_requests_.login_request_second_;
}
inline ::game::LoginRequestSecond* LoginRequest::mutable_login_request_second() {
  ::game::LoginRequestSecond* _msg = _internal_mutable_login_request_second();
  // @@protoc_insertion_point(field_mutable:game.LoginRequest.login_request_second)
  return _msg;
}

inline bool LoginRequest::has_login_requests() const {
  return login_requests_case() != LOGIN_REQUESTS_NOT_SET;
}
inline void LoginRequest::clear_has_login_requests() {
  _impl_._oneof_case_[0] = LOGIN_REQUESTS_NOT_SET;
}
inline LoginRequest::LoginRequestsCase LoginRequest::login_requests_case() const {
  return LoginRequest::LoginRequestsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginResponse

// .game.LoginResponseFirst login_response_first = 1;
inline bool LoginResponse::_internal_has_login_response_first() const {
  return login_responses_case() == kLoginResponseFirst;
}
inline bool LoginResponse::has_login_response_first() const {
  return _internal_has_login_response_first();
}
inline void LoginResponse::set_has_login_response_first() {
  _impl_._oneof_case_[0] = kLoginResponseFirst;
}
inline void LoginResponse::clear_login_response_first() {
  if (_internal_has_login_response_first()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_.login_response_first_;
    }
    clear_has_login_responses();
  }
}
inline ::game::LoginResponseFirst* LoginResponse::release_login_response_first() {
  // @@protoc_insertion_point(field_release:game.LoginResponse.login_response_first)
  if (_internal_has_login_response_first()) {
    clear_has_login_responses();
    ::game::LoginResponseFirst* temp = _impl_.login_responses_.login_response_first_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_.login_response_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginResponseFirst& LoginResponse::_internal_login_response_first() const {
  return _internal_has_login_response_first()
      ? *_impl_.login_responses_.login_response_first_
      : reinterpret_cast< ::game::LoginResponseFirst&>(::game::_LoginResponseFirst_default_instance_);
}
inline const ::game::LoginResponseFirst& LoginResponse::login_response_first() const {
  // @@protoc_insertion_point(field_get:game.LoginResponse.login_response_first)
  return _internal_login_response_first();
}
inline ::game::LoginResponseFirst* LoginResponse::unsafe_arena_release_login_response_first() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponse.login_response_first)
  if (_internal_has_login_response_first()) {
    clear_has_login_responses();
    ::game::LoginResponseFirst* temp = _impl_.login_responses_.login_response_first_;
    _impl_.login_responses_.login_response_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponse::unsafe_arena_set_allocated_login_response_first(::game::LoginResponseFirst* login_response_first) {
  clear_login_responses();
  if (login_response_first) {
    set_has_login_response_first();
    _impl_.login_responses_.login_response_first_ = login_response_first;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponse.login_response_first)
}
inline ::game::LoginResponseFirst* LoginResponse::_internal_mutable_login_response_first() {
  if (!_internal_has_login_response_first()) {
    clear_login_responses();
    set_has_login_response_first();
    _impl_.login_responses_.login_response_first_ = CreateMaybeMessage< ::game::LoginResponseFirst >(GetArenaForAllocation());
  }
  return _impl_.login_responses_.login_response_first_;
}
inline ::game::LoginResponseFirst* LoginResponse::mutable_login_response_first() {
  ::game::LoginResponseFirst* _msg = _internal_mutable_login_response_first();
  // @@protoc_insertion_point(field_mutable:game.LoginResponse.login_response_first)
  return _msg;
}

// .game.LoginResponseSecond login_response_second = 2;
inline bool LoginResponse::_internal_has_login_response_second() const {
  return login_responses_case() == kLoginResponseSecond;
}
inline bool LoginResponse::has_login_response_second() const {
  return _internal_has_login_response_second();
}
inline void LoginResponse::set_has_login_response_second() {
  _impl_._oneof_case_[0] = kLoginResponseSecond;
}
inline void LoginResponse::clear_login_response_second() {
  if (_internal_has_login_response_second()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_.login_response_second_;
    }
    clear_has_login_responses();
  }
}
inline ::game::LoginResponseSecond* LoginResponse::release_login_response_second() {
  // @@protoc_insertion_point(field_release:game.LoginResponse.login_response_second)
  if (_internal_has_login_response_second()) {
    clear_has_login_responses();
    ::game::LoginResponseSecond* temp = _impl_.login_responses_.login_response_second_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_.login_response_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginResponseSecond& LoginResponse::_internal_login_response_second() const {
  return _internal_has_login_response_second()
      ? *_impl_.login_responses_.login_response_second_
      : reinterpret_cast< ::game::LoginResponseSecond&>(::game::_LoginResponseSecond_default_instance_);
}
inline const ::game::LoginResponseSecond& LoginResponse::login_response_second() const {
  // @@protoc_insertion_point(field_get:game.LoginResponse.login_response_second)
  return _internal_login_response_second();
}
inline ::game::LoginResponseSecond* LoginResponse::unsafe_arena_release_login_response_second() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponse.login_response_second)
  if (_internal_has_login_response_second()) {
    clear_has_login_responses();
    ::game::LoginResponseSecond* temp = _impl_.login_responses_.login_response_second_;
    _impl_.login_responses_.login_response_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponse::unsafe_arena_set_allocated_login_response_second(::game::LoginResponseSecond* login_response_second) {
  clear_login_responses();
  if (login_response_second) {
    set_has_login_response_second();
    _impl_.login_responses_.login_response_second_ = login_response_second;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponse.login_response_second)
}
inline ::game::LoginResponseSecond* LoginResponse::_internal_mutable_login_response_second() {
  if (!_internal_has_login_response_second()) {
    clear_login_responses();
    set_has_login_response_second();
    _impl_.login_responses_.login_response_second_ = CreateMaybeMessage< ::game::LoginResponseSecond >(GetArenaForAllocation());
  }
  return _impl_.login_responses_.login_response_second_;
}
inline ::game::LoginResponseSecond* LoginResponse::mutable_login_response_second() {
  ::game::LoginResponseSecond* _msg = _internal_mutable_login_response_second();
  // @@protoc_insertion_point(field_mutable:game.LoginResponse.login_response_second)
  return _msg;
}

inline bool LoginResponse::has_login_responses() const {
  return login_responses_case() != LOGIN_RESPONSES_NOT_SET;
}
inline void LoginResponse::clear_has_login_responses() {
  _impl_._oneof_case_[0] = LOGIN_RESPONSES_NOT_SET;
}
inline LoginResponse::LoginResponsesCase LoginResponse::login_responses_case() const {
  return LoginResponse::LoginResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginRequestFirst

// string name = 1;
inline void LoginRequestFirst::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LoginRequestFirst::name() const {
  // @@protoc_insertion_point(field_get:game.LoginRequestFirst.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequestFirst::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.LoginRequestFirst.name)
}
inline std::string* LoginRequestFirst::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.LoginRequestFirst.name)
  return _s;
}
inline const std::string& LoginRequestFirst::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LoginRequestFirst::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequestFirst::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequestFirst::release_name() {
  // @@protoc_insertion_point(field_release:game.LoginRequestFirst.name)
  return _impl_.name_.Release();
}
inline void LoginRequestFirst::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequestFirst.name)
}

// -------------------------------------------------------------------

// LoginRequestSecond

// string name = 1;
inline void LoginRequestSecond::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LoginRequestSecond::name() const {
  // @@protoc_insertion_point(field_get:game.LoginRequestSecond.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequestSecond::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.LoginRequestSecond.name)
}
inline std::string* LoginRequestSecond::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.LoginRequestSecond.name)
  return _s;
}
inline const std::string& LoginRequestSecond::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LoginRequestSecond::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequestSecond::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequestSecond::release_name() {
  // @@protoc_insertion_point(field_release:game.LoginRequestSecond.name)
  return _impl_.name_.Release();
}
inline void LoginRequestSecond::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequestSecond.name)
}

// string hashed = 2;
inline void LoginRequestSecond::clear_hashed() {
  _impl_.hashed_.ClearToEmpty();
}
inline const std::string& LoginRequestSecond::hashed() const {
  // @@protoc_insertion_point(field_get:game.LoginRequestSecond.hashed)
  return _internal_hashed();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequestSecond::set_hashed(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hashed_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.LoginRequestSecond.hashed)
}
inline std::string* LoginRequestSecond::mutable_hashed() {
  std::string* _s = _internal_mutable_hashed();
  // @@protoc_insertion_point(field_mutable:game.LoginRequestSecond.hashed)
  return _s;
}
inline const std::string& LoginRequestSecond::_internal_hashed() const {
  return _impl_.hashed_.Get();
}
inline void LoginRequestSecond::_internal_set_hashed(const std::string& value) {
  
  _impl_.hashed_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequestSecond::_internal_mutable_hashed() {
  
  return _impl_.hashed_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequestSecond::release_hashed() {
  // @@protoc_insertion_point(field_release:game.LoginRequestSecond.hashed)
  return _impl_.hashed_.Release();
}
inline void LoginRequestSecond::set_allocated_hashed(std::string* hashed) {
  if (hashed != nullptr) {
    
  } else {
    
  }
  _impl_.hashed_.SetAllocated(hashed, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hashed_.IsDefault()) {
    _impl_.hashed_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequestSecond.hashed)
}

// -------------------------------------------------------------------

// LoginResponseFirst

// string salt = 1;
inline bool LoginResponseFirst::_internal_has_salt() const {
  return login_responses_first_case() == kSalt;
}
inline bool LoginResponseFirst::has_salt() const {
  return _internal_has_salt();
}
inline void LoginResponseFirst::set_has_salt() {
  _impl_._oneof_case_[0] = kSalt;
}
inline void LoginResponseFirst::clear_salt() {
  if (_internal_has_salt()) {
    _impl_.login_responses_first_.salt_.Destroy();
    clear_has_login_responses_first();
  }
}
inline const std::string& LoginResponseFirst::salt() const {
  // @@protoc_insertion_point(field_get:game.LoginResponseFirst.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline void LoginResponseFirst::set_salt(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_salt()) {
    clear_login_responses_first();
    set_has_salt();
    _impl_.login_responses_first_.salt_.InitDefault();
  }
  _impl_.login_responses_first_.salt_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.LoginResponseFirst.salt)
}
inline std::string* LoginResponseFirst::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:game.LoginResponseFirst.salt)
  return _s;
}
inline const std::string& LoginResponseFirst::_internal_salt() const {
  if (_internal_has_salt()) {
    return _impl_.login_responses_first_.salt_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LoginResponseFirst::_internal_set_salt(const std::string& value) {
  if (!_internal_has_salt()) {
    clear_login_responses_first();
    set_has_salt();
    _impl_.login_responses_first_.salt_.InitDefault();
  }
  _impl_.login_responses_first_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponseFirst::_internal_mutable_salt() {
  if (!_internal_has_salt()) {
    clear_login_responses_first();
    set_has_salt();
    _impl_.login_responses_first_.salt_.InitDefault();
  }
  return _impl_.login_responses_first_.salt_.Mutable(      GetArenaForAllocation());
}
inline std::string* LoginResponseFirst::release_salt() {
  // @@protoc_insertion_point(field_release:game.LoginResponseFirst.salt)
  if (_internal_has_salt()) {
    clear_has_login_responses_first();
    return _impl_.login_responses_first_.salt_.Release();
  } else {
    return nullptr;
  }
}
inline void LoginResponseFirst::set_allocated_salt(std::string* salt) {
  if (has_login_responses_first()) {
    clear_login_responses_first();
  }
  if (salt != nullptr) {
    set_has_salt();
    _impl_.login_responses_first_.salt_.InitAllocated(salt, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:game.LoginResponseFirst.salt)
}

// .game.ErrorMessage msg = 2;
inline bool LoginResponseFirst::_internal_has_msg() const {
  return login_responses_first_case() == kMsg;
}
inline bool LoginResponseFirst::has_msg() const {
  return _internal_has_msg();
}
inline void LoginResponseFirst::set_has_msg() {
  _impl_._oneof_case_[0] = kMsg;
}
inline void LoginResponseFirst::clear_msg() {
  if (_internal_has_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_first_.msg_;
    }
    clear_has_login_responses_first();
  }
}
inline ::game::ErrorMessage* LoginResponseFirst::release_msg() {
  // @@protoc_insertion_point(field_release:game.LoginResponseFirst.msg)
  if (_internal_has_msg()) {
    clear_has_login_responses_first();
    ::game::ErrorMessage* temp = _impl_.login_responses_first_.msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_first_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ErrorMessage& LoginResponseFirst::_internal_msg() const {
  return _internal_has_msg()
      ? *_impl_.login_responses_first_.msg_
      : reinterpret_cast< ::game::ErrorMessage&>(::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& LoginResponseFirst::msg() const {
  // @@protoc_insertion_point(field_get:game.LoginResponseFirst.msg)
  return _internal_msg();
}
inline ::game::ErrorMessage* LoginResponseFirst::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponseFirst.msg)
  if (_internal_has_msg()) {
    clear_has_login_responses_first();
    ::game::ErrorMessage* temp = _impl_.login_responses_first_.msg_;
    _impl_.login_responses_first_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponseFirst::unsafe_arena_set_allocated_msg(::game::ErrorMessage* msg) {
  clear_login_responses_first();
  if (msg) {
    set_has_msg();
    _impl_.login_responses_first_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponseFirst.msg)
}
inline ::game::ErrorMessage* LoginResponseFirst::_internal_mutable_msg() {
  if (!_internal_has_msg()) {
    clear_login_responses_first();
    set_has_msg();
    _impl_.login_responses_first_.msg_ = CreateMaybeMessage< ::game::ErrorMessage >(GetArenaForAllocation());
  }
  return _impl_.login_responses_first_.msg_;
}
inline ::game::ErrorMessage* LoginResponseFirst::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.LoginResponseFirst.msg)
  return _msg;
}

inline bool LoginResponseFirst::has_login_responses_first() const {
  return login_responses_first_case() != LOGIN_RESPONSES_FIRST_NOT_SET;
}
inline void LoginResponseFirst::clear_has_login_responses_first() {
  _impl_._oneof_case_[0] = LOGIN_RESPONSES_FIRST_NOT_SET;
}
inline LoginResponseFirst::LoginResponsesFirstCase LoginResponseFirst::login_responses_first_case() const {
  return LoginResponseFirst::LoginResponsesFirstCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginResponseSecond

// .game.PlayerInfo player_info = 1;
inline bool LoginResponseSecond::_internal_has_player_info() const {
  return login_responses_second_case() == kPlayerInfo;
}
inline bool LoginResponseSecond::has_player_info() const {
  return _internal_has_player_info();
}
inline void LoginResponseSecond::set_has_player_info() {
  _impl_._oneof_case_[0] = kPlayerInfo;
}
inline void LoginResponseSecond::clear_player_info() {
  if (_internal_has_player_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_second_.player_info_;
    }
    clear_has_login_responses_second();
  }
}
inline ::game::PlayerInfo* LoginResponseSecond::release_player_info() {
  // @@protoc_insertion_point(field_release:game.LoginResponseSecond.player_info)
  if (_internal_has_player_info()) {
    clear_has_login_responses_second();
    ::game::PlayerInfo* temp = _impl_.login_responses_second_.player_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_second_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::PlayerInfo& LoginResponseSecond::_internal_player_info() const {
  return _internal_has_player_info()
      ? *_impl_.login_responses_second_.player_info_
      : reinterpret_cast< ::game::PlayerInfo&>(::game::_PlayerInfo_default_instance_);
}
inline const ::game::PlayerInfo& LoginResponseSecond::player_info() const {
  // @@protoc_insertion_point(field_get:game.LoginResponseSecond.player_info)
  return _internal_player_info();
}
inline ::game::PlayerInfo* LoginResponseSecond::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponseSecond.player_info)
  if (_internal_has_player_info()) {
    clear_has_login_responses_second();
    ::game::PlayerInfo* temp = _impl_.login_responses_second_.player_info_;
    _impl_.login_responses_second_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponseSecond::unsafe_arena_set_allocated_player_info(::game::PlayerInfo* player_info) {
  clear_login_responses_second();
  if (player_info) {
    set_has_player_info();
    _impl_.login_responses_second_.player_info_ = player_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponseSecond.player_info)
}
inline ::game::PlayerInfo* LoginResponseSecond::_internal_mutable_player_info() {
  if (!_internal_has_player_info()) {
    clear_login_responses_second();
    set_has_player_info();
    _impl_.login_responses_second_.player_info_ = CreateMaybeMessage< ::game::PlayerInfo >(GetArenaForAllocation());
  }
  return _impl_.login_responses_second_.player_info_;
}
inline ::game::PlayerInfo* LoginResponseSecond::mutable_player_info() {
  ::game::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:game.LoginResponseSecond.player_info)
  return _msg;
}

// .game.ErrorMessage msg = 2;
inline bool LoginResponseSecond::_internal_has_msg() const {
  return login_responses_second_case() == kMsg;
}
inline bool LoginResponseSecond::has_msg() const {
  return _internal_has_msg();
}
inline void LoginResponseSecond::set_has_msg() {
  _impl_._oneof_case_[0] = kMsg;
}
inline void LoginResponseSecond::clear_msg() {
  if (_internal_has_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_second_.msg_;
    }
    clear_has_login_responses_second();
  }
}
inline ::game::ErrorMessage* LoginResponseSecond::release_msg() {
  // @@protoc_insertion_point(field_release:game.LoginResponseSecond.msg)
  if (_internal_has_msg()) {
    clear_has_login_responses_second();
    ::game::ErrorMessage* temp = _impl_.login_responses_second_.msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_second_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ErrorMessage& LoginResponseSecond::_internal_msg() const {
  return _internal_has_msg()
      ? *_impl_.login_responses_second_.msg_
      : reinterpret_cast< ::game::ErrorMessage&>(::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& LoginResponseSecond::msg() const {
  // @@protoc_insertion_point(field_get:game.LoginResponseSecond.msg)
  return _internal_msg();
}
inline ::game::ErrorMessage* LoginResponseSecond::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponseSecond.msg)
  if (_internal_has_msg()) {
    clear_has_login_responses_second();
    ::game::ErrorMessage* temp = _impl_.login_responses_second_.msg_;
    _impl_.login_responses_second_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponseSecond::unsafe_arena_set_allocated_msg(::game::ErrorMessage* msg) {
  clear_login_responses_second();
  if (msg) {
    set_has_msg();
    _impl_.login_responses_second_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponseSecond.msg)
}
inline ::game::ErrorMessage* LoginResponseSecond::_internal_mutable_msg() {
  if (!_internal_has_msg()) {
    clear_login_responses_second();
    set_has_msg();
    _impl_.login_responses_second_.msg_ = CreateMaybeMessage< ::game::ErrorMessage >(GetArenaForAllocation());
  }
  return _impl_.login_responses_second_.msg_;
}
inline ::game::ErrorMessage* LoginResponseSecond::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.LoginResponseSecond.msg)
  return _msg;
}

inline bool LoginResponseSecond::has_login_responses_second() const {
  return login_responses_second_case() != LOGIN_RESPONSES_SECOND_NOT_SET;
}
inline void LoginResponseSecond::clear_has_login_responses_second() {
  _impl_._oneof_case_[0] = LOGIN_RESPONSES_SECOND_NOT_SET;
}
inline LoginResponseSecond::LoginResponsesSecondCase LoginResponseSecond::login_responses_second_case() const {
  return LoginResponseSecond::LoginResponsesSecondCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegisterRequest

// string name = 1;
inline void RegisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RegisterRequest::name() const {
  // @@protoc_insertion_point(field_get:game.RegisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.RegisterRequest.name)
}
inline std::string* RegisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.RegisterRequest.name)
  return _s;
}
inline const std::string& RegisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RegisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:game.RegisterRequest.name)
  return _impl_.name_.Release();
}
inline void RegisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.RegisterRequest.name)
}

// .game.SaltHash salt_hash = 2;
inline bool RegisterRequest::_internal_has_salt_hash() const {
  return this != internal_default_instance() && _impl_.salt_hash_ != nullptr;
}
inline bool RegisterRequest::has_salt_hash() const {
  return _internal_has_salt_hash();
}
inline void RegisterRequest::clear_salt_hash() {
  if (GetArenaForAllocation() == nullptr && _impl_.salt_hash_ != nullptr) {
    delete _impl_.salt_hash_;
  }
  _impl_.salt_hash_ = nullptr;
}
inline const ::game::SaltHash& RegisterRequest::_internal_salt_hash() const {
  const ::game::SaltHash* p = _impl_.salt_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::SaltHash&>(
      ::game::_SaltHash_default_instance_);
}
inline const ::game::SaltHash& RegisterRequest::salt_hash() const {
  // @@protoc_insertion_point(field_get:game.RegisterRequest.salt_hash)
  return _internal_salt_hash();
}
inline void RegisterRequest::unsafe_arena_set_allocated_salt_hash(
    ::game::SaltHash* salt_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.salt_hash_);
  }
  _impl_.salt_hash_ = salt_hash;
  if (salt_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.RegisterRequest.salt_hash)
}
inline ::game::SaltHash* RegisterRequest::release_salt_hash() {
  
  ::game::SaltHash* temp = _impl_.salt_hash_;
  _impl_.salt_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::SaltHash* RegisterRequest::unsafe_arena_release_salt_hash() {
  // @@protoc_insertion_point(field_release:game.RegisterRequest.salt_hash)
  
  ::game::SaltHash* temp = _impl_.salt_hash_;
  _impl_.salt_hash_ = nullptr;
  return temp;
}
inline ::game::SaltHash* RegisterRequest::_internal_mutable_salt_hash() {
  
  if (_impl_.salt_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::SaltHash>(GetArenaForAllocation());
    _impl_.salt_hash_ = p;
  }
  return _impl_.salt_hash_;
}
inline ::game::SaltHash* RegisterRequest::mutable_salt_hash() {
  ::game::SaltHash* _msg = _internal_mutable_salt_hash();
  // @@protoc_insertion_point(field_mutable:game.RegisterRequest.salt_hash)
  return _msg;
}
inline void RegisterRequest::set_allocated_salt_hash(::game::SaltHash* salt_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.salt_hash_;
  }
  if (salt_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(salt_hash);
    if (message_arena != submessage_arena) {
      salt_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, salt_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.salt_hash_ = salt_hash;
  // @@protoc_insertion_point(field_set_allocated:game.RegisterRequest.salt_hash)
}

// -------------------------------------------------------------------

// RegisterResponse

// .game.PlayerInfo player_info = 1;
inline bool RegisterResponse::_internal_has_player_info() const {
  return register_responses_case() == kPlayerInfo;
}
inline bool RegisterResponse::has_player_info() const {
  return _internal_has_player_info();
}
inline void RegisterResponse::set_has_player_info() {
  _impl_._oneof_case_[0] = kPlayerInfo;
}
inline void RegisterResponse::clear_player_info() {
  if (_internal_has_player_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.register_responses_.player_info_;
    }
    clear_has_register_responses();
  }
}
inline ::game::PlayerInfo* RegisterResponse::release_player_info() {
  // @@protoc_insertion_point(field_release:game.RegisterResponse.player_info)
  if (_internal_has_player_info()) {
    clear_has_register_responses();
    ::game::PlayerInfo* temp = _impl_.register_responses_.player_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.register_responses_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::PlayerInfo& RegisterResponse::_internal_player_info() const {
  return _internal_has_player_info()
      ? *_impl_.register_responses_.player_info_
      : reinterpret_cast< ::game::PlayerInfo&>(::game::_PlayerInfo_default_instance_);
}
inline const ::game::PlayerInfo& RegisterResponse::player_info() const {
  // @@protoc_insertion_point(field_get:game.RegisterResponse.player_info)
  return _internal_player_info();
}
inline ::game::PlayerInfo* RegisterResponse::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.RegisterResponse.player_info)
  if (_internal_has_player_info()) {
    clear_has_register_responses();
    ::game::PlayerInfo* temp = _impl_.register_responses_.player_info_;
    _impl_.register_responses_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegisterResponse::unsafe_arena_set_allocated_player_info(::game::PlayerInfo* player_info) {
  clear_register_responses();
  if (player_info) {
    set_has_player_info();
    _impl_.register_responses_.player_info_ = player_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.RegisterResponse.player_info)
}
inline ::game::PlayerInfo* RegisterResponse::_internal_mutable_player_info() {
  if (!_internal_has_player_info()) {
    clear_register_responses();
    set_has_player_info();
    _impl_.register_responses_.player_info_ = CreateMaybeMessage< ::game::PlayerInfo >(GetArenaForAllocation());
  }
  return _impl_.register_responses_.player_info_;
}
inline ::game::PlayerInfo* RegisterResponse::mutable_player_info() {
  ::game::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:game.RegisterResponse.player_info)
  return _msg;
}

// .game.ErrorMessage msg = 2;
inline bool RegisterResponse::_internal_has_msg() const {
  return register_responses_case() == kMsg;
}
inline bool RegisterResponse::has_msg() const {
  return _internal_has_msg();
}
inline void RegisterResponse::set_has_msg() {
  _impl_._oneof_case_[0] = kMsg;
}
inline void RegisterResponse::clear_msg() {
  if (_internal_has_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.register_responses_.msg_;
    }
    clear_has_register_responses();
  }
}
inline ::game::ErrorMessage* RegisterResponse::release_msg() {
  // @@protoc_insertion_point(field_release:game.RegisterResponse.msg)
  if (_internal_has_msg()) {
    clear_has_register_responses();
    ::game::ErrorMessage* temp = _impl_.register_responses_.msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.register_responses_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ErrorMessage& RegisterResponse::_internal_msg() const {
  return _internal_has_msg()
      ? *_impl_.register_responses_.msg_
      : reinterpret_cast< ::game::ErrorMessage&>(::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& RegisterResponse::msg() const {
  // @@protoc_insertion_point(field_get:game.RegisterResponse.msg)
  return _internal_msg();
}
inline ::game::ErrorMessage* RegisterResponse::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.RegisterResponse.msg)
  if (_internal_has_msg()) {
    clear_has_register_responses();
    ::game::ErrorMessage* temp = _impl_.register_responses_.msg_;
    _impl_.register_responses_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegisterResponse::unsafe_arena_set_allocated_msg(::game::ErrorMessage* msg) {
  clear_register_responses();
  if (msg) {
    set_has_msg();
    _impl_.register_responses_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.RegisterResponse.msg)
}
inline ::game::ErrorMessage* RegisterResponse::_internal_mutable_msg() {
  if (!_internal_has_msg()) {
    clear_register_responses();
    set_has_msg();
    _impl_.register_responses_.msg_ = CreateMaybeMessage< ::game::ErrorMessage >(GetArenaForAllocation());
  }
  return _impl_.register_responses_.msg_;
}
inline ::game::ErrorMessage* RegisterResponse::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.RegisterResponse.msg)
  return _msg;
}

inline bool RegisterResponse::has_register_responses() const {
  return register_responses_case() != REGISTER_RESPONSES_NOT_SET;
}
inline void RegisterResponse::clear_has_register_responses() {
  _impl_._oneof_case_[0] = REGISTER_RESPONSES_NOT_SET;
}
inline RegisterResponse::RegisterResponsesCase RegisterResponse::register_responses_case() const {
  return RegisterResponse::RegisterResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SaltHash

// string salt = 1;
inline void SaltHash::clear_salt() {
  _impl_.salt_.ClearToEmpty();
}
inline const std::string& SaltHash::salt() const {
  // @@protoc_insertion_point(field_get:game.SaltHash.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaltHash::set_salt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.salt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.SaltHash.salt)
}
inline std::string* SaltHash::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:game.SaltHash.salt)
  return _s;
}
inline const std::string& SaltHash::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void SaltHash::_internal_set_salt(const std::string& value) {
  
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* SaltHash::_internal_mutable_salt() {
  
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* SaltHash::release_salt() {
  // @@protoc_insertion_point(field_release:game.SaltHash.salt)
  return _impl_.salt_.Release();
}
inline void SaltHash::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    
  } else {
    
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.SaltHash.salt)
}

// string hash = 2;
inline void SaltHash::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& SaltHash::hash() const {
  // @@protoc_insertion_point(field_get:game.SaltHash.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaltHash::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.SaltHash.hash)
}
inline std::string* SaltHash::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:game.SaltHash.hash)
  return _s;
}
inline const std::string& SaltHash::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void SaltHash::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SaltHash::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SaltHash::release_hash() {
  // @@protoc_insertion_point(field_release:game.SaltHash.hash)
  return _impl_.hash_.Release();
}
inline void SaltHash::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.SaltHash.hash)
}

// -------------------------------------------------------------------

// Player

// string name = 1;
inline void Player::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:game.Player.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.Player.name)
}
inline std::string* Player::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.Player.name)
  return _s;
}
inline const std::string& Player::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Player::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:game.Player.name)
  return _impl_.name_.Release();
}
inline void Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.Player.name)
}

// .game.PlayerStatus status = 2;
inline void Player::clear_status() {
  _impl_.status_ = 0;
}
inline ::game::PlayerStatus Player::_internal_status() const {
  return static_cast< ::game::PlayerStatus >(_impl_.status_);
}
inline ::game::PlayerStatus Player::status() const {
  // @@protoc_insertion_point(field_get:game.Player.status)
  return _internal_status();
}
inline void Player::_internal_set_status(::game::PlayerStatus value) {
  
  _impl_.status_ = value;
}
inline void Player::set_status(::game::PlayerStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:game.Player.status)
}

// int32 balance = 3;
inline void Player::clear_balance() {
  _impl_.balance_ = 0;
}
inline int32_t Player::_internal_balance() const {
  return _impl_.balance_;
}
inline int32_t Player::balance() const {
  // @@protoc_insertion_point(field_get:game.Player.balance)
  return _internal_balance();
}
inline void Player::_internal_set_balance(int32_t value) {
  
  _impl_.balance_ = value;
}
inline void Player::set_balance(int32_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:game.Player.balance)
}

// -------------------------------------------------------------------

// LobbyRequests

// .game.CreateGameRequest create_game_request = 1;
inline bool LobbyRequests::_internal_has_create_game_request() const {
  return requests_case() == kCreateGameRequest;
}
inline bool LobbyRequests::has_create_game_request() const {
  return _internal_has_create_game_request();
}
inline void LobbyRequests::set_has_create_game_request() {
  _impl_._oneof_case_[0] = kCreateGameRequest;
}
inline void LobbyRequests::clear_create_game_request() {
  if (_internal_has_create_game_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.requests_.create_game_request_;
    }
    clear_has_requests();
  }
}
inline ::game::CreateGameRequest* LobbyRequests::release_create_game_request() {
  // @@protoc_insertion_point(field_release:game.LobbyRequests.create_game_request)
  if (_internal_has_create_game_request()) {
    clear_has_requests();
    ::game::CreateGameRequest* temp = _impl_.requests_.create_game_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requests_.create_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::CreateGameRequest& LobbyRequests::_internal_create_game_request() const {
  return _internal_has_create_game_request()
      ? *_impl_.requests_.create_game_request_
      : reinterpret_cast< ::game::CreateGameRequest&>(::game::_CreateGameRequest_default_instance_);
}
inline const ::game::CreateGameRequest& LobbyRequests::create_game_request() const {
  // @@protoc_insertion_point(field_get:game.LobbyRequests.create_game_request)
  return _internal_create_game_request();
}
inline ::game::CreateGameRequest* LobbyRequests::unsafe_arena_release_create_game_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LobbyRequests.create_game_request)
  if (_internal_has_create_game_request()) {
    clear_has_requests();
    ::game::CreateGameRequest* temp = _impl_.requests_.create_game_request_;
    _impl_.requests_.create_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbyRequests::unsafe_arena_set_allocated_create_game_request(::game::CreateGameRequest* create_game_request) {
  clear_requests();
  if (create_game_request) {
    set_has_create_game_request();
    _impl_.requests_.create_game_request_ = create_game_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LobbyRequests.create_game_request)
}
inline ::game::CreateGameRequest* LobbyRequests::_internal_mutable_create_game_request() {
  if (!_internal_has_create_game_request()) {
    clear_requests();
    set_has_create_game_request();
    _impl_.requests_.create_game_request_ = CreateMaybeMessage< ::game::CreateGameRequest >(GetArenaForAllocation());
  }
  return _impl_.requests_.create_game_request_;
}
inline ::game::CreateGameRequest* LobbyRequests::mutable_create_game_request() {
  ::game::CreateGameRequest* _msg = _internal_mutable_create_game_request();
  // @@protoc_insertion_point(field_mutable:game.LobbyRequests.create_game_request)
  return _msg;
}

// .game.SearchGameRequest search_game_request = 2;
inline bool LobbyRequests::_internal_has_search_game_request() const {
  return requests_case() == kSearchGameRequest;
}
inline bool LobbyRequests::has_search_game_request() const {
  return _internal_has_search_game_request();
}
inline void LobbyRequests::set_has_search_game_request() {
  _impl_._oneof_case_[0] = kSearchGameRequest;
}
inline void LobbyRequests::clear_search_game_request() {
  if (_internal_has_search_game_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.requests_.search_game_request_;
    }
    clear_has_requests();
  }
}
inline ::game::SearchGameRequest* LobbyRequests::release_search_game_request() {
  // @@protoc_insertion_point(field_release:game.LobbyRequests.search_game_request)
  if (_internal_has_search_game_request()) {
    clear_has_requests();
    ::game::SearchGameRequest* temp = _impl_.requests_.search_game_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requests_.search_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::SearchGameRequest& LobbyRequests::_internal_search_game_request() const {
  return _internal_has_search_game_request()
      ? *_impl_.requests_.search_game_request_
      : reinterpret_cast< ::game::SearchGameRequest&>(::game::_SearchGameRequest_default_instance_);
}
inline const ::game::SearchGameRequest& LobbyRequests::search_game_request() const {
  // @@protoc_insertion_point(field_get:game.LobbyRequests.search_game_request)
  return _internal_search_game_request();
}
inline ::game::SearchGameRequest* LobbyRequests::unsafe_arena_release_search_game_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LobbyRequests.search_game_request)
  if (_internal_has_search_game_request()) {
    clear_has_requests();
    ::game::SearchGameRequest* temp = _impl_.requests_.search_game_request_;
    _impl_.requests_.search_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbyRequests::unsafe_arena_set_allocated_search_game_request(::game::SearchGameRequest* search_game_request) {
  clear_requests();
  if (search_game_request) {
    set_has_search_game_request();
    _impl_.requests_.search_game_request_ = search_game_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LobbyRequests.search_game_request)
}
inline ::game::SearchGameRequest* LobbyRequests::_internal_mutable_search_game_request() {
  if (!_internal_has_search_game_request()) {
    clear_requests();
    set_has_search_game_request();
    _impl_.requests_.search_game_request_ = CreateMaybeMessage< ::game::SearchGameRequest >(GetArenaForAllocation());
  }
  return _impl_.requests_.search_game_request_;
}
inline ::game::SearchGameRequest* LobbyRequests::mutable_search_game_request() {
  ::game::SearchGameRequest* _msg = _internal_mutable_search_game_request();
  // @@protoc_insertion_point(field_mutable:game.LobbyRequests.search_game_request)
  return _msg;
}

inline bool LobbyRequests::has_requests() const {
  return requests_case() != REQUESTS_NOT_SET;
}
inline void LobbyRequests::clear_has_requests() {
  _impl_._oneof_case_[0] = REQUESTS_NOT_SET;
}
inline LobbyRequests::RequestsCase LobbyRequests::requests_case() const {
  return LobbyRequests::RequestsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LobbyResponses

// .game.CreateGameResponse create_game_response = 1;
inline bool LobbyResponses::_internal_has_create_game_response() const {
  return responses_case() == kCreateGameResponse;
}
inline bool LobbyResponses::has_create_game_response() const {
  return _internal_has_create_game_response();
}
inline void LobbyResponses::set_has_create_game_response() {
  _impl_._oneof_case_[0] = kCreateGameResponse;
}
inline void LobbyResponses::clear_create_game_response() {
  if (_internal_has_create_game_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.create_game_response_;
    }
    clear_has_responses();
  }
}
inline ::game::CreateGameResponse* LobbyResponses::release_create_game_response() {
  // @@protoc_insertion_point(field_release:game.LobbyResponses.create_game_response)
  if (_internal_has_create_game_response()) {
    clear_has_responses();
    ::game::CreateGameResponse* temp = _impl_.responses_.create_game_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.create_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::CreateGameResponse& LobbyResponses::_internal_create_game_response() const {
  return _internal_has_create_game_response()
      ? *_impl_.responses_.create_game_response_
      : reinterpret_cast< ::game::CreateGameResponse&>(::game::_CreateGameResponse_default_instance_);
}
inline const ::game::CreateGameResponse& LobbyResponses::create_game_response() const {
  // @@protoc_insertion_point(field_get:game.LobbyResponses.create_game_response)
  return _internal_create_game_response();
}
inline ::game::CreateGameResponse* LobbyResponses::unsafe_arena_release_create_game_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LobbyResponses.create_game_response)
  if (_internal_has_create_game_response()) {
    clear_has_responses();
    ::game::CreateGameResponse* temp = _impl_.responses_.create_game_response_;
    _impl_.responses_.create_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbyResponses::unsafe_arena_set_allocated_create_game_response(::game::CreateGameResponse* create_game_response) {
  clear_responses();
  if (create_game_response) {
    set_has_create_game_response();
    _impl_.responses_.create_game_response_ = create_game_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LobbyResponses.create_game_response)
}
inline ::game::CreateGameResponse* LobbyResponses::_internal_mutable_create_game_response() {
  if (!_internal_has_create_game_response()) {
    clear_responses();
    set_has_create_game_response();
    _impl_.responses_.create_game_response_ = CreateMaybeMessage< ::game::CreateGameResponse >(GetArenaForAllocation());
  }
  return _impl_.responses_.create_game_response_;
}
inline ::game::CreateGameResponse* LobbyResponses::mutable_create_game_response() {
  ::game::CreateGameResponse* _msg = _internal_mutable_create_game_response();
  // @@protoc_insertion_point(field_mutable:game.LobbyResponses.create_game_response)
  return _msg;
}

// .game.SearchGameResponse search_game_response = 2;
inline bool LobbyResponses::_internal_has_search_game_response() const {
  return responses_case() == kSearchGameResponse;
}
inline bool LobbyResponses::has_search_game_response() const {
  return _internal_has_search_game_response();
}
inline void LobbyResponses::set_has_search_game_response() {
  _impl_._oneof_case_[0] = kSearchGameResponse;
}
inline void LobbyResponses::clear_search_game_response() {
  if (_internal_has_search_game_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.search_game_response_;
    }
    clear_has_responses();
  }
}
inline ::game::SearchGameResponse* LobbyResponses::release_search_game_response() {
  // @@protoc_insertion_point(field_release:game.LobbyResponses.search_game_response)
  if (_internal_has_search_game_response()) {
    clear_has_responses();
    ::game::SearchGameResponse* temp = _impl_.responses_.search_game_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.search_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::SearchGameResponse& LobbyResponses::_internal_search_game_response() const {
  return _internal_has_search_game_response()
      ? *_impl_.responses_.search_game_response_
      : reinterpret_cast< ::game::SearchGameResponse&>(::game::_SearchGameResponse_default_instance_);
}
inline const ::game::SearchGameResponse& LobbyResponses::search_game_response() const {
  // @@protoc_insertion_point(field_get:game.LobbyResponses.search_game_response)
  return _internal_search_game_response();
}
inline ::game::SearchGameResponse* LobbyResponses::unsafe_arena_release_search_game_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LobbyResponses.search_game_response)
  if (_internal_has_search_game_response()) {
    clear_has_responses();
    ::game::SearchGameResponse* temp = _impl_.responses_.search_game_response_;
    _impl_.responses_.search_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbyResponses::unsafe_arena_set_allocated_search_game_response(::game::SearchGameResponse* search_game_response) {
  clear_responses();
  if (search_game_response) {
    set_has_search_game_response();
    _impl_.responses_.search_game_response_ = search_game_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LobbyResponses.search_game_response)
}
inline ::game::SearchGameResponse* LobbyResponses::_internal_mutable_search_game_response() {
  if (!_internal_has_search_game_response()) {
    clear_responses();
    set_has_search_game_response();
    _impl_.responses_.search_game_response_ = CreateMaybeMessage< ::game::SearchGameResponse >(GetArenaForAllocation());
  }
  return _impl_.responses_.search_game_response_;
}
inline ::game::SearchGameResponse* LobbyResponses::mutable_search_game_response() {
  ::game::SearchGameResponse* _msg = _internal_mutable_search_game_response();
  // @@protoc_insertion_point(field_mutable:game.LobbyResponses.search_game_response)
  return _msg;
}

inline bool LobbyResponses::has_responses() const {
  return responses_case() != RESPONSES_NOT_SET;
}
inline void LobbyResponses::clear_has_responses() {
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}
inline LobbyResponses::ResponsesCase LobbyResponses::responses_case() const {
  return LobbyResponses::ResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateGameRequest

// string game_owner = 1;
inline void CreateGameRequest::clear_game_owner() {
  _impl_.game_owner_.ClearToEmpty();
}
inline const std::string& CreateGameRequest::game_owner() const {
  // @@protoc_insertion_point(field_get:game.CreateGameRequest.game_owner)
  return _internal_game_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGameRequest::set_game_owner(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.CreateGameRequest.game_owner)
}
inline std::string* CreateGameRequest::mutable_game_owner() {
  std::string* _s = _internal_mutable_game_owner();
  // @@protoc_insertion_point(field_mutable:game.CreateGameRequest.game_owner)
  return _s;
}
inline const std::string& CreateGameRequest::_internal_game_owner() const {
  return _impl_.game_owner_.Get();
}
inline void CreateGameRequest::_internal_set_game_owner(const std::string& value) {
  
  _impl_.game_owner_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateGameRequest::_internal_mutable_game_owner() {
  
  return _impl_.game_owner_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateGameRequest::release_game_owner() {
  // @@protoc_insertion_point(field_release:game.CreateGameRequest.game_owner)
  return _impl_.game_owner_.Release();
}
inline void CreateGameRequest::set_allocated_game_owner(std::string* game_owner) {
  if (game_owner != nullptr) {
    
  } else {
    
  }
  _impl_.game_owner_.SetAllocated(game_owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_owner_.IsDefault()) {
    _impl_.game_owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.CreateGameRequest.game_owner)
}

// .game.PlayerInfo player_info = 2;
inline bool CreateGameRequest::_internal_has_player_info() const {
  return this != internal_default_instance() && _impl_.player_info_ != nullptr;
}
inline bool CreateGameRequest::has_player_info() const {
  return _internal_has_player_info();
}
inline void CreateGameRequest::clear_player_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_info_ != nullptr) {
    delete _impl_.player_info_;
  }
  _impl_.player_info_ = nullptr;
}
inline const ::game::PlayerInfo& CreateGameRequest::_internal_player_info() const {
  const ::game::PlayerInfo* p = _impl_.player_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::PlayerInfo&>(
      ::game::_PlayerInfo_default_instance_);
}
inline const ::game::PlayerInfo& CreateGameRequest::player_info() const {
  // @@protoc_insertion_point(field_get:game.CreateGameRequest.player_info)
  return _internal_player_info();
}
inline void CreateGameRequest::unsafe_arena_set_allocated_player_info(
    ::game::PlayerInfo* player_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_info_);
  }
  _impl_.player_info_ = player_info;
  if (player_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.CreateGameRequest.player_info)
}
inline ::game::PlayerInfo* CreateGameRequest::release_player_info() {
  
  ::game::PlayerInfo* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::PlayerInfo* CreateGameRequest::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_release:game.CreateGameRequest.player_info)
  
  ::game::PlayerInfo* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
  return temp;
}
inline ::game::PlayerInfo* CreateGameRequest::_internal_mutable_player_info() {
  
  if (_impl_.player_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::PlayerInfo>(GetArenaForAllocation());
    _impl_.player_info_ = p;
  }
  return _impl_.player_info_;
}
inline ::game::PlayerInfo* CreateGameRequest::mutable_player_info() {
  ::game::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:game.CreateGameRequest.player_info)
  return _msg;
}
inline void CreateGameRequest::set_allocated_player_info(::game::PlayerInfo* player_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_info_;
  }
  if (player_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_info);
    if (message_arena != submessage_arena) {
      player_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:game.CreateGameRequest.player_info)
}

// .game.GameParameters game_parameters = 3;
inline bool CreateGameRequest::_internal_has_game_parameters() const {
  return this != internal_default_instance() && _impl_.game_parameters_ != nullptr;
}
inline bool CreateGameRequest::has_game_parameters() const {
  return _internal_has_game_parameters();
}
inline void CreateGameRequest::clear_game_parameters() {
  if (GetArenaForAllocation() == nullptr && _impl_.game_parameters_ != nullptr) {
    delete _impl_.game_parameters_;
  }
  _impl_.game_parameters_ = nullptr;
}
inline const ::game::GameParameters& CreateGameRequest::_internal_game_parameters() const {
  const ::game::GameParameters* p = _impl_.game_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::GameParameters&>(
      ::game::_GameParameters_default_instance_);
}
inline const ::game::GameParameters& CreateGameRequest::game_parameters() const {
  // @@protoc_insertion_point(field_get:game.CreateGameRequest.game_parameters)
  return _internal_game_parameters();
}
inline void CreateGameRequest::unsafe_arena_set_allocated_game_parameters(
    ::game::GameParameters* game_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.game_parameters_);
  }
  _impl_.game_parameters_ = game_parameters;
  if (game_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.CreateGameRequest.game_parameters)
}
inline ::game::GameParameters* CreateGameRequest::release_game_parameters() {
  
  ::game::GameParameters* temp = _impl_.game_parameters_;
  _impl_.game_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::GameParameters* CreateGameRequest::unsafe_arena_release_game_parameters() {
  // @@protoc_insertion_point(field_release:game.CreateGameRequest.game_parameters)
  
  ::game::GameParameters* temp = _impl_.game_parameters_;
  _impl_.game_parameters_ = nullptr;
  return temp;
}
inline ::game::GameParameters* CreateGameRequest::_internal_mutable_game_parameters() {
  
  if (_impl_.game_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::GameParameters>(GetArenaForAllocation());
    _impl_.game_parameters_ = p;
  }
  return _impl_.game_parameters_;
}
inline ::game::GameParameters* CreateGameRequest::mutable_game_parameters() {
  ::game::GameParameters* _msg = _internal_mutable_game_parameters();
  // @@protoc_insertion_point(field_mutable:game.CreateGameRequest.game_parameters)
  return _msg;
}
inline void CreateGameRequest::set_allocated_game_parameters(::game::GameParameters* game_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.game_parameters_;
  }
  if (game_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(game_parameters);
    if (message_arena != submessage_arena) {
      game_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.game_parameters_ = game_parameters;
  // @@protoc_insertion_point(field_set_allocated:game.CreateGameRequest.game_parameters)
}

// -------------------------------------------------------------------

// CreateGameResponse

// .game.StatusMessage status_message = 1;
inline bool CreateGameResponse::_internal_has_status_message() const {
  return this != internal_default_instance() && _impl_.status_message_ != nullptr;
}
inline bool CreateGameResponse::has_status_message() const {
  return _internal_has_status_message();
}
inline void CreateGameResponse::clear_status_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_message_ != nullptr) {
    delete _impl_.status_message_;
  }
  _impl_.status_message_ = nullptr;
}
inline const ::game::StatusMessage& CreateGameResponse::_internal_status_message() const {
  const ::game::StatusMessage* p = _impl_.status_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::StatusMessage&>(
      ::game::_StatusMessage_default_instance_);
}
inline const ::game::StatusMessage& CreateGameResponse::status_message() const {
  // @@protoc_insertion_point(field_get:game.CreateGameResponse.status_message)
  return _internal_status_message();
}
inline void CreateGameResponse::unsafe_arena_set_allocated_status_message(
    ::game::StatusMessage* status_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_message_);
  }
  _impl_.status_message_ = status_message;
  if (status_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.CreateGameResponse.status_message)
}
inline ::game::StatusMessage* CreateGameResponse::release_status_message() {
  
  ::game::StatusMessage* temp = _impl_.status_message_;
  _impl_.status_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::StatusMessage* CreateGameResponse::unsafe_arena_release_status_message() {
  // @@protoc_insertion_point(field_release:game.CreateGameResponse.status_message)
  
  ::game::StatusMessage* temp = _impl_.status_message_;
  _impl_.status_message_ = nullptr;
  return temp;
}
inline ::game::StatusMessage* CreateGameResponse::_internal_mutable_status_message() {
  
  if (_impl_.status_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::StatusMessage>(GetArenaForAllocation());
    _impl_.status_message_ = p;
  }
  return _impl_.status_message_;
}
inline ::game::StatusMessage* CreateGameResponse::mutable_status_message() {
  ::game::StatusMessage* _msg = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:game.CreateGameResponse.status_message)
  return _msg;
}
inline void CreateGameResponse::set_allocated_status_message(::game::StatusMessage* status_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_message_;
  }
  if (status_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status_message);
    if (message_arena != submessage_arena) {
      status_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_message_ = status_message;
  // @@protoc_insertion_point(field_set_allocated:game.CreateGameResponse.status_message)
}

// repeated .game.Player players = 2;
inline int CreateGameResponse::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int CreateGameResponse::players_size() const {
  return _internal_players_size();
}
inline void CreateGameResponse::clear_players() {
  _impl_.players_.Clear();
}
inline ::game::Player* CreateGameResponse::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:game.CreateGameResponse.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >*
CreateGameResponse::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:game.CreateGameResponse.players)
  return &_impl_.players_;
}
inline const ::game::Player& CreateGameResponse::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::game::Player& CreateGameResponse::players(int index) const {
  // @@protoc_insertion_point(field_get:game.CreateGameResponse.players)
  return _internal_players(index);
}
inline ::game::Player* CreateGameResponse::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::game::Player* CreateGameResponse::add_players() {
  ::game::Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:game.CreateGameResponse.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >&
CreateGameResponse::players() const {
  // @@protoc_insertion_point(field_list:game.CreateGameResponse.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// SearchGameRequest

// string name = 1;
inline void SearchGameRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SearchGameRequest::name() const {
  // @@protoc_insertion_point(field_get:game.SearchGameRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchGameRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.SearchGameRequest.name)
}
inline std::string* SearchGameRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.SearchGameRequest.name)
  return _s;
}
inline const std::string& SearchGameRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SearchGameRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchGameRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchGameRequest::release_name() {
  // @@protoc_insertion_point(field_release:game.SearchGameRequest.name)
  return _impl_.name_.Release();
}
inline void SearchGameRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.SearchGameRequest.name)
}

// .game.PlayerInfo player_info = 2;
inline bool SearchGameRequest::_internal_has_player_info() const {
  return this != internal_default_instance() && _impl_.player_info_ != nullptr;
}
inline bool SearchGameRequest::has_player_info() const {
  return _internal_has_player_info();
}
inline void SearchGameRequest::clear_player_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_info_ != nullptr) {
    delete _impl_.player_info_;
  }
  _impl_.player_info_ = nullptr;
}
inline const ::game::PlayerInfo& SearchGameRequest::_internal_player_info() const {
  const ::game::PlayerInfo* p = _impl_.player_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::PlayerInfo&>(
      ::game::_PlayerInfo_default_instance_);
}
inline const ::game::PlayerInfo& SearchGameRequest::player_info() const {
  // @@protoc_insertion_point(field_get:game.SearchGameRequest.player_info)
  return _internal_player_info();
}
inline void SearchGameRequest::unsafe_arena_set_allocated_player_info(
    ::game::PlayerInfo* player_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_info_);
  }
  _impl_.player_info_ = player_info;
  if (player_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.SearchGameRequest.player_info)
}
inline ::game::PlayerInfo* SearchGameRequest::release_player_info() {
  
  ::game::PlayerInfo* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::PlayerInfo* SearchGameRequest::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_release:game.SearchGameRequest.player_info)
  
  ::game::PlayerInfo* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
  return temp;
}
inline ::game::PlayerInfo* SearchGameRequest::_internal_mutable_player_info() {
  
  if (_impl_.player_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::PlayerInfo>(GetArenaForAllocation());
    _impl_.player_info_ = p;
  }
  return _impl_.player_info_;
}
inline ::game::PlayerInfo* SearchGameRequest::mutable_player_info() {
  ::game::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:game.SearchGameRequest.player_info)
  return _msg;
}
inline void SearchGameRequest::set_allocated_player_info(::game::PlayerInfo* player_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_info_;
  }
  if (player_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_info);
    if (message_arena != submessage_arena) {
      player_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:game.SearchGameRequest.player_info)
}

// .game.GameParameters game_parameters = 3;
inline bool SearchGameRequest::_internal_has_game_parameters() const {
  return this != internal_default_instance() && _impl_.game_parameters_ != nullptr;
}
inline bool SearchGameRequest::has_game_parameters() const {
  return _internal_has_game_parameters();
}
inline void SearchGameRequest::clear_game_parameters() {
  if (GetArenaForAllocation() == nullptr && _impl_.game_parameters_ != nullptr) {
    delete _impl_.game_parameters_;
  }
  _impl_.game_parameters_ = nullptr;
}
inline const ::game::GameParameters& SearchGameRequest::_internal_game_parameters() const {
  const ::game::GameParameters* p = _impl_.game_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::GameParameters&>(
      ::game::_GameParameters_default_instance_);
}
inline const ::game::GameParameters& SearchGameRequest::game_parameters() const {
  // @@protoc_insertion_point(field_get:game.SearchGameRequest.game_parameters)
  return _internal_game_parameters();
}
inline void SearchGameRequest::unsafe_arena_set_allocated_game_parameters(
    ::game::GameParameters* game_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.game_parameters_);
  }
  _impl_.game_parameters_ = game_parameters;
  if (game_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.SearchGameRequest.game_parameters)
}
inline ::game::GameParameters* SearchGameRequest::release_game_parameters() {
  
  ::game::GameParameters* temp = _impl_.game_parameters_;
  _impl_.game_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::GameParameters* SearchGameRequest::unsafe_arena_release_game_parameters() {
  // @@protoc_insertion_point(field_release:game.SearchGameRequest.game_parameters)
  
  ::game::GameParameters* temp = _impl_.game_parameters_;
  _impl_.game_parameters_ = nullptr;
  return temp;
}
inline ::game::GameParameters* SearchGameRequest::_internal_mutable_game_parameters() {
  
  if (_impl_.game_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::GameParameters>(GetArenaForAllocation());
    _impl_.game_parameters_ = p;
  }
  return _impl_.game_parameters_;
}
inline ::game::GameParameters* SearchGameRequest::mutable_game_parameters() {
  ::game::GameParameters* _msg = _internal_mutable_game_parameters();
  // @@protoc_insertion_point(field_mutable:game.SearchGameRequest.game_parameters)
  return _msg;
}
inline void SearchGameRequest::set_allocated_game_parameters(::game::GameParameters* game_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.game_parameters_;
  }
  if (game_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(game_parameters);
    if (message_arena != submessage_arena) {
      game_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.game_parameters_ = game_parameters;
  // @@protoc_insertion_point(field_set_allocated:game.SearchGameRequest.game_parameters)
}

// -------------------------------------------------------------------

// SearchGameResponse

// .game.StatusMessage status_message = 1;
inline bool SearchGameResponse::_internal_has_status_message() const {
  return this != internal_default_instance() && _impl_.status_message_ != nullptr;
}
inline bool SearchGameResponse::has_status_message() const {
  return _internal_has_status_message();
}
inline void SearchGameResponse::clear_status_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_message_ != nullptr) {
    delete _impl_.status_message_;
  }
  _impl_.status_message_ = nullptr;
}
inline const ::game::StatusMessage& SearchGameResponse::_internal_status_message() const {
  const ::game::StatusMessage* p = _impl_.status_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::StatusMessage&>(
      ::game::_StatusMessage_default_instance_);
}
inline const ::game::StatusMessage& SearchGameResponse::status_message() const {
  // @@protoc_insertion_point(field_get:game.SearchGameResponse.status_message)
  return _internal_status_message();
}
inline void SearchGameResponse::unsafe_arena_set_allocated_status_message(
    ::game::StatusMessage* status_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_message_);
  }
  _impl_.status_message_ = status_message;
  if (status_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.SearchGameResponse.status_message)
}
inline ::game::StatusMessage* SearchGameResponse::release_status_message() {
  
  ::game::StatusMessage* temp = _impl_.status_message_;
  _impl_.status_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::StatusMessage* SearchGameResponse::unsafe_arena_release_status_message() {
  // @@protoc_insertion_point(field_release:game.SearchGameResponse.status_message)
  
  ::game::StatusMessage* temp = _impl_.status_message_;
  _impl_.status_message_ = nullptr;
  return temp;
}
inline ::game::StatusMessage* SearchGameResponse::_internal_mutable_status_message() {
  
  if (_impl_.status_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::StatusMessage>(GetArenaForAllocation());
    _impl_.status_message_ = p;
  }
  return _impl_.status_message_;
}
inline ::game::StatusMessage* SearchGameResponse::mutable_status_message() {
  ::game::StatusMessage* _msg = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:game.SearchGameResponse.status_message)
  return _msg;
}
inline void SearchGameResponse::set_allocated_status_message(::game::StatusMessage* status_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_message_;
  }
  if (status_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status_message);
    if (message_arena != submessage_arena) {
      status_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_message_ = status_message;
  // @@protoc_insertion_point(field_set_allocated:game.SearchGameResponse.status_message)
}

// repeated .game.Player players = 2;
inline int SearchGameResponse::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int SearchGameResponse::players_size() const {
  return _internal_players_size();
}
inline void SearchGameResponse::clear_players() {
  _impl_.players_.Clear();
}
inline ::game::Player* SearchGameResponse::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:game.SearchGameResponse.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >*
SearchGameResponse::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:game.SearchGameResponse.players)
  return &_impl_.players_;
}
inline const ::game::Player& SearchGameResponse::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::game::Player& SearchGameResponse::players(int index) const {
  // @@protoc_insertion_point(field_get:game.SearchGameResponse.players)
  return _internal_players(index);
}
inline ::game::Player* SearchGameResponse::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::game::Player* SearchGameResponse::add_players() {
  ::game::Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:game.SearchGameResponse.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >&
SearchGameResponse::players() const {
  // @@protoc_insertion_point(field_list:game.SearchGameResponse.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// GameRequests

// .game.MakeMoveRequest MakeMoveRequest = 1;
inline bool GameRequests::_internal_has_make_move_request() const {
  return requests_case() == kMakeMoveRequest;
}
inline bool GameRequests::has_make_move_request() const {
  return _internal_has_make_move_request();
}
inline void GameRequests::set_has_make_move_request() {
  _impl_._oneof_case_[0] = kMakeMoveRequest;
}
inline void GameRequests::clear_make_move_request() {
  if (_internal_has_make_move_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.requests_.make_move_request_;
    }
    clear_has_requests();
  }
}
inline ::game::make_move_request* GameRequests::release_make_move_request() {
  // @@protoc_insertion_point(field_release:game.GameRequests.MakeMoveRequest)
  if (_internal_has_make_move_request()) {
    clear_has_requests();
    ::game::make_move_request* temp = _impl_.requests_.make_move_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requests_.make_move_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::make_move_request& GameRequests::_internal_make_move_request() const {
  return _internal_has_make_move_request()
      ? *_impl_.requests_.make_move_request_
      : reinterpret_cast< ::game::make_move_request&>(::game::_make_move_request_default_instance_);
}
inline const ::game::make_move_request& GameRequests::make_move_request() const {
  // @@protoc_insertion_point(field_get:game.GameRequests.MakeMoveRequest)
  return _internal_make_move_request();
}
inline ::game::make_move_request* GameRequests::unsafe_arena_release_make_move_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameRequests.MakeMoveRequest)
  if (_internal_has_make_move_request()) {
    clear_has_requests();
    ::game::make_move_request* temp = _impl_.requests_.make_move_request_;
    _impl_.requests_.make_move_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameRequests::unsafe_arena_set_allocated_make_move_request(::game::make_move_request* make_move_request) {
  clear_requests();
  if (make_move_request) {
    set_has_make_move_request();
    _impl_.requests_.make_move_request_ = make_move_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameRequests.MakeMoveRequest)
}
inline ::game::make_move_request* GameRequests::_internal_mutable_make_move_request() {
  if (!_internal_has_make_move_request()) {
    clear_requests();
    set_has_make_move_request();
    _impl_.requests_.make_move_request_ = CreateMaybeMessage< ::game::make_move_request >(GetArenaForAllocation());
  }
  return _impl_.requests_.make_move_request_;
}
inline ::game::make_move_request* GameRequests::mutable_make_move_request() {
  ::game::make_move_request* _msg = _internal_mutable_make_move_request();
  // @@protoc_insertion_point(field_mutable:game.GameRequests.MakeMoveRequest)
  return _msg;
}

inline bool GameRequests::has_requests() const {
  return requests_case() != REQUESTS_NOT_SET;
}
inline void GameRequests::clear_has_requests() {
  _impl_._oneof_case_[0] = REQUESTS_NOT_SET;
}
inline GameRequests::RequestsCase GameRequests::requests_case() const {
  return GameRequests::RequestsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GameResponses

// .game.MakeMoveResponse MakeMoveResponse = 1;
inline bool GameResponses::_internal_has_make_move_response() const {
  return responses_case() == kMakeMoveResponse;
}
inline bool GameResponses::has_make_move_response() const {
  return _internal_has_make_move_response();
}
inline void GameResponses::set_has_make_move_response() {
  _impl_._oneof_case_[0] = kMakeMoveResponse;
}
inline void GameResponses::clear_make_move_response() {
  if (_internal_has_make_move_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.make_move_response_;
    }
    clear_has_responses();
  }
}
inline ::game::make_move_response* GameResponses::release_make_move_response() {
  // @@protoc_insertion_point(field_release:game.GameResponses.MakeMoveResponse)
  if (_internal_has_make_move_response()) {
    clear_has_responses();
    ::game::make_move_response* temp = _impl_.responses_.make_move_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.make_move_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::make_move_response& GameResponses::_internal_make_move_response() const {
  return _internal_has_make_move_response()
      ? *_impl_.responses_.make_move_response_
      : reinterpret_cast< ::game::make_move_response&>(::game::_make_move_response_default_instance_);
}
inline const ::game::make_move_response& GameResponses::make_move_response() const {
  // @@protoc_insertion_point(field_get:game.GameResponses.MakeMoveResponse)
  return _internal_make_move_response();
}
inline ::game::make_move_response* GameResponses::unsafe_arena_release_make_move_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameResponses.MakeMoveResponse)
  if (_internal_has_make_move_response()) {
    clear_has_responses();
    ::game::make_move_response* temp = _impl_.responses_.make_move_response_;
    _impl_.responses_.make_move_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameResponses::unsafe_arena_set_allocated_make_move_response(::game::make_move_response* make_move_response) {
  clear_responses();
  if (make_move_response) {
    set_has_make_move_response();
    _impl_.responses_.make_move_response_ = make_move_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameResponses.MakeMoveResponse)
}
inline ::game::make_move_response* GameResponses::_internal_mutable_make_move_response() {
  if (!_internal_has_make_move_response()) {
    clear_responses();
    set_has_make_move_response();
    _impl_.responses_.make_move_response_ = CreateMaybeMessage< ::game::make_move_response >(GetArenaForAllocation());
  }
  return _impl_.responses_.make_move_response_;
}
inline ::game::make_move_response* GameResponses::mutable_make_move_response() {
  ::game::make_move_response* _msg = _internal_mutable_make_move_response();
  // @@protoc_insertion_point(field_mutable:game.GameResponses.MakeMoveResponse)
  return _msg;
}

inline bool GameResponses::has_responses() const {
  return responses_case() != RESPONSES_NOT_SET;
}
inline void GameResponses::clear_has_responses() {
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}
inline GameResponses::ResponsesCase GameResponses::responses_case() const {
  return GameResponses::ResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MakeMoveRequest

// string client_name = 1;
inline void make_move_request::clear_client_name() {
  _impl_.client_name_.ClearToEmpty();
}
inline const std::string& make_move_request::client_name() const {
  // @@protoc_insertion_point(field_get:game.MakeMoveRequest.client_name)
  return _internal_client_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void make_move_request::set_client_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.MakeMoveRequest.client_name)
}
inline std::string* make_move_request::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:game.MakeMoveRequest.client_name)
  return _s;
}
inline const std::string& make_move_request::_internal_client_name() const {
  return _impl_.client_name_.Get();
}
inline void make_move_request::_internal_set_client_name(const std::string& value) {
  
  _impl_.client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* make_move_request::_internal_mutable_client_name() {
  
  return _impl_.client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* make_move_request::release_client_name() {
  // @@protoc_insertion_point(field_release:game.MakeMoveRequest.client_name)
  return _impl_.client_name_.Release();
}
inline void make_move_request::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    
  } else {
    
  }
  _impl_.client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_name_.IsDefault()) {
    _impl_.client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.MakeMoveRequest.client_name)
}

// int32 make_blind = 2;
inline void make_move_request::clear_make_blind() {
  _impl_.make_blind_ = 0;
}
inline int32_t make_move_request::_internal_make_blind() const {
  return _impl_.make_blind_;
}
inline int32_t make_move_request::make_blind() const {
  // @@protoc_insertion_point(field_get:game.MakeMoveRequest.make_blind)
  return _internal_make_blind();
}
inline void make_move_request::_internal_set_make_blind(int32_t value) {
  
  _impl_.make_blind_ = value;
}
inline void make_move_request::set_make_blind(int32_t value) {
  _internal_set_make_blind(value);
  // @@protoc_insertion_point(field_set:game.MakeMoveRequest.make_blind)
}

// bool fold = 3;
inline void make_move_request::clear_fold() {
  _impl_.fold_ = false;
}
inline bool make_move_request::_internal_fold() const {
  return _impl_.fold_;
}
inline bool make_move_request::fold() const {
  // @@protoc_insertion_point(field_get:game.MakeMoveRequest.fold)
  return _internal_fold();
}
inline void make_move_request::_internal_set_fold(bool value) {
  
  _impl_.fold_ = value;
}
inline void make_move_request::set_fold(bool value) {
  _internal_set_fold(value);
  // @@protoc_insertion_point(field_set:game.MakeMoveRequest.fold)
}

// -------------------------------------------------------------------

// MakeMoveResponse

// repeated .game.Player players = 1;
inline int make_move_response::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int make_move_response::players_size() const {
  return _internal_players_size();
}
inline void make_move_response::clear_players() {
  _impl_.players_.Clear();
}
inline ::game::Player* make_move_response::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:game.MakeMoveResponse.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >*
make_move_response::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:game.MakeMoveResponse.players)
  return &_impl_.players_;
}
inline const ::game::Player& make_move_response::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::game::Player& make_move_response::players(int index) const {
  // @@protoc_insertion_point(field_get:game.MakeMoveResponse.players)
  return _internal_players(index);
}
inline ::game::Player* make_move_response::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::game::Player* make_move_response::add_players() {
  ::game::Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:game.MakeMoveResponse.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >&
make_move_response::players() const {
  // @@protoc_insertion_point(field_list:game.MakeMoveResponse.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// GameParameters

// string game_name = 1;
inline void GameParameters::clear_game_name() {
  _impl_.game_name_.ClearToEmpty();
}
inline const std::string& GameParameters::game_name() const {
  // @@protoc_insertion_point(field_get:game.GameParameters.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameParameters::set_game_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.GameParameters.game_name)
}
inline std::string* GameParameters::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:game.GameParameters.game_name)
  return _s;
}
inline const std::string& GameParameters::_internal_game_name() const {
  return _impl_.game_name_.Get();
}
inline void GameParameters::_internal_set_game_name(const std::string& value) {
  
  _impl_.game_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GameParameters::_internal_mutable_game_name() {
  
  return _impl_.game_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GameParameters::release_game_name() {
  // @@protoc_insertion_point(field_release:game.GameParameters.game_name)
  return _impl_.game_name_.Release();
}
inline void GameParameters::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    
  } else {
    
  }
  _impl_.game_name_.SetAllocated(game_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_name_.IsDefault()) {
    _impl_.game_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.GameParameters.game_name)
}

// int32 number_of_players = 2;
inline void GameParameters::clear_number_of_players() {
  _impl_.number_of_players_ = 0;
}
inline int32_t GameParameters::_internal_number_of_players() const {
  return _impl_.number_of_players_;
}
inline int32_t GameParameters::number_of_players() const {
  // @@protoc_insertion_point(field_get:game.GameParameters.number_of_players)
  return _internal_number_of_players();
}
inline void GameParameters::_internal_set_number_of_players(int32_t value) {
  
  _impl_.number_of_players_ = value;
}
inline void GameParameters::set_number_of_players(int32_t value) {
  _internal_set_number_of_players(value);
  // @@protoc_insertion_point(field_set:game.GameParameters.number_of_players)
}

// int32 minimal_bet = 3;
inline void GameParameters::clear_minimal_bet() {
  _impl_.minimal_bet_ = 0;
}
inline int32_t GameParameters::_internal_minimal_bet() const {
  return _impl_.minimal_bet_;
}
inline int32_t GameParameters::minimal_bet() const {
  // @@protoc_insertion_point(field_get:game.GameParameters.minimal_bet)
  return _internal_minimal_bet();
}
inline void GameParameters::_internal_set_minimal_bet(int32_t value) {
  
  _impl_.minimal_bet_ = value;
}
inline void GameParameters::set_minimal_bet(int32_t value) {
  _internal_set_minimal_bet(value);
  // @@protoc_insertion_point(field_set:game.GameParameters.minimal_bet)
}

// int32 game_enter_balance = 4;
inline void GameParameters::clear_game_enter_balance() {
  _impl_.game_enter_balance_ = 0;
}
inline int32_t GameParameters::_internal_game_enter_balance() const {
  return _impl_.game_enter_balance_;
}
inline int32_t GameParameters::game_enter_balance() const {
  // @@protoc_insertion_point(field_get:game.GameParameters.game_enter_balance)
  return _internal_game_enter_balance();
}
inline void GameParameters::_internal_set_game_enter_balance(int32_t value) {
  
  _impl_.game_enter_balance_ = value;
}
inline void GameParameters::set_game_enter_balance(int32_t value) {
  _internal_set_game_enter_balance(value);
  // @@protoc_insertion_point(field_set:game.GameParameters.game_enter_balance)
}

// -------------------------------------------------------------------

// PlayerInfo

// int32 client_id = 1;
inline void PlayerInfo::clear_client_id() {
  _impl_.client_id_ = 0;
}
inline int32_t PlayerInfo::_internal_client_id() const {
  return _impl_.client_id_;
}
inline int32_t PlayerInfo::client_id() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.client_id)
  return _internal_client_id();
}
inline void PlayerInfo::_internal_set_client_id(int32_t value) {
  
  _impl_.client_id_ = value;
}
inline void PlayerInfo::set_client_id(int32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.client_id)
}

// int32 client_games = 2;
inline void PlayerInfo::clear_client_games() {
  _impl_.client_games_ = 0;
}
inline int32_t PlayerInfo::_internal_client_games() const {
  return _impl_.client_games_;
}
inline int32_t PlayerInfo::client_games() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.client_games)
  return _internal_client_games();
}
inline void PlayerInfo::_internal_set_client_games(int32_t value) {
  
  _impl_.client_games_ = value;
}
inline void PlayerInfo::set_client_games(int32_t value) {
  _internal_set_client_games(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.client_games)
}

// int32 client_wins = 3;
inline void PlayerInfo::clear_client_wins() {
  _impl_.client_wins_ = 0;
}
inline int32_t PlayerInfo::_internal_client_wins() const {
  return _impl_.client_wins_;
}
inline int32_t PlayerInfo::client_wins() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.client_wins)
  return _internal_client_wins();
}
inline void PlayerInfo::_internal_set_client_wins(int32_t value) {
  
  _impl_.client_wins_ = value;
}
inline void PlayerInfo::set_client_wins(int32_t value) {
  _internal_set_client_wins(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.client_wins)
}

// int32 client_balance = 4;
inline void PlayerInfo::clear_client_balance() {
  _impl_.client_balance_ = 0;
}
inline int32_t PlayerInfo::_internal_client_balance() const {
  return _impl_.client_balance_;
}
inline int32_t PlayerInfo::client_balance() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.client_balance)
  return _internal_client_balance();
}
inline void PlayerInfo::_internal_set_client_balance(int32_t value) {
  
  _impl_.client_balance_ = value;
}
inline void PlayerInfo::set_client_balance(int32_t value) {
  _internal_set_client_balance(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.client_balance)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace game

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::game::error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::error>() {
  return ::game::error_descriptor();
}
template <> struct is_proto_enum< ::game::PlayerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::PlayerStatus>() {
  return ::game::PlayerStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_game_2eproto
