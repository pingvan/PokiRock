// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_game_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_game_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_game_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_game_2eproto;
namespace game {
class Card;
struct CardDefaultTypeInternal;
extern CardDefaultTypeInternal _Card_default_instance_;
class CreateGameRequest;
struct CreateGameRequestDefaultTypeInternal;
extern CreateGameRequestDefaultTypeInternal _CreateGameRequest_default_instance_;
class CreateGameResponse;
struct CreateGameResponseDefaultTypeInternal;
extern CreateGameResponseDefaultTypeInternal _CreateGameResponse_default_instance_;
class ErrorMessage;
struct ErrorMessageDefaultTypeInternal;
extern ErrorMessageDefaultTypeInternal _ErrorMessage_default_instance_;
class GameParameters;
struct GameParametersDefaultTypeInternal;
extern GameParametersDefaultTypeInternal _GameParameters_default_instance_;
class GameRequests;
struct GameRequestsDefaultTypeInternal;
extern GameRequestsDefaultTypeInternal _GameRequests_default_instance_;
class GameResponses;
struct GameResponsesDefaultTypeInternal;
extern GameResponsesDefaultTypeInternal _GameResponses_default_instance_;
class GameState;
struct GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class JoinGameAsOwnerRequest;
struct JoinGameAsOwnerRequestDefaultTypeInternal;
extern JoinGameAsOwnerRequestDefaultTypeInternal _JoinGameAsOwnerRequest_default_instance_;
class JoinGameAsOwnerResponse;
struct JoinGameAsOwnerResponseDefaultTypeInternal;
extern JoinGameAsOwnerResponseDefaultTypeInternal _JoinGameAsOwnerResponse_default_instance_;
class JoinGameRequest;
struct JoinGameRequestDefaultTypeInternal;
extern JoinGameRequestDefaultTypeInternal _JoinGameRequest_default_instance_;
class JoinGameResponse;
struct JoinGameResponseDefaultTypeInternal;
extern JoinGameResponseDefaultTypeInternal _JoinGameResponse_default_instance_;
class LobbyRequests;
struct LobbyRequestsDefaultTypeInternal;
extern LobbyRequestsDefaultTypeInternal _LobbyRequests_default_instance_;
class LobbyResponses;
struct LobbyResponsesDefaultTypeInternal;
extern LobbyResponsesDefaultTypeInternal _LobbyResponses_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginRequestFirst;
struct LoginRequestFirstDefaultTypeInternal;
extern LoginRequestFirstDefaultTypeInternal _LoginRequestFirst_default_instance_;
class LoginRequestSecond;
struct LoginRequestSecondDefaultTypeInternal;
extern LoginRequestSecondDefaultTypeInternal _LoginRequestSecond_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class LoginResponseFirst;
struct LoginResponseFirstDefaultTypeInternal;
extern LoginResponseFirstDefaultTypeInternal _LoginResponseFirst_default_instance_;
class LoginResponseSecond;
struct LoginResponseSecondDefaultTypeInternal;
extern LoginResponseSecondDefaultTypeInternal _LoginResponseSecond_default_instance_;
class MakeMoveRequest;
struct MakeMoveRequestDefaultTypeInternal;
extern MakeMoveRequestDefaultTypeInternal _MakeMoveRequest_default_instance_;
class MakeMoveResponse;
struct MakeMoveResponseDefaultTypeInternal;
extern MakeMoveResponseDefaultTypeInternal _MakeMoveResponse_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class SaltHash;
struct SaltHashDefaultTypeInternal;
extern SaltHashDefaultTypeInternal _SaltHash_default_instance_;
class SearchGameRequest;
struct SearchGameRequestDefaultTypeInternal;
extern SearchGameRequestDefaultTypeInternal _SearchGameRequest_default_instance_;
class SearchGameResponse;
struct SearchGameResponseDefaultTypeInternal;
extern SearchGameResponseDefaultTypeInternal _SearchGameResponse_default_instance_;
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> ::game::Card* Arena::CreateMaybeMessage<::game::Card>(Arena*);
template<> ::game::CreateGameRequest* Arena::CreateMaybeMessage<::game::CreateGameRequest>(Arena*);
template<> ::game::CreateGameResponse* Arena::CreateMaybeMessage<::game::CreateGameResponse>(Arena*);
template<> ::game::ErrorMessage* Arena::CreateMaybeMessage<::game::ErrorMessage>(Arena*);
template<> ::game::GameParameters* Arena::CreateMaybeMessage<::game::GameParameters>(Arena*);
template<> ::game::GameRequests* Arena::CreateMaybeMessage<::game::GameRequests>(Arena*);
template<> ::game::GameResponses* Arena::CreateMaybeMessage<::game::GameResponses>(Arena*);
template<> ::game::GameState* Arena::CreateMaybeMessage<::game::GameState>(Arena*);
template<> ::game::JoinGameAsOwnerRequest* Arena::CreateMaybeMessage<::game::JoinGameAsOwnerRequest>(Arena*);
template<> ::game::JoinGameAsOwnerResponse* Arena::CreateMaybeMessage<::game::JoinGameAsOwnerResponse>(Arena*);
template<> ::game::JoinGameRequest* Arena::CreateMaybeMessage<::game::JoinGameRequest>(Arena*);
template<> ::game::JoinGameResponse* Arena::CreateMaybeMessage<::game::JoinGameResponse>(Arena*);
template<> ::game::LobbyRequests* Arena::CreateMaybeMessage<::game::LobbyRequests>(Arena*);
template<> ::game::LobbyResponses* Arena::CreateMaybeMessage<::game::LobbyResponses>(Arena*);
template<> ::game::LoginRequest* Arena::CreateMaybeMessage<::game::LoginRequest>(Arena*);
template<> ::game::LoginRequestFirst* Arena::CreateMaybeMessage<::game::LoginRequestFirst>(Arena*);
template<> ::game::LoginRequestSecond* Arena::CreateMaybeMessage<::game::LoginRequestSecond>(Arena*);
template<> ::game::LoginResponse* Arena::CreateMaybeMessage<::game::LoginResponse>(Arena*);
template<> ::game::LoginResponseFirst* Arena::CreateMaybeMessage<::game::LoginResponseFirst>(Arena*);
template<> ::game::LoginResponseSecond* Arena::CreateMaybeMessage<::game::LoginResponseSecond>(Arena*);
template<> ::game::MakeMoveRequest* Arena::CreateMaybeMessage<::game::MakeMoveRequest>(Arena*);
template<> ::game::MakeMoveResponse* Arena::CreateMaybeMessage<::game::MakeMoveResponse>(Arena*);
template<> ::game::Player* Arena::CreateMaybeMessage<::game::Player>(Arena*);
template<> ::game::PlayerInfo* Arena::CreateMaybeMessage<::game::PlayerInfo>(Arena*);
template<> ::game::RegisterRequest* Arena::CreateMaybeMessage<::game::RegisterRequest>(Arena*);
template<> ::game::RegisterResponse* Arena::CreateMaybeMessage<::game::RegisterResponse>(Arena*);
template<> ::game::SaltHash* Arena::CreateMaybeMessage<::game::SaltHash>(Arena*);
template<> ::game::SearchGameRequest* Arena::CreateMaybeMessage<::game::SearchGameRequest>(Arena*);
template<> ::game::SearchGameResponse* Arena::CreateMaybeMessage<::game::SearchGameResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace game {

enum error : int {
  ERROR_NO_USER_WITH_THIS_LOGIN = 0,
  ERROR_USER_WITH_THIS_LOGIN_ALREADY_EXISTS = 1,
  ERROR_UNCORRECT_PASSWORD = 2,
  ERROR_EXCEPTION = 3,
  ERROR_GAME_NOT_FOUND = 4,
  error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool error_IsValid(int value);
constexpr error error_MIN = ERROR_NO_USER_WITH_THIS_LOGIN;
constexpr error error_MAX = ERROR_GAME_NOT_FOUND;
constexpr int error_ARRAYSIZE = error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* error_descriptor();
template<typename T>
inline const std::string& error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    error_descriptor(), enum_t_value);
}
inline bool error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<error>(
    error_descriptor(), name, value);
}
enum PlayerStatus : int {
  PLAYER_STATUS_FOLD = 0,
  PLAYER_STATUS_PLAYING = 1,
  PLAYER_STATUS_WIN = 2,
  PlayerStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlayerStatus_IsValid(int value);
constexpr PlayerStatus PlayerStatus_MIN = PLAYER_STATUS_FOLD;
constexpr PlayerStatus PlayerStatus_MAX = PLAYER_STATUS_WIN;
constexpr int PlayerStatus_ARRAYSIZE = PlayerStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerStatus_descriptor();
template<typename T>
inline const std::string& PlayerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerStatus_descriptor(), enum_t_value);
}
inline bool PlayerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerStatus>(
    PlayerStatus_descriptor(), name, value);
}
enum MoveType : int {
  MOVE_TYPE_FOLD = 0,
  MOVE_TYPE_ALL_IN = 1,
  MOVE_TYPE_CHECK = 2,
  MOVE_TYPE_RAISE_BLIND = 3,
  MoveType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MoveType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MoveType_IsValid(int value);
constexpr MoveType MoveType_MIN = MOVE_TYPE_FOLD;
constexpr MoveType MoveType_MAX = MOVE_TYPE_RAISE_BLIND;
constexpr int MoveType_ARRAYSIZE = MoveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveType_descriptor();
template<typename T>
inline const std::string& MoveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MoveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MoveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MoveType_descriptor(), enum_t_value);
}
inline bool MoveType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MoveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MoveType>(
    MoveType_descriptor(), name, value);
}
enum Suits : int {
  SUITS_DIAMONDS = 0,
  SUITS_HEARTS = 1,
  SUITS_CLUBS = 2,
  SUITS_SPADES = 3,
  Suits_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Suits_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Suits_IsValid(int value);
constexpr Suits Suits_MIN = SUITS_DIAMONDS;
constexpr Suits Suits_MAX = SUITS_SPADES;
constexpr int Suits_ARRAYSIZE = Suits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Suits_descriptor();
template<typename T>
inline const std::string& Suits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Suits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Suits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Suits_descriptor(), enum_t_value);
}
inline bool Suits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Suits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Suits>(
    Suits_descriptor(), name, value);
}
enum Values : int {
  VALUES_TWO = 0,
  VALUES_THREE = 1,
  VALUES_FOUR = 2,
  VALUES_FIVE = 3,
  VALUES_SIX = 4,
  VALUES_SEVEN = 5,
  VALUES_EIGHT = 6,
  VALUES_NINE = 7,
  VALUES_TEN = 8,
  VALUES_JACK = 9,
  VALUES_QUEEN = 10,
  VALUES_KING = 11,
  VALUES_ACE = 12,
  Values_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Values_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Values_IsValid(int value);
constexpr Values Values_MIN = VALUES_TWO;
constexpr Values Values_MAX = VALUES_ACE;
constexpr int Values_ARRAYSIZE = Values_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Values_descriptor();
template<typename T>
inline const std::string& Values_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Values>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Values_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Values_descriptor(), enum_t_value);
}
inline bool Values_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Values* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Values>(
    Values_descriptor(), name, value);
}
// ===================================================================

class ErrorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.ErrorMessage) */ {
 public:
  inline ErrorMessage() : ErrorMessage(nullptr) {}
  ~ErrorMessage() override;
  explicit PROTOBUF_CONSTEXPR ErrorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorMessage(const ErrorMessage& from);
  ErrorMessage(ErrorMessage&& from) noexcept
    : ErrorMessage() {
    *this = ::std::move(from);
  }

  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorMessage& operator=(ErrorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorMessage* internal_default_instance() {
    return reinterpret_cast<const ErrorMessage*>(
               &_ErrorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ErrorMessage& a, ErrorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorMessage& from) {
    ErrorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.ErrorMessage";
  }
  protected:
  explicit ErrorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageStringFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // optional string message_string = 2;
  bool has_message_string() const;
  private:
  bool _internal_has_message_string() const;
  public:
  void clear_message_string();
  const std::string& message_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_string();
  PROTOBUF_NODISCARD std::string* release_message_string();
  void set_allocated_message_string(std::string* message_string);
  private:
  const std::string& _internal_message_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_string(const std::string& value);
  std::string* _internal_mutable_message_string();
  public:

  // .game.error error = 1;
  void clear_error();
  ::game::error error() const;
  void set_error(::game::error value);
  private:
  ::game::error _internal_error() const;
  void _internal_set_error(::game::error value);
  public:

  // @@protoc_insertion_point(class_scope:game.ErrorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_string_;
    int error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  enum LoginRequestsCase {
    kLoginRequestFirst = 1,
    kLoginRequestSecond = 2,
    LOGIN_REQUESTS_NOT_SET = 0,
  };

  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginRequestFirstFieldNumber = 1,
    kLoginRequestSecondFieldNumber = 2,
  };
  // .game.LoginRequestFirst login_request_first = 1;
  bool has_login_request_first() const;
  private:
  bool _internal_has_login_request_first() const;
  public:
  void clear_login_request_first();
  const ::game::LoginRequestFirst& login_request_first() const;
  PROTOBUF_NODISCARD ::game::LoginRequestFirst* release_login_request_first();
  ::game::LoginRequestFirst* mutable_login_request_first();
  void set_allocated_login_request_first(::game::LoginRequestFirst* login_request_first);
  private:
  const ::game::LoginRequestFirst& _internal_login_request_first() const;
  ::game::LoginRequestFirst* _internal_mutable_login_request_first();
  public:
  void unsafe_arena_set_allocated_login_request_first(
      ::game::LoginRequestFirst* login_request_first);
  ::game::LoginRequestFirst* unsafe_arena_release_login_request_first();

  // .game.LoginRequestSecond login_request_second = 2;
  bool has_login_request_second() const;
  private:
  bool _internal_has_login_request_second() const;
  public:
  void clear_login_request_second();
  const ::game::LoginRequestSecond& login_request_second() const;
  PROTOBUF_NODISCARD ::game::LoginRequestSecond* release_login_request_second();
  ::game::LoginRequestSecond* mutable_login_request_second();
  void set_allocated_login_request_second(::game::LoginRequestSecond* login_request_second);
  private:
  const ::game::LoginRequestSecond& _internal_login_request_second() const;
  ::game::LoginRequestSecond* _internal_mutable_login_request_second();
  public:
  void unsafe_arena_set_allocated_login_request_second(
      ::game::LoginRequestSecond* login_request_second);
  ::game::LoginRequestSecond* unsafe_arena_release_login_request_second();

  void clear_login_requests();
  LoginRequestsCase login_requests_case() const;
  // @@protoc_insertion_point(class_scope:game.LoginRequest)
 private:
  class _Internal;
  void set_has_login_request_first();
  void set_has_login_request_second();

  inline bool has_login_requests() const;
  inline void clear_has_login_requests();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LoginRequestsUnion {
      constexpr LoginRequestsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::LoginRequestFirst* login_request_first_;
      ::game::LoginRequestSecond* login_request_second_;
    } login_requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  enum LoginResponsesCase {
    kLoginResponseFirst = 1,
    kLoginResponseSecond = 2,
    LOGIN_RESPONSES_NOT_SET = 0,
  };

  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginResponseFirstFieldNumber = 1,
    kLoginResponseSecondFieldNumber = 2,
  };
  // .game.LoginResponseFirst login_response_first = 1;
  bool has_login_response_first() const;
  private:
  bool _internal_has_login_response_first() const;
  public:
  void clear_login_response_first();
  const ::game::LoginResponseFirst& login_response_first() const;
  PROTOBUF_NODISCARD ::game::LoginResponseFirst* release_login_response_first();
  ::game::LoginResponseFirst* mutable_login_response_first();
  void set_allocated_login_response_first(::game::LoginResponseFirst* login_response_first);
  private:
  const ::game::LoginResponseFirst& _internal_login_response_first() const;
  ::game::LoginResponseFirst* _internal_mutable_login_response_first();
  public:
  void unsafe_arena_set_allocated_login_response_first(
      ::game::LoginResponseFirst* login_response_first);
  ::game::LoginResponseFirst* unsafe_arena_release_login_response_first();

  // .game.LoginResponseSecond login_response_second = 2;
  bool has_login_response_second() const;
  private:
  bool _internal_has_login_response_second() const;
  public:
  void clear_login_response_second();
  const ::game::LoginResponseSecond& login_response_second() const;
  PROTOBUF_NODISCARD ::game::LoginResponseSecond* release_login_response_second();
  ::game::LoginResponseSecond* mutable_login_response_second();
  void set_allocated_login_response_second(::game::LoginResponseSecond* login_response_second);
  private:
  const ::game::LoginResponseSecond& _internal_login_response_second() const;
  ::game::LoginResponseSecond* _internal_mutable_login_response_second();
  public:
  void unsafe_arena_set_allocated_login_response_second(
      ::game::LoginResponseSecond* login_response_second);
  ::game::LoginResponseSecond* unsafe_arena_release_login_response_second();

  void clear_login_responses();
  LoginResponsesCase login_responses_case() const;
  // @@protoc_insertion_point(class_scope:game.LoginResponse)
 private:
  class _Internal;
  void set_has_login_response_first();
  void set_has_login_response_second();

  inline bool has_login_responses() const;
  inline void clear_has_login_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LoginResponsesUnion {
      constexpr LoginResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::LoginResponseFirst* login_response_first_;
      ::game::LoginResponseSecond* login_response_second_;
    } login_responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginRequestFirst final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginRequestFirst) */ {
 public:
  inline LoginRequestFirst() : LoginRequestFirst(nullptr) {}
  ~LoginRequestFirst() override;
  explicit PROTOBUF_CONSTEXPR LoginRequestFirst(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequestFirst(const LoginRequestFirst& from);
  LoginRequestFirst(LoginRequestFirst&& from) noexcept
    : LoginRequestFirst() {
    *this = ::std::move(from);
  }

  inline LoginRequestFirst& operator=(const LoginRequestFirst& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequestFirst& operator=(LoginRequestFirst&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequestFirst& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequestFirst* internal_default_instance() {
    return reinterpret_cast<const LoginRequestFirst*>(
               &_LoginRequestFirst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginRequestFirst& a, LoginRequestFirst& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequestFirst* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequestFirst* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequestFirst* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequestFirst>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequestFirst& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequestFirst& from) {
    LoginRequestFirst::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequestFirst* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginRequestFirst";
  }
  protected:
  explicit LoginRequestFirst(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:game.LoginRequestFirst)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginRequestSecond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginRequestSecond) */ {
 public:
  inline LoginRequestSecond() : LoginRequestSecond(nullptr) {}
  ~LoginRequestSecond() override;
  explicit PROTOBUF_CONSTEXPR LoginRequestSecond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequestSecond(const LoginRequestSecond& from);
  LoginRequestSecond(LoginRequestSecond&& from) noexcept
    : LoginRequestSecond() {
    *this = ::std::move(from);
  }

  inline LoginRequestSecond& operator=(const LoginRequestSecond& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequestSecond& operator=(LoginRequestSecond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequestSecond& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequestSecond* internal_default_instance() {
    return reinterpret_cast<const LoginRequestSecond*>(
               &_LoginRequestSecond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginRequestSecond& a, LoginRequestSecond& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequestSecond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequestSecond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequestSecond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequestSecond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequestSecond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequestSecond& from) {
    LoginRequestSecond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequestSecond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginRequestSecond";
  }
  protected:
  explicit LoginRequestSecond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kHashedFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string hashed = 2;
  void clear_hashed();
  const std::string& hashed() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hashed(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hashed();
  PROTOBUF_NODISCARD std::string* release_hashed();
  void set_allocated_hashed(std::string* hashed);
  private:
  const std::string& _internal_hashed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hashed(const std::string& value);
  std::string* _internal_mutable_hashed();
  public:

  // @@protoc_insertion_point(class_scope:game.LoginRequestSecond)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginResponseFirst final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginResponseFirst) */ {
 public:
  inline LoginResponseFirst() : LoginResponseFirst(nullptr) {}
  ~LoginResponseFirst() override;
  explicit PROTOBUF_CONSTEXPR LoginResponseFirst(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponseFirst(const LoginResponseFirst& from);
  LoginResponseFirst(LoginResponseFirst&& from) noexcept
    : LoginResponseFirst() {
    *this = ::std::move(from);
  }

  inline LoginResponseFirst& operator=(const LoginResponseFirst& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponseFirst& operator=(LoginResponseFirst&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponseFirst& default_instance() {
    return *internal_default_instance();
  }
  enum LoginResponsesFirstCase {
    kSalt = 1,
    kMsg = 2,
    LOGIN_RESPONSES_FIRST_NOT_SET = 0,
  };

  static inline const LoginResponseFirst* internal_default_instance() {
    return reinterpret_cast<const LoginResponseFirst*>(
               &_LoginResponseFirst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginResponseFirst& a, LoginResponseFirst& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponseFirst* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponseFirst* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponseFirst* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponseFirst>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponseFirst& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponseFirst& from) {
    LoginResponseFirst::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponseFirst* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginResponseFirst";
  }
  protected:
  explicit LoginResponseFirst(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaltFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // string salt = 1;
  bool has_salt() const;
  private:
  bool _internal_has_salt() const;
  public:
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  void clear_login_responses_first();
  LoginResponsesFirstCase login_responses_first_case() const;
  // @@protoc_insertion_point(class_scope:game.LoginResponseFirst)
 private:
  class _Internal;
  void set_has_salt();
  void set_has_msg();

  inline bool has_login_responses_first() const;
  inline void clear_has_login_responses_first();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LoginResponsesFirstUnion {
      constexpr LoginResponsesFirstUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
      ::game::ErrorMessage* msg_;
    } login_responses_first_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginResponseSecond final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LoginResponseSecond) */ {
 public:
  inline LoginResponseSecond() : LoginResponseSecond(nullptr) {}
  ~LoginResponseSecond() override;
  explicit PROTOBUF_CONSTEXPR LoginResponseSecond(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponseSecond(const LoginResponseSecond& from);
  LoginResponseSecond(LoginResponseSecond&& from) noexcept
    : LoginResponseSecond() {
    *this = ::std::move(from);
  }

  inline LoginResponseSecond& operator=(const LoginResponseSecond& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponseSecond& operator=(LoginResponseSecond&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponseSecond& default_instance() {
    return *internal_default_instance();
  }
  enum LoginResponsesSecondCase {
    kPlayerInfo = 1,
    kMsg = 2,
    LOGIN_RESPONSES_SECOND_NOT_SET = 0,
  };

  static inline const LoginResponseSecond* internal_default_instance() {
    return reinterpret_cast<const LoginResponseSecond*>(
               &_LoginResponseSecond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginResponseSecond& a, LoginResponseSecond& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponseSecond* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponseSecond* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponseSecond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponseSecond>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponseSecond& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponseSecond& from) {
    LoginResponseSecond::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponseSecond* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LoginResponseSecond";
  }
  protected:
  explicit LoginResponseSecond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // .game.PlayerInfo player_info = 1;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::game::PlayerInfo& player_info() const;
  PROTOBUF_NODISCARD ::game::PlayerInfo* release_player_info();
  ::game::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::game::PlayerInfo* player_info);
  private:
  const ::game::PlayerInfo& _internal_player_info() const;
  ::game::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::game::PlayerInfo* player_info);
  ::game::PlayerInfo* unsafe_arena_release_player_info();

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  void clear_login_responses_second();
  LoginResponsesSecondCase login_responses_second_case() const;
  // @@protoc_insertion_point(class_scope:game.LoginResponseSecond)
 private:
  class _Internal;
  void set_has_player_info();
  void set_has_msg();

  inline bool has_login_responses_second() const;
  inline void clear_has_login_responses_second();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LoginResponsesSecondUnion {
      constexpr LoginResponsesSecondUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::PlayerInfo* player_info_;
      ::game::ErrorMessage* msg_;
    } login_responses_second_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSaltHashFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .game.SaltHash salt_hash = 2;
  bool has_salt_hash() const;
  private:
  bool _internal_has_salt_hash() const;
  public:
  void clear_salt_hash();
  const ::game::SaltHash& salt_hash() const;
  PROTOBUF_NODISCARD ::game::SaltHash* release_salt_hash();
  ::game::SaltHash* mutable_salt_hash();
  void set_allocated_salt_hash(::game::SaltHash* salt_hash);
  private:
  const ::game::SaltHash& _internal_salt_hash() const;
  ::game::SaltHash* _internal_mutable_salt_hash();
  public:
  void unsafe_arena_set_allocated_salt_hash(
      ::game::SaltHash* salt_hash);
  ::game::SaltHash* unsafe_arena_release_salt_hash();

  // @@protoc_insertion_point(class_scope:game.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::game::SaltHash* salt_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  enum RegisterResponsesCase {
    kPlayerInfo = 1,
    kMsg = 2,
    REGISTER_RESPONSES_NOT_SET = 0,
  };

  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterResponse& from) {
    RegisterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // .game.PlayerInfo player_info = 1;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::game::PlayerInfo& player_info() const;
  PROTOBUF_NODISCARD ::game::PlayerInfo* release_player_info();
  ::game::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::game::PlayerInfo* player_info);
  private:
  const ::game::PlayerInfo& _internal_player_info() const;
  ::game::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::game::PlayerInfo* player_info);
  ::game::PlayerInfo* unsafe_arena_release_player_info();

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  void clear_register_responses();
  RegisterResponsesCase register_responses_case() const;
  // @@protoc_insertion_point(class_scope:game.RegisterResponse)
 private:
  class _Internal;
  void set_has_player_info();
  void set_has_msg();

  inline bool has_register_responses() const;
  inline void clear_has_register_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RegisterResponsesUnion {
      constexpr RegisterResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::PlayerInfo* player_info_;
      ::game::ErrorMessage* msg_;
    } register_responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class SaltHash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SaltHash) */ {
 public:
  inline SaltHash() : SaltHash(nullptr) {}
  ~SaltHash() override;
  explicit PROTOBUF_CONSTEXPR SaltHash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaltHash(const SaltHash& from);
  SaltHash(SaltHash&& from) noexcept
    : SaltHash() {
    *this = ::std::move(from);
  }

  inline SaltHash& operator=(const SaltHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaltHash& operator=(SaltHash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaltHash& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaltHash* internal_default_instance() {
    return reinterpret_cast<const SaltHash*>(
               &_SaltHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SaltHash& a, SaltHash& b) {
    a.Swap(&b);
  }
  inline void Swap(SaltHash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaltHash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaltHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaltHash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaltHash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaltHash& from) {
    SaltHash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaltHash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SaltHash";
  }
  protected:
  explicit SaltHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaltFieldNumber = 1,
    kHashFieldNumber = 2,
  };
  // string salt = 1;
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // string hash = 2;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:game.SaltHash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  explicit PROTOBUF_CONSTEXPR Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kStatusFieldNumber = 2,
    kBalanceFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .game.PlayerStatus status = 2;
  void clear_status();
  ::game::PlayerStatus status() const;
  void set_status(::game::PlayerStatus value);
  private:
  ::game::PlayerStatus _internal_status() const;
  void _internal_set_status(::game::PlayerStatus value);
  public:

  // uint32 balance = 3;
  void clear_balance();
  uint32_t balance() const;
  void set_balance(uint32_t value);
  private:
  uint32_t _internal_balance() const;
  void _internal_set_balance(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int status_;
    uint32_t balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LobbyRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LobbyRequests) */ {
 public:
  inline LobbyRequests() : LobbyRequests(nullptr) {}
  ~LobbyRequests() override;
  explicit PROTOBUF_CONSTEXPR LobbyRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyRequests(const LobbyRequests& from);
  LobbyRequests(LobbyRequests&& from) noexcept
    : LobbyRequests() {
    *this = ::std::move(from);
  }

  inline LobbyRequests& operator=(const LobbyRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyRequests& operator=(LobbyRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyRequests& default_instance() {
    return *internal_default_instance();
  }
  enum RequestsCase {
    kCreateGameRequest = 1,
    kSearchGameRequest = 2,
    REQUESTS_NOT_SET = 0,
  };

  static inline const LobbyRequests* internal_default_instance() {
    return reinterpret_cast<const LobbyRequests*>(
               &_LobbyRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LobbyRequests& a, LobbyRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LobbyRequests& from) {
    LobbyRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LobbyRequests";
  }
  protected:
  explicit LobbyRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateGameRequestFieldNumber = 1,
    kSearchGameRequestFieldNumber = 2,
  };
  // .game.CreateGameRequest create_game_request = 1;
  bool has_create_game_request() const;
  private:
  bool _internal_has_create_game_request() const;
  public:
  void clear_create_game_request();
  const ::game::CreateGameRequest& create_game_request() const;
  PROTOBUF_NODISCARD ::game::CreateGameRequest* release_create_game_request();
  ::game::CreateGameRequest* mutable_create_game_request();
  void set_allocated_create_game_request(::game::CreateGameRequest* create_game_request);
  private:
  const ::game::CreateGameRequest& _internal_create_game_request() const;
  ::game::CreateGameRequest* _internal_mutable_create_game_request();
  public:
  void unsafe_arena_set_allocated_create_game_request(
      ::game::CreateGameRequest* create_game_request);
  ::game::CreateGameRequest* unsafe_arena_release_create_game_request();

  // .game.SearchGameRequest search_game_request = 2;
  bool has_search_game_request() const;
  private:
  bool _internal_has_search_game_request() const;
  public:
  void clear_search_game_request();
  const ::game::SearchGameRequest& search_game_request() const;
  PROTOBUF_NODISCARD ::game::SearchGameRequest* release_search_game_request();
  ::game::SearchGameRequest* mutable_search_game_request();
  void set_allocated_search_game_request(::game::SearchGameRequest* search_game_request);
  private:
  const ::game::SearchGameRequest& _internal_search_game_request() const;
  ::game::SearchGameRequest* _internal_mutable_search_game_request();
  public:
  void unsafe_arena_set_allocated_search_game_request(
      ::game::SearchGameRequest* search_game_request);
  ::game::SearchGameRequest* unsafe_arena_release_search_game_request();

  void clear_requests();
  RequestsCase requests_case() const;
  // @@protoc_insertion_point(class_scope:game.LobbyRequests)
 private:
  class _Internal;
  void set_has_create_game_request();
  void set_has_search_game_request();

  inline bool has_requests() const;
  inline void clear_has_requests();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestsUnion {
      constexpr RequestsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::CreateGameRequest* create_game_request_;
      ::game::SearchGameRequest* search_game_request_;
    } requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LobbyResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.LobbyResponses) */ {
 public:
  inline LobbyResponses() : LobbyResponses(nullptr) {}
  ~LobbyResponses() override;
  explicit PROTOBUF_CONSTEXPR LobbyResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyResponses(const LobbyResponses& from);
  LobbyResponses(LobbyResponses&& from) noexcept
    : LobbyResponses() {
    *this = ::std::move(from);
  }

  inline LobbyResponses& operator=(const LobbyResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyResponses& operator=(LobbyResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyResponses& default_instance() {
    return *internal_default_instance();
  }
  enum ResponsesCase {
    kCreateGameResponse = 1,
    kSearchGameResponse = 2,
    RESPONSES_NOT_SET = 0,
  };

  static inline const LobbyResponses* internal_default_instance() {
    return reinterpret_cast<const LobbyResponses*>(
               &_LobbyResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LobbyResponses& a, LobbyResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LobbyResponses& from) {
    LobbyResponses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.LobbyResponses";
  }
  protected:
  explicit LobbyResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateGameResponseFieldNumber = 1,
    kSearchGameResponseFieldNumber = 2,
  };
  // .game.CreateGameResponse create_game_response = 1;
  bool has_create_game_response() const;
  private:
  bool _internal_has_create_game_response() const;
  public:
  void clear_create_game_response();
  const ::game::CreateGameResponse& create_game_response() const;
  PROTOBUF_NODISCARD ::game::CreateGameResponse* release_create_game_response();
  ::game::CreateGameResponse* mutable_create_game_response();
  void set_allocated_create_game_response(::game::CreateGameResponse* create_game_response);
  private:
  const ::game::CreateGameResponse& _internal_create_game_response() const;
  ::game::CreateGameResponse* _internal_mutable_create_game_response();
  public:
  void unsafe_arena_set_allocated_create_game_response(
      ::game::CreateGameResponse* create_game_response);
  ::game::CreateGameResponse* unsafe_arena_release_create_game_response();

  // .game.SearchGameResponse search_game_response = 2;
  bool has_search_game_response() const;
  private:
  bool _internal_has_search_game_response() const;
  public:
  void clear_search_game_response();
  const ::game::SearchGameResponse& search_game_response() const;
  PROTOBUF_NODISCARD ::game::SearchGameResponse* release_search_game_response();
  ::game::SearchGameResponse* mutable_search_game_response();
  void set_allocated_search_game_response(::game::SearchGameResponse* search_game_response);
  private:
  const ::game::SearchGameResponse& _internal_search_game_response() const;
  ::game::SearchGameResponse* _internal_mutable_search_game_response();
  public:
  void unsafe_arena_set_allocated_search_game_response(
      ::game::SearchGameResponse* search_game_response);
  ::game::SearchGameResponse* unsafe_arena_release_search_game_response();

  void clear_responses();
  ResponsesCase responses_case() const;
  // @@protoc_insertion_point(class_scope:game.LobbyResponses)
 private:
  class _Internal;
  void set_has_create_game_response();
  void set_has_search_game_response();

  inline bool has_responses() const;
  inline void clear_has_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponsesUnion {
      constexpr ResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::CreateGameResponse* create_game_response_;
      ::game::SearchGameResponse* search_game_response_;
    } responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class CreateGameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CreateGameRequest) */ {
 public:
  inline CreateGameRequest() : CreateGameRequest(nullptr) {}
  ~CreateGameRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGameRequest(const CreateGameRequest& from);
  CreateGameRequest(CreateGameRequest&& from) noexcept
    : CreateGameRequest() {
    *this = ::std::move(from);
  }

  inline CreateGameRequest& operator=(const CreateGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGameRequest& operator=(CreateGameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGameRequest* internal_default_instance() {
    return reinterpret_cast<const CreateGameRequest*>(
               &_CreateGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CreateGameRequest& a, CreateGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateGameRequest& from) {
    CreateGameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CreateGameRequest";
  }
  protected:
  explicit CreateGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameParametersFieldNumber = 2,
    kGameOwnerIdFieldNumber = 1,
  };
  // .game.GameParameters game_parameters = 2;
  bool has_game_parameters() const;
  private:
  bool _internal_has_game_parameters() const;
  public:
  void clear_game_parameters();
  const ::game::GameParameters& game_parameters() const;
  PROTOBUF_NODISCARD ::game::GameParameters* release_game_parameters();
  ::game::GameParameters* mutable_game_parameters();
  void set_allocated_game_parameters(::game::GameParameters* game_parameters);
  private:
  const ::game::GameParameters& _internal_game_parameters() const;
  ::game::GameParameters* _internal_mutable_game_parameters();
  public:
  void unsafe_arena_set_allocated_game_parameters(
      ::game::GameParameters* game_parameters);
  ::game::GameParameters* unsafe_arena_release_game_parameters();

  // uint32 game_owner_id = 1;
  void clear_game_owner_id();
  uint32_t game_owner_id() const;
  void set_game_owner_id(uint32_t value);
  private:
  uint32_t _internal_game_owner_id() const;
  void _internal_set_game_owner_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.CreateGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::game::GameParameters* game_parameters_;
    uint32_t game_owner_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class CreateGameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.CreateGameResponse) */ {
 public:
  inline CreateGameResponse() : CreateGameResponse(nullptr) {}
  ~CreateGameResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateGameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGameResponse(const CreateGameResponse& from);
  CreateGameResponse(CreateGameResponse&& from) noexcept
    : CreateGameResponse() {
    *this = ::std::move(from);
  }

  inline CreateGameResponse& operator=(const CreateGameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGameResponse& operator=(CreateGameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGameResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponsesCase {
    kGameId = 1,
    kMsg = 2,
    RESPONSES_NOT_SET = 0,
  };

  static inline const CreateGameResponse* internal_default_instance() {
    return reinterpret_cast<const CreateGameResponse*>(
               &_CreateGameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateGameResponse& a, CreateGameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateGameResponse& from) {
    CreateGameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.CreateGameResponse";
  }
  protected:
  explicit CreateGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // uint32 game_id = 1;
  bool has_game_id() const;
  private:
  bool _internal_has_game_id() const;
  public:
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  void clear_responses();
  ResponsesCase responses_case() const;
  // @@protoc_insertion_point(class_scope:game.CreateGameResponse)
 private:
  class _Internal;
  void set_has_game_id();
  void set_has_msg();

  inline bool has_responses() const;
  inline void clear_has_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponsesUnion {
      constexpr ResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t game_id_;
      ::game::ErrorMessage* msg_;
    } responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class SearchGameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SearchGameRequest) */ {
 public:
  inline SearchGameRequest() : SearchGameRequest(nullptr) {}
  ~SearchGameRequest() override;
  explicit PROTOBUF_CONSTEXPR SearchGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchGameRequest(const SearchGameRequest& from);
  SearchGameRequest(SearchGameRequest&& from) noexcept
    : SearchGameRequest() {
    *this = ::std::move(from);
  }

  inline SearchGameRequest& operator=(const SearchGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchGameRequest& operator=(SearchGameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchGameRequest* internal_default_instance() {
    return reinterpret_cast<const SearchGameRequest*>(
               &_SearchGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SearchGameRequest& a, SearchGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchGameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchGameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchGameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchGameRequest& from) {
    SearchGameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchGameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SearchGameRequest";
  }
  protected:
  explicit SearchGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameParametersFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // .game.GameParameters game_parameters = 2;
  bool has_game_parameters() const;
  private:
  bool _internal_has_game_parameters() const;
  public:
  void clear_game_parameters();
  const ::game::GameParameters& game_parameters() const;
  PROTOBUF_NODISCARD ::game::GameParameters* release_game_parameters();
  ::game::GameParameters* mutable_game_parameters();
  void set_allocated_game_parameters(::game::GameParameters* game_parameters);
  private:
  const ::game::GameParameters& _internal_game_parameters() const;
  ::game::GameParameters* _internal_mutable_game_parameters();
  public:
  void unsafe_arena_set_allocated_game_parameters(
      ::game::GameParameters* game_parameters);
  ::game::GameParameters* unsafe_arena_release_game_parameters();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.SearchGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::game::GameParameters* game_parameters_;
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class SearchGameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.SearchGameResponse) */ {
 public:
  inline SearchGameResponse() : SearchGameResponse(nullptr) {}
  ~SearchGameResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchGameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchGameResponse(const SearchGameResponse& from);
  SearchGameResponse(SearchGameResponse&& from) noexcept
    : SearchGameResponse() {
    *this = ::std::move(from);
  }

  inline SearchGameResponse& operator=(const SearchGameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchGameResponse& operator=(SearchGameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchGameResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponsesCase {
    kGameId = 1,
    kMsg = 2,
    RESPONSES_NOT_SET = 0,
  };

  static inline const SearchGameResponse* internal_default_instance() {
    return reinterpret_cast<const SearchGameResponse*>(
               &_SearchGameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SearchGameResponse& a, SearchGameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchGameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchGameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchGameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchGameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchGameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchGameResponse& from) {
    SearchGameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchGameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.SearchGameResponse";
  }
  protected:
  explicit SearchGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // uint32 game_id = 1;
  bool has_game_id() const;
  private:
  bool _internal_has_game_id() const;
  public:
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  void clear_responses();
  ResponsesCase responses_case() const;
  // @@protoc_insertion_point(class_scope:game.SearchGameResponse)
 private:
  class _Internal;
  void set_has_game_id();
  void set_has_msg();

  inline bool has_responses() const;
  inline void clear_has_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponsesUnion {
      constexpr ResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint32_t game_id_;
      ::game::ErrorMessage* msg_;
    } responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.GameParameters) */ {
 public:
  inline GameParameters() : GameParameters(nullptr) {}
  ~GameParameters() override;
  explicit PROTOBUF_CONSTEXPR GameParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameParameters(const GameParameters& from);
  GameParameters(GameParameters&& from) noexcept
    : GameParameters() {
    *this = ::std::move(from);
  }

  inline GameParameters& operator=(const GameParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameParameters& operator=(GameParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameParameters* internal_default_instance() {
    return reinterpret_cast<const GameParameters*>(
               &_GameParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GameParameters& a, GameParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(GameParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameParameters& from) {
    GameParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.GameParameters";
  }
  protected:
  explicit GameParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameNameFieldNumber = 1,
    kNumberOfPlayersFieldNumber = 2,
    kMinimalBetFieldNumber = 3,
    kGameEnterBalanceFieldNumber = 4,
  };
  // string game_name = 1;
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // uint32 number_of_players = 2;
  void clear_number_of_players();
  uint32_t number_of_players() const;
  void set_number_of_players(uint32_t value);
  private:
  uint32_t _internal_number_of_players() const;
  void _internal_set_number_of_players(uint32_t value);
  public:

  // uint32 minimal_bet = 3;
  void clear_minimal_bet();
  uint32_t minimal_bet() const;
  void set_minimal_bet(uint32_t value);
  private:
  uint32_t _internal_minimal_bet() const;
  void _internal_set_minimal_bet(uint32_t value);
  public:

  // uint32 game_enter_balance = 4;
  void clear_game_enter_balance();
  uint32_t game_enter_balance() const;
  void set_game_enter_balance(uint32_t value);
  private:
  uint32_t _internal_game_enter_balance() const;
  void _internal_set_game_enter_balance(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.GameParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
    uint32_t number_of_players_;
    uint32_t minimal_bet_;
    uint32_t game_enter_balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kClientGamesFieldNumber = 2,
    kClientWinsFieldNumber = 3,
    kClientBalanceFieldNumber = 4,
  };
  // uint32 client_id = 1;
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // uint32 client_games = 2;
  void clear_client_games();
  uint32_t client_games() const;
  void set_client_games(uint32_t value);
  private:
  uint32_t _internal_client_games() const;
  void _internal_set_client_games(uint32_t value);
  public:

  // uint32 client_wins = 3;
  void clear_client_wins();
  uint32_t client_wins() const;
  void set_client_wins(uint32_t value);
  private:
  uint32_t _internal_client_wins() const;
  void _internal_set_client_wins(uint32_t value);
  public:

  // uint32 client_balance = 4;
  void clear_client_balance();
  uint32_t client_balance() const;
  void set_client_balance(uint32_t value);
  private:
  uint32_t _internal_client_balance() const;
  void _internal_set_client_balance(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t client_id_;
    uint32_t client_games_;
    uint32_t client_wins_;
    uint32_t client_balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.GameRequests) */ {
 public:
  inline GameRequests() : GameRequests(nullptr) {}
  ~GameRequests() override;
  explicit PROTOBUF_CONSTEXPR GameRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameRequests(const GameRequests& from);
  GameRequests(GameRequests&& from) noexcept
    : GameRequests() {
    *this = ::std::move(from);
  }

  inline GameRequests& operator=(const GameRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameRequests& operator=(GameRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameRequests& default_instance() {
    return *internal_default_instance();
  }
  enum RequestsCase {
    kMakeMoveRequest = 1,
    kJoinGameRequest = 2,
    kJoinGameAsOwnerRequest = 3,
    REQUESTS_NOT_SET = 0,
  };

  static inline const GameRequests* internal_default_instance() {
    return reinterpret_cast<const GameRequests*>(
               &_GameRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GameRequests& a, GameRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(GameRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameRequests& from) {
    GameRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.GameRequests";
  }
  protected:
  explicit GameRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakeMoveRequestFieldNumber = 1,
    kJoinGameRequestFieldNumber = 2,
    kJoinGameAsOwnerRequestFieldNumber = 3,
  };
  // .game.MakeMoveRequest make_move_request = 1;
  bool has_make_move_request() const;
  private:
  bool _internal_has_make_move_request() const;
  public:
  void clear_make_move_request();
  const ::game::MakeMoveRequest& make_move_request() const;
  PROTOBUF_NODISCARD ::game::MakeMoveRequest* release_make_move_request();
  ::game::MakeMoveRequest* mutable_make_move_request();
  void set_allocated_make_move_request(::game::MakeMoveRequest* make_move_request);
  private:
  const ::game::MakeMoveRequest& _internal_make_move_request() const;
  ::game::MakeMoveRequest* _internal_mutable_make_move_request();
  public:
  void unsafe_arena_set_allocated_make_move_request(
      ::game::MakeMoveRequest* make_move_request);
  ::game::MakeMoveRequest* unsafe_arena_release_make_move_request();

  // .game.JoinGameRequest join_game_request = 2;
  bool has_join_game_request() const;
  private:
  bool _internal_has_join_game_request() const;
  public:
  void clear_join_game_request();
  const ::game::JoinGameRequest& join_game_request() const;
  PROTOBUF_NODISCARD ::game::JoinGameRequest* release_join_game_request();
  ::game::JoinGameRequest* mutable_join_game_request();
  void set_allocated_join_game_request(::game::JoinGameRequest* join_game_request);
  private:
  const ::game::JoinGameRequest& _internal_join_game_request() const;
  ::game::JoinGameRequest* _internal_mutable_join_game_request();
  public:
  void unsafe_arena_set_allocated_join_game_request(
      ::game::JoinGameRequest* join_game_request);
  ::game::JoinGameRequest* unsafe_arena_release_join_game_request();

  // .game.JoinGameAsOwnerRequest join_game_as_owner_request = 3;
  bool has_join_game_as_owner_request() const;
  private:
  bool _internal_has_join_game_as_owner_request() const;
  public:
  void clear_join_game_as_owner_request();
  const ::game::JoinGameAsOwnerRequest& join_game_as_owner_request() const;
  PROTOBUF_NODISCARD ::game::JoinGameAsOwnerRequest* release_join_game_as_owner_request();
  ::game::JoinGameAsOwnerRequest* mutable_join_game_as_owner_request();
  void set_allocated_join_game_as_owner_request(::game::JoinGameAsOwnerRequest* join_game_as_owner_request);
  private:
  const ::game::JoinGameAsOwnerRequest& _internal_join_game_as_owner_request() const;
  ::game::JoinGameAsOwnerRequest* _internal_mutable_join_game_as_owner_request();
  public:
  void unsafe_arena_set_allocated_join_game_as_owner_request(
      ::game::JoinGameAsOwnerRequest* join_game_as_owner_request);
  ::game::JoinGameAsOwnerRequest* unsafe_arena_release_join_game_as_owner_request();

  void clear_requests();
  RequestsCase requests_case() const;
  // @@protoc_insertion_point(class_scope:game.GameRequests)
 private:
  class _Internal;
  void set_has_make_move_request();
  void set_has_join_game_request();
  void set_has_join_game_as_owner_request();

  inline bool has_requests() const;
  inline void clear_has_requests();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestsUnion {
      constexpr RequestsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::MakeMoveRequest* make_move_request_;
      ::game::JoinGameRequest* join_game_request_;
      ::game::JoinGameAsOwnerRequest* join_game_as_owner_request_;
    } requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameResponses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.GameResponses) */ {
 public:
  inline GameResponses() : GameResponses(nullptr) {}
  ~GameResponses() override;
  explicit PROTOBUF_CONSTEXPR GameResponses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameResponses(const GameResponses& from);
  GameResponses(GameResponses&& from) noexcept
    : GameResponses() {
    *this = ::std::move(from);
  }

  inline GameResponses& operator=(const GameResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameResponses& operator=(GameResponses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameResponses& default_instance() {
    return *internal_default_instance();
  }
  enum ResponsesCase {
    kMakeMoveResponse = 1,
    kGameState = 2,
    kJoinGameResponse = 3,
    kJoinGameAsOwnerResponse = 4,
    RESPONSES_NOT_SET = 0,
  };

  static inline const GameResponses* internal_default_instance() {
    return reinterpret_cast<const GameResponses*>(
               &_GameResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GameResponses& a, GameResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(GameResponses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameResponses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameResponses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameResponses& from) {
    GameResponses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameResponses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.GameResponses";
  }
  protected:
  explicit GameResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakeMoveResponseFieldNumber = 1,
    kGameStateFieldNumber = 2,
    kJoinGameResponseFieldNumber = 3,
    kJoinGameAsOwnerResponseFieldNumber = 4,
  };
  // .game.MakeMoveResponse make_move_response = 1;
  bool has_make_move_response() const;
  private:
  bool _internal_has_make_move_response() const;
  public:
  void clear_make_move_response();
  const ::game::MakeMoveResponse& make_move_response() const;
  PROTOBUF_NODISCARD ::game::MakeMoveResponse* release_make_move_response();
  ::game::MakeMoveResponse* mutable_make_move_response();
  void set_allocated_make_move_response(::game::MakeMoveResponse* make_move_response);
  private:
  const ::game::MakeMoveResponse& _internal_make_move_response() const;
  ::game::MakeMoveResponse* _internal_mutable_make_move_response();
  public:
  void unsafe_arena_set_allocated_make_move_response(
      ::game::MakeMoveResponse* make_move_response);
  ::game::MakeMoveResponse* unsafe_arena_release_make_move_response();

  // .game.GameState game_state = 2;
  bool has_game_state() const;
  private:
  bool _internal_has_game_state() const;
  public:
  void clear_game_state();
  const ::game::GameState& game_state() const;
  PROTOBUF_NODISCARD ::game::GameState* release_game_state();
  ::game::GameState* mutable_game_state();
  void set_allocated_game_state(::game::GameState* game_state);
  private:
  const ::game::GameState& _internal_game_state() const;
  ::game::GameState* _internal_mutable_game_state();
  public:
  void unsafe_arena_set_allocated_game_state(
      ::game::GameState* game_state);
  ::game::GameState* unsafe_arena_release_game_state();

  // .game.JoinGameResponse join_game_response = 3;
  bool has_join_game_response() const;
  private:
  bool _internal_has_join_game_response() const;
  public:
  void clear_join_game_response();
  const ::game::JoinGameResponse& join_game_response() const;
  PROTOBUF_NODISCARD ::game::JoinGameResponse* release_join_game_response();
  ::game::JoinGameResponse* mutable_join_game_response();
  void set_allocated_join_game_response(::game::JoinGameResponse* join_game_response);
  private:
  const ::game::JoinGameResponse& _internal_join_game_response() const;
  ::game::JoinGameResponse* _internal_mutable_join_game_response();
  public:
  void unsafe_arena_set_allocated_join_game_response(
      ::game::JoinGameResponse* join_game_response);
  ::game::JoinGameResponse* unsafe_arena_release_join_game_response();

  // .game.JoinGameAsOwnerResponse join_game_as_owner_response = 4;
  bool has_join_game_as_owner_response() const;
  private:
  bool _internal_has_join_game_as_owner_response() const;
  public:
  void clear_join_game_as_owner_response();
  const ::game::JoinGameAsOwnerResponse& join_game_as_owner_response() const;
  PROTOBUF_NODISCARD ::game::JoinGameAsOwnerResponse* release_join_game_as_owner_response();
  ::game::JoinGameAsOwnerResponse* mutable_join_game_as_owner_response();
  void set_allocated_join_game_as_owner_response(::game::JoinGameAsOwnerResponse* join_game_as_owner_response);
  private:
  const ::game::JoinGameAsOwnerResponse& _internal_join_game_as_owner_response() const;
  ::game::JoinGameAsOwnerResponse* _internal_mutable_join_game_as_owner_response();
  public:
  void unsafe_arena_set_allocated_join_game_as_owner_response(
      ::game::JoinGameAsOwnerResponse* join_game_as_owner_response);
  ::game::JoinGameAsOwnerResponse* unsafe_arena_release_join_game_as_owner_response();

  void clear_responses();
  ResponsesCase responses_case() const;
  // @@protoc_insertion_point(class_scope:game.GameResponses)
 private:
  class _Internal;
  void set_has_make_move_response();
  void set_has_game_state();
  void set_has_join_game_response();
  void set_has_join_game_as_owner_response();

  inline bool has_responses() const;
  inline void clear_has_responses();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponsesUnion {
      constexpr ResponsesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::game::MakeMoveResponse* make_move_response_;
      ::game::GameState* game_state_;
      ::game::JoinGameResponse* join_game_response_;
      ::game::JoinGameAsOwnerResponse* join_game_as_owner_response_;
    } responses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class JoinGameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.JoinGameRequest) */ {
 public:
  inline JoinGameRequest() : JoinGameRequest(nullptr) {}
  ~JoinGameRequest() override;
  explicit PROTOBUF_CONSTEXPR JoinGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinGameRequest(const JoinGameRequest& from);
  JoinGameRequest(JoinGameRequest&& from) noexcept
    : JoinGameRequest() {
    *this = ::std::move(from);
  }

  inline JoinGameRequest& operator=(const JoinGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinGameRequest& operator=(JoinGameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinGameRequest* internal_default_instance() {
    return reinterpret_cast<const JoinGameRequest*>(
               &_JoinGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(JoinGameRequest& a, JoinGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinGameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinGameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinGameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinGameRequest& from) {
    JoinGameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinGameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.JoinGameRequest";
  }
  protected:
  explicit JoinGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 2,
    kPlayerInfoFieldNumber = 3,
    kGameIdFieldNumber = 1,
  };
  // string player_name = 2;
  void clear_player_name();
  const std::string& player_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // .game.PlayerInfo player_info = 3;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::game::PlayerInfo& player_info() const;
  PROTOBUF_NODISCARD ::game::PlayerInfo* release_player_info();
  ::game::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::game::PlayerInfo* player_info);
  private:
  const ::game::PlayerInfo& _internal_player_info() const;
  ::game::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::game::PlayerInfo* player_info);
  ::game::PlayerInfo* unsafe_arena_release_player_info();

  // uint32 game_id = 1;
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.JoinGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
    ::game::PlayerInfo* player_info_;
    uint32_t game_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class JoinGameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.JoinGameResponse) */ {
 public:
  inline JoinGameResponse() : JoinGameResponse(nullptr) {}
  ~JoinGameResponse() override;
  explicit PROTOBUF_CONSTEXPR JoinGameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinGameResponse(const JoinGameResponse& from);
  JoinGameResponse(JoinGameResponse&& from) noexcept
    : JoinGameResponse() {
    *this = ::std::move(from);
  }

  inline JoinGameResponse& operator=(const JoinGameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinGameResponse& operator=(JoinGameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinGameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinGameResponse* internal_default_instance() {
    return reinterpret_cast<const JoinGameResponse*>(
               &_JoinGameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(JoinGameResponse& a, JoinGameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinGameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinGameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinGameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinGameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinGameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinGameResponse& from) {
    JoinGameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinGameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.JoinGameResponse";
  }
  protected:
  explicit JoinGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameStateFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // .game.GameState game_state = 1;
  bool has_game_state() const;
  private:
  bool _internal_has_game_state() const;
  public:
  void clear_game_state();
  const ::game::GameState& game_state() const;
  PROTOBUF_NODISCARD ::game::GameState* release_game_state();
  ::game::GameState* mutable_game_state();
  void set_allocated_game_state(::game::GameState* game_state);
  private:
  const ::game::GameState& _internal_game_state() const;
  ::game::GameState* _internal_mutable_game_state();
  public:
  void unsafe_arena_set_allocated_game_state(
      ::game::GameState* game_state);
  ::game::GameState* unsafe_arena_release_game_state();

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  // @@protoc_insertion_point(class_scope:game.JoinGameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::game::GameState* game_state_;
    ::game::ErrorMessage* msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class JoinGameAsOwnerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.JoinGameAsOwnerRequest) */ {
 public:
  inline JoinGameAsOwnerRequest() : JoinGameAsOwnerRequest(nullptr) {}
  ~JoinGameAsOwnerRequest() override;
  explicit PROTOBUF_CONSTEXPR JoinGameAsOwnerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinGameAsOwnerRequest(const JoinGameAsOwnerRequest& from);
  JoinGameAsOwnerRequest(JoinGameAsOwnerRequest&& from) noexcept
    : JoinGameAsOwnerRequest() {
    *this = ::std::move(from);
  }

  inline JoinGameAsOwnerRequest& operator=(const JoinGameAsOwnerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinGameAsOwnerRequest& operator=(JoinGameAsOwnerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinGameAsOwnerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinGameAsOwnerRequest* internal_default_instance() {
    return reinterpret_cast<const JoinGameAsOwnerRequest*>(
               &_JoinGameAsOwnerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(JoinGameAsOwnerRequest& a, JoinGameAsOwnerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinGameAsOwnerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinGameAsOwnerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinGameAsOwnerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinGameAsOwnerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinGameAsOwnerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinGameAsOwnerRequest& from) {
    JoinGameAsOwnerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinGameAsOwnerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.JoinGameAsOwnerRequest";
  }
  protected:
  explicit JoinGameAsOwnerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 2,
    kPlayerInfoFieldNumber = 3,
    kGameIdFieldNumber = 1,
  };
  // string player_name = 2;
  void clear_player_name();
  const std::string& player_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // .game.PlayerInfo player_info = 3;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::game::PlayerInfo& player_info() const;
  PROTOBUF_NODISCARD ::game::PlayerInfo* release_player_info();
  ::game::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::game::PlayerInfo* player_info);
  private:
  const ::game::PlayerInfo& _internal_player_info() const;
  ::game::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::game::PlayerInfo* player_info);
  ::game::PlayerInfo* unsafe_arena_release_player_info();

  // uint32 game_id = 1;
  void clear_game_id();
  uint32_t game_id() const;
  void set_game_id(uint32_t value);
  private:
  uint32_t _internal_game_id() const;
  void _internal_set_game_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.JoinGameAsOwnerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
    ::game::PlayerInfo* player_info_;
    uint32_t game_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class JoinGameAsOwnerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.JoinGameAsOwnerResponse) */ {
 public:
  inline JoinGameAsOwnerResponse() : JoinGameAsOwnerResponse(nullptr) {}
  ~JoinGameAsOwnerResponse() override;
  explicit PROTOBUF_CONSTEXPR JoinGameAsOwnerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinGameAsOwnerResponse(const JoinGameAsOwnerResponse& from);
  JoinGameAsOwnerResponse(JoinGameAsOwnerResponse&& from) noexcept
    : JoinGameAsOwnerResponse() {
    *this = ::std::move(from);
  }

  inline JoinGameAsOwnerResponse& operator=(const JoinGameAsOwnerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinGameAsOwnerResponse& operator=(JoinGameAsOwnerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinGameAsOwnerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinGameAsOwnerResponse* internal_default_instance() {
    return reinterpret_cast<const JoinGameAsOwnerResponse*>(
               &_JoinGameAsOwnerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(JoinGameAsOwnerResponse& a, JoinGameAsOwnerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinGameAsOwnerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinGameAsOwnerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinGameAsOwnerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinGameAsOwnerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinGameAsOwnerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinGameAsOwnerResponse& from) {
    JoinGameAsOwnerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinGameAsOwnerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.JoinGameAsOwnerResponse";
  }
  protected:
  explicit JoinGameAsOwnerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameStateFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // .game.GameState game_state = 1;
  bool has_game_state() const;
  private:
  bool _internal_has_game_state() const;
  public:
  void clear_game_state();
  const ::game::GameState& game_state() const;
  PROTOBUF_NODISCARD ::game::GameState* release_game_state();
  ::game::GameState* mutable_game_state();
  void set_allocated_game_state(::game::GameState* game_state);
  private:
  const ::game::GameState& _internal_game_state() const;
  ::game::GameState* _internal_mutable_game_state();
  public:
  void unsafe_arena_set_allocated_game_state(
      ::game::GameState* game_state);
  ::game::GameState* unsafe_arena_release_game_state();

  // .game.ErrorMessage msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const ::game::ErrorMessage& msg() const;
  PROTOBUF_NODISCARD ::game::ErrorMessage* release_msg();
  ::game::ErrorMessage* mutable_msg();
  void set_allocated_msg(::game::ErrorMessage* msg);
  private:
  const ::game::ErrorMessage& _internal_msg() const;
  ::game::ErrorMessage* _internal_mutable_msg();
  public:
  void unsafe_arena_set_allocated_msg(
      ::game::ErrorMessage* msg);
  ::game::ErrorMessage* unsafe_arena_release_msg();

  // @@protoc_insertion_point(class_scope:game.JoinGameAsOwnerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::game::GameState* game_state_;
    ::game::ErrorMessage* msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.GameState) */ {
 public:
  inline GameState() : GameState(nullptr) {}
  ~GameState() override;
  explicit PROTOBUF_CONSTEXPR GameState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameState(const GameState& from);
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState& operator=(GameState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameState& from) {
    GameState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.GameState";
  }
  protected:
  explicit GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerCardsFieldNumber = 1,
    kBoardCardsFieldNumber = 2,
    kPlayersFieldNumber = 3,
  };
  // repeated .game.Card player_cards = 1;
  int player_cards_size() const;
  private:
  int _internal_player_cards_size() const;
  public:
  void clear_player_cards();
  ::game::Card* mutable_player_cards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card >*
      mutable_player_cards();
  private:
  const ::game::Card& _internal_player_cards(int index) const;
  ::game::Card* _internal_add_player_cards();
  public:
  const ::game::Card& player_cards(int index) const;
  ::game::Card* add_player_cards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card >&
      player_cards() const;

  // repeated .game.Card board_cards = 2;
  int board_cards_size() const;
  private:
  int _internal_board_cards_size() const;
  public:
  void clear_board_cards();
  ::game::Card* mutable_board_cards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card >*
      mutable_board_cards();
  private:
  const ::game::Card& _internal_board_cards(int index) const;
  ::game::Card* _internal_add_board_cards();
  public:
  const ::game::Card& board_cards(int index) const;
  ::game::Card* add_board_cards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card >&
      board_cards() const;

  // repeated .game.Player players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::game::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >*
      mutable_players();
  private:
  const ::game::Player& _internal_players(int index) const;
  ::game::Player* _internal_add_players();
  public:
  const ::game::Player& players(int index) const;
  ::game::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >&
      players() const;

  // @@protoc_insertion_point(class_scope:game.GameState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card > player_cards_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card > board_cards_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player > players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MakeMoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.MakeMoveRequest) */ {
 public:
  inline MakeMoveRequest() : MakeMoveRequest(nullptr) {}
  ~MakeMoveRequest() override;
  explicit PROTOBUF_CONSTEXPR MakeMoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MakeMoveRequest(const MakeMoveRequest& from);
  MakeMoveRequest(MakeMoveRequest&& from) noexcept
    : MakeMoveRequest() {
    *this = ::std::move(from);
  }

  inline MakeMoveRequest& operator=(const MakeMoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeMoveRequest& operator=(MakeMoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeMoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeMoveRequest* internal_default_instance() {
    return reinterpret_cast<const MakeMoveRequest*>(
               &_MakeMoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MakeMoveRequest& a, MakeMoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MakeMoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeMoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeMoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MakeMoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MakeMoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MakeMoveRequest& from) {
    MakeMoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MakeMoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.MakeMoveRequest";
  }
  protected:
  explicit MakeMoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kMoveTypeFieldNumber = 2,
    kBlindSizeFieldNumber = 3,
  };
  // uint32 player_id = 1;
  void clear_player_id();
  uint32_t player_id() const;
  void set_player_id(uint32_t value);
  private:
  uint32_t _internal_player_id() const;
  void _internal_set_player_id(uint32_t value);
  public:

  // .game.MoveType move_type = 2;
  void clear_move_type();
  ::game::MoveType move_type() const;
  void set_move_type(::game::MoveType value);
  private:
  ::game::MoveType _internal_move_type() const;
  void _internal_set_move_type(::game::MoveType value);
  public:

  // optional uint32 blind_size = 3;
  bool has_blind_size() const;
  private:
  bool _internal_has_blind_size() const;
  public:
  void clear_blind_size();
  uint32_t blind_size() const;
  void set_blind_size(uint32_t value);
  private:
  uint32_t _internal_blind_size() const;
  void _internal_set_blind_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.MakeMoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t player_id_;
    int move_type_;
    uint32_t blind_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MakeMoveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:game.MakeMoveResponse) */ {
 public:
  inline MakeMoveResponse() : MakeMoveResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MakeMoveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MakeMoveResponse(const MakeMoveResponse& from);
  MakeMoveResponse(MakeMoveResponse&& from) noexcept
    : MakeMoveResponse() {
    *this = ::std::move(from);
  }

  inline MakeMoveResponse& operator=(const MakeMoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MakeMoveResponse& operator=(MakeMoveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MakeMoveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MakeMoveResponse* internal_default_instance() {
    return reinterpret_cast<const MakeMoveResponse*>(
               &_MakeMoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(MakeMoveResponse& a, MakeMoveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MakeMoveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MakeMoveResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MakeMoveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MakeMoveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MakeMoveResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MakeMoveResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.MakeMoveResponse";
  }
  protected:
  explicit MakeMoveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:game.MakeMoveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Card final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Card) */ {
 public:
  inline Card() : Card(nullptr) {}
  ~Card() override;
  explicit PROTOBUF_CONSTEXPR Card(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Card(const Card& from);
  Card(Card&& from) noexcept
    : Card() {
    *this = ::std::move(from);
  }

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }
  inline Card& operator=(Card&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Card& default_instance() {
    return *internal_default_instance();
  }
  static inline const Card* internal_default_instance() {
    return reinterpret_cast<const Card*>(
               &_Card_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Card& a, Card& b) {
    a.Swap(&b);
  }
  inline void Swap(Card* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Card* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Card* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Card>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Card& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Card& from) {
    Card::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Card* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Card";
  }
  protected:
  explicit Card(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuitFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .game.Suits suit = 1;
  void clear_suit();
  ::game::Suits suit() const;
  void set_suit(::game::Suits value);
  private:
  ::game::Suits _internal_suit() const;
  void _internal_set_suit(::game::Suits value);
  public:

  // .game.Values value = 2;
  void clear_value();
  ::game::Values value() const;
  void set_value(::game::Values value);
  private:
  ::game::Values _internal_value() const;
  void _internal_set_value(::game::Values value);
  public:

  // @@protoc_insertion_point(class_scope:game.Card)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int suit_;
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ErrorMessage

// .game.error error = 1;
inline void ErrorMessage::clear_error() {
  _impl_.error_ = 0;
}
inline ::game::error ErrorMessage::_internal_error() const {
  return static_cast< ::game::error >(_impl_.error_);
}
inline ::game::error ErrorMessage::error() const {
  // @@protoc_insertion_point(field_get:game.ErrorMessage.error)
  return _internal_error();
}
inline void ErrorMessage::_internal_set_error(::game::error value) {
  
  _impl_.error_ = value;
}
inline void ErrorMessage::set_error(::game::error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:game.ErrorMessage.error)
}

// optional string message_string = 2;
inline bool ErrorMessage::_internal_has_message_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErrorMessage::has_message_string() const {
  return _internal_has_message_string();
}
inline void ErrorMessage::clear_message_string() {
  _impl_.message_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorMessage::message_string() const {
  // @@protoc_insertion_point(field_get:game.ErrorMessage.message_string)
  return _internal_message_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorMessage::set_message_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.ErrorMessage.message_string)
}
inline std::string* ErrorMessage::mutable_message_string() {
  std::string* _s = _internal_mutable_message_string();
  // @@protoc_insertion_point(field_mutable:game.ErrorMessage.message_string)
  return _s;
}
inline const std::string& ErrorMessage::_internal_message_string() const {
  return _impl_.message_string_.Get();
}
inline void ErrorMessage::_internal_set_message_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorMessage::_internal_mutable_message_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_string_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorMessage::release_message_string() {
  // @@protoc_insertion_point(field_release:game.ErrorMessage.message_string)
  if (!_internal_has_message_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_string_.IsDefault()) {
    _impl_.message_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ErrorMessage::set_allocated_message_string(std::string* message_string) {
  if (message_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_string_.SetAllocated(message_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_string_.IsDefault()) {
    _impl_.message_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.ErrorMessage.message_string)
}

// -------------------------------------------------------------------

// LoginRequest

// .game.LoginRequestFirst login_request_first = 1;
inline bool LoginRequest::_internal_has_login_request_first() const {
  return login_requests_case() == kLoginRequestFirst;
}
inline bool LoginRequest::has_login_request_first() const {
  return _internal_has_login_request_first();
}
inline void LoginRequest::set_has_login_request_first() {
  _impl_._oneof_case_[0] = kLoginRequestFirst;
}
inline void LoginRequest::clear_login_request_first() {
  if (_internal_has_login_request_first()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_requests_.login_request_first_;
    }
    clear_has_login_requests();
  }
}
inline ::game::LoginRequestFirst* LoginRequest::release_login_request_first() {
  // @@protoc_insertion_point(field_release:game.LoginRequest.login_request_first)
  if (_internal_has_login_request_first()) {
    clear_has_login_requests();
    ::game::LoginRequestFirst* temp = _impl_.login_requests_.login_request_first_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_requests_.login_request_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginRequestFirst& LoginRequest::_internal_login_request_first() const {
  return _internal_has_login_request_first()
      ? *_impl_.login_requests_.login_request_first_
      : reinterpret_cast< ::game::LoginRequestFirst&>(::game::_LoginRequestFirst_default_instance_);
}
inline const ::game::LoginRequestFirst& LoginRequest::login_request_first() const {
  // @@protoc_insertion_point(field_get:game.LoginRequest.login_request_first)
  return _internal_login_request_first();
}
inline ::game::LoginRequestFirst* LoginRequest::unsafe_arena_release_login_request_first() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginRequest.login_request_first)
  if (_internal_has_login_request_first()) {
    clear_has_login_requests();
    ::game::LoginRequestFirst* temp = _impl_.login_requests_.login_request_first_;
    _impl_.login_requests_.login_request_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginRequest::unsafe_arena_set_allocated_login_request_first(::game::LoginRequestFirst* login_request_first) {
  clear_login_requests();
  if (login_request_first) {
    set_has_login_request_first();
    _impl_.login_requests_.login_request_first_ = login_request_first;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginRequest.login_request_first)
}
inline ::game::LoginRequestFirst* LoginRequest::_internal_mutable_login_request_first() {
  if (!_internal_has_login_request_first()) {
    clear_login_requests();
    set_has_login_request_first();
    _impl_.login_requests_.login_request_first_ = CreateMaybeMessage< ::game::LoginRequestFirst >(GetArenaForAllocation());
  }
  return _impl_.login_requests_.login_request_first_;
}
inline ::game::LoginRequestFirst* LoginRequest::mutable_login_request_first() {
  ::game::LoginRequestFirst* _msg = _internal_mutable_login_request_first();
  // @@protoc_insertion_point(field_mutable:game.LoginRequest.login_request_first)
  return _msg;
}

// .game.LoginRequestSecond login_request_second = 2;
inline bool LoginRequest::_internal_has_login_request_second() const {
  return login_requests_case() == kLoginRequestSecond;
}
inline bool LoginRequest::has_login_request_second() const {
  return _internal_has_login_request_second();
}
inline void LoginRequest::set_has_login_request_second() {
  _impl_._oneof_case_[0] = kLoginRequestSecond;
}
inline void LoginRequest::clear_login_request_second() {
  if (_internal_has_login_request_second()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_requests_.login_request_second_;
    }
    clear_has_login_requests();
  }
}
inline ::game::LoginRequestSecond* LoginRequest::release_login_request_second() {
  // @@protoc_insertion_point(field_release:game.LoginRequest.login_request_second)
  if (_internal_has_login_request_second()) {
    clear_has_login_requests();
    ::game::LoginRequestSecond* temp = _impl_.login_requests_.login_request_second_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_requests_.login_request_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginRequestSecond& LoginRequest::_internal_login_request_second() const {
  return _internal_has_login_request_second()
      ? *_impl_.login_requests_.login_request_second_
      : reinterpret_cast< ::game::LoginRequestSecond&>(::game::_LoginRequestSecond_default_instance_);
}
inline const ::game::LoginRequestSecond& LoginRequest::login_request_second() const {
  // @@protoc_insertion_point(field_get:game.LoginRequest.login_request_second)
  return _internal_login_request_second();
}
inline ::game::LoginRequestSecond* LoginRequest::unsafe_arena_release_login_request_second() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginRequest.login_request_second)
  if (_internal_has_login_request_second()) {
    clear_has_login_requests();
    ::game::LoginRequestSecond* temp = _impl_.login_requests_.login_request_second_;
    _impl_.login_requests_.login_request_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginRequest::unsafe_arena_set_allocated_login_request_second(::game::LoginRequestSecond* login_request_second) {
  clear_login_requests();
  if (login_request_second) {
    set_has_login_request_second();
    _impl_.login_requests_.login_request_second_ = login_request_second;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginRequest.login_request_second)
}
inline ::game::LoginRequestSecond* LoginRequest::_internal_mutable_login_request_second() {
  if (!_internal_has_login_request_second()) {
    clear_login_requests();
    set_has_login_request_second();
    _impl_.login_requests_.login_request_second_ = CreateMaybeMessage< ::game::LoginRequestSecond >(GetArenaForAllocation());
  }
  return _impl_.login_requests_.login_request_second_;
}
inline ::game::LoginRequestSecond* LoginRequest::mutable_login_request_second() {
  ::game::LoginRequestSecond* _msg = _internal_mutable_login_request_second();
  // @@protoc_insertion_point(field_mutable:game.LoginRequest.login_request_second)
  return _msg;
}

inline bool LoginRequest::has_login_requests() const {
  return login_requests_case() != LOGIN_REQUESTS_NOT_SET;
}
inline void LoginRequest::clear_has_login_requests() {
  _impl_._oneof_case_[0] = LOGIN_REQUESTS_NOT_SET;
}
inline LoginRequest::LoginRequestsCase LoginRequest::login_requests_case() const {
  return LoginRequest::LoginRequestsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginResponse

// .game.LoginResponseFirst login_response_first = 1;
inline bool LoginResponse::_internal_has_login_response_first() const {
  return login_responses_case() == kLoginResponseFirst;
}
inline bool LoginResponse::has_login_response_first() const {
  return _internal_has_login_response_first();
}
inline void LoginResponse::set_has_login_response_first() {
  _impl_._oneof_case_[0] = kLoginResponseFirst;
}
inline void LoginResponse::clear_login_response_first() {
  if (_internal_has_login_response_first()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_.login_response_first_;
    }
    clear_has_login_responses();
  }
}
inline ::game::LoginResponseFirst* LoginResponse::release_login_response_first() {
  // @@protoc_insertion_point(field_release:game.LoginResponse.login_response_first)
  if (_internal_has_login_response_first()) {
    clear_has_login_responses();
    ::game::LoginResponseFirst* temp = _impl_.login_responses_.login_response_first_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_.login_response_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginResponseFirst& LoginResponse::_internal_login_response_first() const {
  return _internal_has_login_response_first()
      ? *_impl_.login_responses_.login_response_first_
      : reinterpret_cast< ::game::LoginResponseFirst&>(::game::_LoginResponseFirst_default_instance_);
}
inline const ::game::LoginResponseFirst& LoginResponse::login_response_first() const {
  // @@protoc_insertion_point(field_get:game.LoginResponse.login_response_first)
  return _internal_login_response_first();
}
inline ::game::LoginResponseFirst* LoginResponse::unsafe_arena_release_login_response_first() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponse.login_response_first)
  if (_internal_has_login_response_first()) {
    clear_has_login_responses();
    ::game::LoginResponseFirst* temp = _impl_.login_responses_.login_response_first_;
    _impl_.login_responses_.login_response_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponse::unsafe_arena_set_allocated_login_response_first(::game::LoginResponseFirst* login_response_first) {
  clear_login_responses();
  if (login_response_first) {
    set_has_login_response_first();
    _impl_.login_responses_.login_response_first_ = login_response_first;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponse.login_response_first)
}
inline ::game::LoginResponseFirst* LoginResponse::_internal_mutable_login_response_first() {
  if (!_internal_has_login_response_first()) {
    clear_login_responses();
    set_has_login_response_first();
    _impl_.login_responses_.login_response_first_ = CreateMaybeMessage< ::game::LoginResponseFirst >(GetArenaForAllocation());
  }
  return _impl_.login_responses_.login_response_first_;
}
inline ::game::LoginResponseFirst* LoginResponse::mutable_login_response_first() {
  ::game::LoginResponseFirst* _msg = _internal_mutable_login_response_first();
  // @@protoc_insertion_point(field_mutable:game.LoginResponse.login_response_first)
  return _msg;
}

// .game.LoginResponseSecond login_response_second = 2;
inline bool LoginResponse::_internal_has_login_response_second() const {
  return login_responses_case() == kLoginResponseSecond;
}
inline bool LoginResponse::has_login_response_second() const {
  return _internal_has_login_response_second();
}
inline void LoginResponse::set_has_login_response_second() {
  _impl_._oneof_case_[0] = kLoginResponseSecond;
}
inline void LoginResponse::clear_login_response_second() {
  if (_internal_has_login_response_second()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_.login_response_second_;
    }
    clear_has_login_responses();
  }
}
inline ::game::LoginResponseSecond* LoginResponse::release_login_response_second() {
  // @@protoc_insertion_point(field_release:game.LoginResponse.login_response_second)
  if (_internal_has_login_response_second()) {
    clear_has_login_responses();
    ::game::LoginResponseSecond* temp = _impl_.login_responses_.login_response_second_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_.login_response_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginResponseSecond& LoginResponse::_internal_login_response_second() const {
  return _internal_has_login_response_second()
      ? *_impl_.login_responses_.login_response_second_
      : reinterpret_cast< ::game::LoginResponseSecond&>(::game::_LoginResponseSecond_default_instance_);
}
inline const ::game::LoginResponseSecond& LoginResponse::login_response_second() const {
  // @@protoc_insertion_point(field_get:game.LoginResponse.login_response_second)
  return _internal_login_response_second();
}
inline ::game::LoginResponseSecond* LoginResponse::unsafe_arena_release_login_response_second() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponse.login_response_second)
  if (_internal_has_login_response_second()) {
    clear_has_login_responses();
    ::game::LoginResponseSecond* temp = _impl_.login_responses_.login_response_second_;
    _impl_.login_responses_.login_response_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponse::unsafe_arena_set_allocated_login_response_second(::game::LoginResponseSecond* login_response_second) {
  clear_login_responses();
  if (login_response_second) {
    set_has_login_response_second();
    _impl_.login_responses_.login_response_second_ = login_response_second;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponse.login_response_second)
}
inline ::game::LoginResponseSecond* LoginResponse::_internal_mutable_login_response_second() {
  if (!_internal_has_login_response_second()) {
    clear_login_responses();
    set_has_login_response_second();
    _impl_.login_responses_.login_response_second_ = CreateMaybeMessage< ::game::LoginResponseSecond >(GetArenaForAllocation());
  }
  return _impl_.login_responses_.login_response_second_;
}
inline ::game::LoginResponseSecond* LoginResponse::mutable_login_response_second() {
  ::game::LoginResponseSecond* _msg = _internal_mutable_login_response_second();
  // @@protoc_insertion_point(field_mutable:game.LoginResponse.login_response_second)
  return _msg;
}

inline bool LoginResponse::has_login_responses() const {
  return login_responses_case() != LOGIN_RESPONSES_NOT_SET;
}
inline void LoginResponse::clear_has_login_responses() {
  _impl_._oneof_case_[0] = LOGIN_RESPONSES_NOT_SET;
}
inline LoginResponse::LoginResponsesCase LoginResponse::login_responses_case() const {
  return LoginResponse::LoginResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginRequestFirst

// string name = 1;
inline void LoginRequestFirst::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LoginRequestFirst::name() const {
  // @@protoc_insertion_point(field_get:game.LoginRequestFirst.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequestFirst::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.LoginRequestFirst.name)
}
inline std::string* LoginRequestFirst::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.LoginRequestFirst.name)
  return _s;
}
inline const std::string& LoginRequestFirst::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LoginRequestFirst::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequestFirst::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequestFirst::release_name() {
  // @@protoc_insertion_point(field_release:game.LoginRequestFirst.name)
  return _impl_.name_.Release();
}
inline void LoginRequestFirst::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequestFirst.name)
}

// -------------------------------------------------------------------

// LoginRequestSecond

// string name = 1;
inline void LoginRequestSecond::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LoginRequestSecond::name() const {
  // @@protoc_insertion_point(field_get:game.LoginRequestSecond.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequestSecond::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.LoginRequestSecond.name)
}
inline std::string* LoginRequestSecond::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.LoginRequestSecond.name)
  return _s;
}
inline const std::string& LoginRequestSecond::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LoginRequestSecond::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequestSecond::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequestSecond::release_name() {
  // @@protoc_insertion_point(field_release:game.LoginRequestSecond.name)
  return _impl_.name_.Release();
}
inline void LoginRequestSecond::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequestSecond.name)
}

// string hashed = 2;
inline void LoginRequestSecond::clear_hashed() {
  _impl_.hashed_.ClearToEmpty();
}
inline const std::string& LoginRequestSecond::hashed() const {
  // @@protoc_insertion_point(field_get:game.LoginRequestSecond.hashed)
  return _internal_hashed();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequestSecond::set_hashed(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hashed_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.LoginRequestSecond.hashed)
}
inline std::string* LoginRequestSecond::mutable_hashed() {
  std::string* _s = _internal_mutable_hashed();
  // @@protoc_insertion_point(field_mutable:game.LoginRequestSecond.hashed)
  return _s;
}
inline const std::string& LoginRequestSecond::_internal_hashed() const {
  return _impl_.hashed_.Get();
}
inline void LoginRequestSecond::_internal_set_hashed(const std::string& value) {
  
  _impl_.hashed_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequestSecond::_internal_mutable_hashed() {
  
  return _impl_.hashed_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequestSecond::release_hashed() {
  // @@protoc_insertion_point(field_release:game.LoginRequestSecond.hashed)
  return _impl_.hashed_.Release();
}
inline void LoginRequestSecond::set_allocated_hashed(std::string* hashed) {
  if (hashed != nullptr) {
    
  } else {
    
  }
  _impl_.hashed_.SetAllocated(hashed, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hashed_.IsDefault()) {
    _impl_.hashed_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequestSecond.hashed)
}

// -------------------------------------------------------------------

// LoginResponseFirst

// string salt = 1;
inline bool LoginResponseFirst::_internal_has_salt() const {
  return login_responses_first_case() == kSalt;
}
inline bool LoginResponseFirst::has_salt() const {
  return _internal_has_salt();
}
inline void LoginResponseFirst::set_has_salt() {
  _impl_._oneof_case_[0] = kSalt;
}
inline void LoginResponseFirst::clear_salt() {
  if (_internal_has_salt()) {
    _impl_.login_responses_first_.salt_.Destroy();
    clear_has_login_responses_first();
  }
}
inline const std::string& LoginResponseFirst::salt() const {
  // @@protoc_insertion_point(field_get:game.LoginResponseFirst.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline void LoginResponseFirst::set_salt(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_salt()) {
    clear_login_responses_first();
    set_has_salt();
    _impl_.login_responses_first_.salt_.InitDefault();
  }
  _impl_.login_responses_first_.salt_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.LoginResponseFirst.salt)
}
inline std::string* LoginResponseFirst::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:game.LoginResponseFirst.salt)
  return _s;
}
inline const std::string& LoginResponseFirst::_internal_salt() const {
  if (_internal_has_salt()) {
    return _impl_.login_responses_first_.salt_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LoginResponseFirst::_internal_set_salt(const std::string& value) {
  if (!_internal_has_salt()) {
    clear_login_responses_first();
    set_has_salt();
    _impl_.login_responses_first_.salt_.InitDefault();
  }
  _impl_.login_responses_first_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponseFirst::_internal_mutable_salt() {
  if (!_internal_has_salt()) {
    clear_login_responses_first();
    set_has_salt();
    _impl_.login_responses_first_.salt_.InitDefault();
  }
  return _impl_.login_responses_first_.salt_.Mutable(      GetArenaForAllocation());
}
inline std::string* LoginResponseFirst::release_salt() {
  // @@protoc_insertion_point(field_release:game.LoginResponseFirst.salt)
  if (_internal_has_salt()) {
    clear_has_login_responses_first();
    return _impl_.login_responses_first_.salt_.Release();
  } else {
    return nullptr;
  }
}
inline void LoginResponseFirst::set_allocated_salt(std::string* salt) {
  if (has_login_responses_first()) {
    clear_login_responses_first();
  }
  if (salt != nullptr) {
    set_has_salt();
    _impl_.login_responses_first_.salt_.InitAllocated(salt, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:game.LoginResponseFirst.salt)
}

// .game.ErrorMessage msg = 2;
inline bool LoginResponseFirst::_internal_has_msg() const {
  return login_responses_first_case() == kMsg;
}
inline bool LoginResponseFirst::has_msg() const {
  return _internal_has_msg();
}
inline void LoginResponseFirst::set_has_msg() {
  _impl_._oneof_case_[0] = kMsg;
}
inline void LoginResponseFirst::clear_msg() {
  if (_internal_has_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_first_.msg_;
    }
    clear_has_login_responses_first();
  }
}
inline ::game::ErrorMessage* LoginResponseFirst::release_msg() {
  // @@protoc_insertion_point(field_release:game.LoginResponseFirst.msg)
  if (_internal_has_msg()) {
    clear_has_login_responses_first();
    ::game::ErrorMessage* temp = _impl_.login_responses_first_.msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_first_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ErrorMessage& LoginResponseFirst::_internal_msg() const {
  return _internal_has_msg()
      ? *_impl_.login_responses_first_.msg_
      : reinterpret_cast< ::game::ErrorMessage&>(::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& LoginResponseFirst::msg() const {
  // @@protoc_insertion_point(field_get:game.LoginResponseFirst.msg)
  return _internal_msg();
}
inline ::game::ErrorMessage* LoginResponseFirst::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponseFirst.msg)
  if (_internal_has_msg()) {
    clear_has_login_responses_first();
    ::game::ErrorMessage* temp = _impl_.login_responses_first_.msg_;
    _impl_.login_responses_first_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponseFirst::unsafe_arena_set_allocated_msg(::game::ErrorMessage* msg) {
  clear_login_responses_first();
  if (msg) {
    set_has_msg();
    _impl_.login_responses_first_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponseFirst.msg)
}
inline ::game::ErrorMessage* LoginResponseFirst::_internal_mutable_msg() {
  if (!_internal_has_msg()) {
    clear_login_responses_first();
    set_has_msg();
    _impl_.login_responses_first_.msg_ = CreateMaybeMessage< ::game::ErrorMessage >(GetArenaForAllocation());
  }
  return _impl_.login_responses_first_.msg_;
}
inline ::game::ErrorMessage* LoginResponseFirst::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.LoginResponseFirst.msg)
  return _msg;
}

inline bool LoginResponseFirst::has_login_responses_first() const {
  return login_responses_first_case() != LOGIN_RESPONSES_FIRST_NOT_SET;
}
inline void LoginResponseFirst::clear_has_login_responses_first() {
  _impl_._oneof_case_[0] = LOGIN_RESPONSES_FIRST_NOT_SET;
}
inline LoginResponseFirst::LoginResponsesFirstCase LoginResponseFirst::login_responses_first_case() const {
  return LoginResponseFirst::LoginResponsesFirstCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginResponseSecond

// .game.PlayerInfo player_info = 1;
inline bool LoginResponseSecond::_internal_has_player_info() const {
  return login_responses_second_case() == kPlayerInfo;
}
inline bool LoginResponseSecond::has_player_info() const {
  return _internal_has_player_info();
}
inline void LoginResponseSecond::set_has_player_info() {
  _impl_._oneof_case_[0] = kPlayerInfo;
}
inline void LoginResponseSecond::clear_player_info() {
  if (_internal_has_player_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_second_.player_info_;
    }
    clear_has_login_responses_second();
  }
}
inline ::game::PlayerInfo* LoginResponseSecond::release_player_info() {
  // @@protoc_insertion_point(field_release:game.LoginResponseSecond.player_info)
  if (_internal_has_player_info()) {
    clear_has_login_responses_second();
    ::game::PlayerInfo* temp = _impl_.login_responses_second_.player_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_second_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::PlayerInfo& LoginResponseSecond::_internal_player_info() const {
  return _internal_has_player_info()
      ? *_impl_.login_responses_second_.player_info_
      : reinterpret_cast< ::game::PlayerInfo&>(::game::_PlayerInfo_default_instance_);
}
inline const ::game::PlayerInfo& LoginResponseSecond::player_info() const {
  // @@protoc_insertion_point(field_get:game.LoginResponseSecond.player_info)
  return _internal_player_info();
}
inline ::game::PlayerInfo* LoginResponseSecond::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponseSecond.player_info)
  if (_internal_has_player_info()) {
    clear_has_login_responses_second();
    ::game::PlayerInfo* temp = _impl_.login_responses_second_.player_info_;
    _impl_.login_responses_second_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponseSecond::unsafe_arena_set_allocated_player_info(::game::PlayerInfo* player_info) {
  clear_login_responses_second();
  if (player_info) {
    set_has_player_info();
    _impl_.login_responses_second_.player_info_ = player_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponseSecond.player_info)
}
inline ::game::PlayerInfo* LoginResponseSecond::_internal_mutable_player_info() {
  if (!_internal_has_player_info()) {
    clear_login_responses_second();
    set_has_player_info();
    _impl_.login_responses_second_.player_info_ = CreateMaybeMessage< ::game::PlayerInfo >(GetArenaForAllocation());
  }
  return _impl_.login_responses_second_.player_info_;
}
inline ::game::PlayerInfo* LoginResponseSecond::mutable_player_info() {
  ::game::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:game.LoginResponseSecond.player_info)
  return _msg;
}

// .game.ErrorMessage msg = 2;
inline bool LoginResponseSecond::_internal_has_msg() const {
  return login_responses_second_case() == kMsg;
}
inline bool LoginResponseSecond::has_msg() const {
  return _internal_has_msg();
}
inline void LoginResponseSecond::set_has_msg() {
  _impl_._oneof_case_[0] = kMsg;
}
inline void LoginResponseSecond::clear_msg() {
  if (_internal_has_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.login_responses_second_.msg_;
    }
    clear_has_login_responses_second();
  }
}
inline ::game::ErrorMessage* LoginResponseSecond::release_msg() {
  // @@protoc_insertion_point(field_release:game.LoginResponseSecond.msg)
  if (_internal_has_msg()) {
    clear_has_login_responses_second();
    ::game::ErrorMessage* temp = _impl_.login_responses_second_.msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.login_responses_second_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ErrorMessage& LoginResponseSecond::_internal_msg() const {
  return _internal_has_msg()
      ? *_impl_.login_responses_second_.msg_
      : reinterpret_cast< ::game::ErrorMessage&>(::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& LoginResponseSecond::msg() const {
  // @@protoc_insertion_point(field_get:game.LoginResponseSecond.msg)
  return _internal_msg();
}
inline ::game::ErrorMessage* LoginResponseSecond::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LoginResponseSecond.msg)
  if (_internal_has_msg()) {
    clear_has_login_responses_second();
    ::game::ErrorMessage* temp = _impl_.login_responses_second_.msg_;
    _impl_.login_responses_second_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponseSecond::unsafe_arena_set_allocated_msg(::game::ErrorMessage* msg) {
  clear_login_responses_second();
  if (msg) {
    set_has_msg();
    _impl_.login_responses_second_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponseSecond.msg)
}
inline ::game::ErrorMessage* LoginResponseSecond::_internal_mutable_msg() {
  if (!_internal_has_msg()) {
    clear_login_responses_second();
    set_has_msg();
    _impl_.login_responses_second_.msg_ = CreateMaybeMessage< ::game::ErrorMessage >(GetArenaForAllocation());
  }
  return _impl_.login_responses_second_.msg_;
}
inline ::game::ErrorMessage* LoginResponseSecond::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.LoginResponseSecond.msg)
  return _msg;
}

inline bool LoginResponseSecond::has_login_responses_second() const {
  return login_responses_second_case() != LOGIN_RESPONSES_SECOND_NOT_SET;
}
inline void LoginResponseSecond::clear_has_login_responses_second() {
  _impl_._oneof_case_[0] = LOGIN_RESPONSES_SECOND_NOT_SET;
}
inline LoginResponseSecond::LoginResponsesSecondCase LoginResponseSecond::login_responses_second_case() const {
  return LoginResponseSecond::LoginResponsesSecondCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegisterRequest

// string name = 1;
inline void RegisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RegisterRequest::name() const {
  // @@protoc_insertion_point(field_get:game.RegisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.RegisterRequest.name)
}
inline std::string* RegisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.RegisterRequest.name)
  return _s;
}
inline const std::string& RegisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RegisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:game.RegisterRequest.name)
  return _impl_.name_.Release();
}
inline void RegisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.RegisterRequest.name)
}

// .game.SaltHash salt_hash = 2;
inline bool RegisterRequest::_internal_has_salt_hash() const {
  return this != internal_default_instance() && _impl_.salt_hash_ != nullptr;
}
inline bool RegisterRequest::has_salt_hash() const {
  return _internal_has_salt_hash();
}
inline void RegisterRequest::clear_salt_hash() {
  if (GetArenaForAllocation() == nullptr && _impl_.salt_hash_ != nullptr) {
    delete _impl_.salt_hash_;
  }
  _impl_.salt_hash_ = nullptr;
}
inline const ::game::SaltHash& RegisterRequest::_internal_salt_hash() const {
  const ::game::SaltHash* p = _impl_.salt_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::SaltHash&>(
      ::game::_SaltHash_default_instance_);
}
inline const ::game::SaltHash& RegisterRequest::salt_hash() const {
  // @@protoc_insertion_point(field_get:game.RegisterRequest.salt_hash)
  return _internal_salt_hash();
}
inline void RegisterRequest::unsafe_arena_set_allocated_salt_hash(
    ::game::SaltHash* salt_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.salt_hash_);
  }
  _impl_.salt_hash_ = salt_hash;
  if (salt_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.RegisterRequest.salt_hash)
}
inline ::game::SaltHash* RegisterRequest::release_salt_hash() {
  
  ::game::SaltHash* temp = _impl_.salt_hash_;
  _impl_.salt_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::SaltHash* RegisterRequest::unsafe_arena_release_salt_hash() {
  // @@protoc_insertion_point(field_release:game.RegisterRequest.salt_hash)
  
  ::game::SaltHash* temp = _impl_.salt_hash_;
  _impl_.salt_hash_ = nullptr;
  return temp;
}
inline ::game::SaltHash* RegisterRequest::_internal_mutable_salt_hash() {
  
  if (_impl_.salt_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::SaltHash>(GetArenaForAllocation());
    _impl_.salt_hash_ = p;
  }
  return _impl_.salt_hash_;
}
inline ::game::SaltHash* RegisterRequest::mutable_salt_hash() {
  ::game::SaltHash* _msg = _internal_mutable_salt_hash();
  // @@protoc_insertion_point(field_mutable:game.RegisterRequest.salt_hash)
  return _msg;
}
inline void RegisterRequest::set_allocated_salt_hash(::game::SaltHash* salt_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.salt_hash_;
  }
  if (salt_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(salt_hash);
    if (message_arena != submessage_arena) {
      salt_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, salt_hash, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.salt_hash_ = salt_hash;
  // @@protoc_insertion_point(field_set_allocated:game.RegisterRequest.salt_hash)
}

// -------------------------------------------------------------------

// RegisterResponse

// .game.PlayerInfo player_info = 1;
inline bool RegisterResponse::_internal_has_player_info() const {
  return register_responses_case() == kPlayerInfo;
}
inline bool RegisterResponse::has_player_info() const {
  return _internal_has_player_info();
}
inline void RegisterResponse::set_has_player_info() {
  _impl_._oneof_case_[0] = kPlayerInfo;
}
inline void RegisterResponse::clear_player_info() {
  if (_internal_has_player_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.register_responses_.player_info_;
    }
    clear_has_register_responses();
  }
}
inline ::game::PlayerInfo* RegisterResponse::release_player_info() {
  // @@protoc_insertion_point(field_release:game.RegisterResponse.player_info)
  if (_internal_has_player_info()) {
    clear_has_register_responses();
    ::game::PlayerInfo* temp = _impl_.register_responses_.player_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.register_responses_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::PlayerInfo& RegisterResponse::_internal_player_info() const {
  return _internal_has_player_info()
      ? *_impl_.register_responses_.player_info_
      : reinterpret_cast< ::game::PlayerInfo&>(::game::_PlayerInfo_default_instance_);
}
inline const ::game::PlayerInfo& RegisterResponse::player_info() const {
  // @@protoc_insertion_point(field_get:game.RegisterResponse.player_info)
  return _internal_player_info();
}
inline ::game::PlayerInfo* RegisterResponse::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.RegisterResponse.player_info)
  if (_internal_has_player_info()) {
    clear_has_register_responses();
    ::game::PlayerInfo* temp = _impl_.register_responses_.player_info_;
    _impl_.register_responses_.player_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegisterResponse::unsafe_arena_set_allocated_player_info(::game::PlayerInfo* player_info) {
  clear_register_responses();
  if (player_info) {
    set_has_player_info();
    _impl_.register_responses_.player_info_ = player_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.RegisterResponse.player_info)
}
inline ::game::PlayerInfo* RegisterResponse::_internal_mutable_player_info() {
  if (!_internal_has_player_info()) {
    clear_register_responses();
    set_has_player_info();
    _impl_.register_responses_.player_info_ = CreateMaybeMessage< ::game::PlayerInfo >(GetArenaForAllocation());
  }
  return _impl_.register_responses_.player_info_;
}
inline ::game::PlayerInfo* RegisterResponse::mutable_player_info() {
  ::game::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:game.RegisterResponse.player_info)
  return _msg;
}

// .game.ErrorMessage msg = 2;
inline bool RegisterResponse::_internal_has_msg() const {
  return register_responses_case() == kMsg;
}
inline bool RegisterResponse::has_msg() const {
  return _internal_has_msg();
}
inline void RegisterResponse::set_has_msg() {
  _impl_._oneof_case_[0] = kMsg;
}
inline void RegisterResponse::clear_msg() {
  if (_internal_has_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.register_responses_.msg_;
    }
    clear_has_register_responses();
  }
}
inline ::game::ErrorMessage* RegisterResponse::release_msg() {
  // @@protoc_insertion_point(field_release:game.RegisterResponse.msg)
  if (_internal_has_msg()) {
    clear_has_register_responses();
    ::game::ErrorMessage* temp = _impl_.register_responses_.msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.register_responses_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ErrorMessage& RegisterResponse::_internal_msg() const {
  return _internal_has_msg()
      ? *_impl_.register_responses_.msg_
      : reinterpret_cast< ::game::ErrorMessage&>(::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& RegisterResponse::msg() const {
  // @@protoc_insertion_point(field_get:game.RegisterResponse.msg)
  return _internal_msg();
}
inline ::game::ErrorMessage* RegisterResponse::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.RegisterResponse.msg)
  if (_internal_has_msg()) {
    clear_has_register_responses();
    ::game::ErrorMessage* temp = _impl_.register_responses_.msg_;
    _impl_.register_responses_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegisterResponse::unsafe_arena_set_allocated_msg(::game::ErrorMessage* msg) {
  clear_register_responses();
  if (msg) {
    set_has_msg();
    _impl_.register_responses_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.RegisterResponse.msg)
}
inline ::game::ErrorMessage* RegisterResponse::_internal_mutable_msg() {
  if (!_internal_has_msg()) {
    clear_register_responses();
    set_has_msg();
    _impl_.register_responses_.msg_ = CreateMaybeMessage< ::game::ErrorMessage >(GetArenaForAllocation());
  }
  return _impl_.register_responses_.msg_;
}
inline ::game::ErrorMessage* RegisterResponse::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.RegisterResponse.msg)
  return _msg;
}

inline bool RegisterResponse::has_register_responses() const {
  return register_responses_case() != REGISTER_RESPONSES_NOT_SET;
}
inline void RegisterResponse::clear_has_register_responses() {
  _impl_._oneof_case_[0] = REGISTER_RESPONSES_NOT_SET;
}
inline RegisterResponse::RegisterResponsesCase RegisterResponse::register_responses_case() const {
  return RegisterResponse::RegisterResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SaltHash

// string salt = 1;
inline void SaltHash::clear_salt() {
  _impl_.salt_.ClearToEmpty();
}
inline const std::string& SaltHash::salt() const {
  // @@protoc_insertion_point(field_get:game.SaltHash.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaltHash::set_salt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.salt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.SaltHash.salt)
}
inline std::string* SaltHash::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:game.SaltHash.salt)
  return _s;
}
inline const std::string& SaltHash::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void SaltHash::_internal_set_salt(const std::string& value) {
  
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* SaltHash::_internal_mutable_salt() {
  
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* SaltHash::release_salt() {
  // @@protoc_insertion_point(field_release:game.SaltHash.salt)
  return _impl_.salt_.Release();
}
inline void SaltHash::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    
  } else {
    
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.SaltHash.salt)
}

// string hash = 2;
inline void SaltHash::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& SaltHash::hash() const {
  // @@protoc_insertion_point(field_get:game.SaltHash.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaltHash::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.SaltHash.hash)
}
inline std::string* SaltHash::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:game.SaltHash.hash)
  return _s;
}
inline const std::string& SaltHash::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void SaltHash::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SaltHash::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SaltHash::release_hash() {
  // @@protoc_insertion_point(field_release:game.SaltHash.hash)
  return _impl_.hash_.Release();
}
inline void SaltHash::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.SaltHash.hash)
}

// -------------------------------------------------------------------

// Player

// string name = 1;
inline void Player::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:game.Player.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.Player.name)
}
inline std::string* Player::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.Player.name)
  return _s;
}
inline const std::string& Player::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Player::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:game.Player.name)
  return _impl_.name_.Release();
}
inline void Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.Player.name)
}

// .game.PlayerStatus status = 2;
inline void Player::clear_status() {
  _impl_.status_ = 0;
}
inline ::game::PlayerStatus Player::_internal_status() const {
  return static_cast< ::game::PlayerStatus >(_impl_.status_);
}
inline ::game::PlayerStatus Player::status() const {
  // @@protoc_insertion_point(field_get:game.Player.status)
  return _internal_status();
}
inline void Player::_internal_set_status(::game::PlayerStatus value) {
  
  _impl_.status_ = value;
}
inline void Player::set_status(::game::PlayerStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:game.Player.status)
}

// uint32 balance = 3;
inline void Player::clear_balance() {
  _impl_.balance_ = 0u;
}
inline uint32_t Player::_internal_balance() const {
  return _impl_.balance_;
}
inline uint32_t Player::balance() const {
  // @@protoc_insertion_point(field_get:game.Player.balance)
  return _internal_balance();
}
inline void Player::_internal_set_balance(uint32_t value) {
  
  _impl_.balance_ = value;
}
inline void Player::set_balance(uint32_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:game.Player.balance)
}

// -------------------------------------------------------------------

// LobbyRequests

// .game.CreateGameRequest create_game_request = 1;
inline bool LobbyRequests::_internal_has_create_game_request() const {
  return requests_case() == kCreateGameRequest;
}
inline bool LobbyRequests::has_create_game_request() const {
  return _internal_has_create_game_request();
}
inline void LobbyRequests::set_has_create_game_request() {
  _impl_._oneof_case_[0] = kCreateGameRequest;
}
inline void LobbyRequests::clear_create_game_request() {
  if (_internal_has_create_game_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.requests_.create_game_request_;
    }
    clear_has_requests();
  }
}
inline ::game::CreateGameRequest* LobbyRequests::release_create_game_request() {
  // @@protoc_insertion_point(field_release:game.LobbyRequests.create_game_request)
  if (_internal_has_create_game_request()) {
    clear_has_requests();
    ::game::CreateGameRequest* temp = _impl_.requests_.create_game_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requests_.create_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::CreateGameRequest& LobbyRequests::_internal_create_game_request() const {
  return _internal_has_create_game_request()
      ? *_impl_.requests_.create_game_request_
      : reinterpret_cast< ::game::CreateGameRequest&>(::game::_CreateGameRequest_default_instance_);
}
inline const ::game::CreateGameRequest& LobbyRequests::create_game_request() const {
  // @@protoc_insertion_point(field_get:game.LobbyRequests.create_game_request)
  return _internal_create_game_request();
}
inline ::game::CreateGameRequest* LobbyRequests::unsafe_arena_release_create_game_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LobbyRequests.create_game_request)
  if (_internal_has_create_game_request()) {
    clear_has_requests();
    ::game::CreateGameRequest* temp = _impl_.requests_.create_game_request_;
    _impl_.requests_.create_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbyRequests::unsafe_arena_set_allocated_create_game_request(::game::CreateGameRequest* create_game_request) {
  clear_requests();
  if (create_game_request) {
    set_has_create_game_request();
    _impl_.requests_.create_game_request_ = create_game_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LobbyRequests.create_game_request)
}
inline ::game::CreateGameRequest* LobbyRequests::_internal_mutable_create_game_request() {
  if (!_internal_has_create_game_request()) {
    clear_requests();
    set_has_create_game_request();
    _impl_.requests_.create_game_request_ = CreateMaybeMessage< ::game::CreateGameRequest >(GetArenaForAllocation());
  }
  return _impl_.requests_.create_game_request_;
}
inline ::game::CreateGameRequest* LobbyRequests::mutable_create_game_request() {
  ::game::CreateGameRequest* _msg = _internal_mutable_create_game_request();
  // @@protoc_insertion_point(field_mutable:game.LobbyRequests.create_game_request)
  return _msg;
}

// .game.SearchGameRequest search_game_request = 2;
inline bool LobbyRequests::_internal_has_search_game_request() const {
  return requests_case() == kSearchGameRequest;
}
inline bool LobbyRequests::has_search_game_request() const {
  return _internal_has_search_game_request();
}
inline void LobbyRequests::set_has_search_game_request() {
  _impl_._oneof_case_[0] = kSearchGameRequest;
}
inline void LobbyRequests::clear_search_game_request() {
  if (_internal_has_search_game_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.requests_.search_game_request_;
    }
    clear_has_requests();
  }
}
inline ::game::SearchGameRequest* LobbyRequests::release_search_game_request() {
  // @@protoc_insertion_point(field_release:game.LobbyRequests.search_game_request)
  if (_internal_has_search_game_request()) {
    clear_has_requests();
    ::game::SearchGameRequest* temp = _impl_.requests_.search_game_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requests_.search_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::SearchGameRequest& LobbyRequests::_internal_search_game_request() const {
  return _internal_has_search_game_request()
      ? *_impl_.requests_.search_game_request_
      : reinterpret_cast< ::game::SearchGameRequest&>(::game::_SearchGameRequest_default_instance_);
}
inline const ::game::SearchGameRequest& LobbyRequests::search_game_request() const {
  // @@protoc_insertion_point(field_get:game.LobbyRequests.search_game_request)
  return _internal_search_game_request();
}
inline ::game::SearchGameRequest* LobbyRequests::unsafe_arena_release_search_game_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LobbyRequests.search_game_request)
  if (_internal_has_search_game_request()) {
    clear_has_requests();
    ::game::SearchGameRequest* temp = _impl_.requests_.search_game_request_;
    _impl_.requests_.search_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbyRequests::unsafe_arena_set_allocated_search_game_request(::game::SearchGameRequest* search_game_request) {
  clear_requests();
  if (search_game_request) {
    set_has_search_game_request();
    _impl_.requests_.search_game_request_ = search_game_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LobbyRequests.search_game_request)
}
inline ::game::SearchGameRequest* LobbyRequests::_internal_mutable_search_game_request() {
  if (!_internal_has_search_game_request()) {
    clear_requests();
    set_has_search_game_request();
    _impl_.requests_.search_game_request_ = CreateMaybeMessage< ::game::SearchGameRequest >(GetArenaForAllocation());
  }
  return _impl_.requests_.search_game_request_;
}
inline ::game::SearchGameRequest* LobbyRequests::mutable_search_game_request() {
  ::game::SearchGameRequest* _msg = _internal_mutable_search_game_request();
  // @@protoc_insertion_point(field_mutable:game.LobbyRequests.search_game_request)
  return _msg;
}

inline bool LobbyRequests::has_requests() const {
  return requests_case() != REQUESTS_NOT_SET;
}
inline void LobbyRequests::clear_has_requests() {
  _impl_._oneof_case_[0] = REQUESTS_NOT_SET;
}
inline LobbyRequests::RequestsCase LobbyRequests::requests_case() const {
  return LobbyRequests::RequestsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LobbyResponses

// .game.CreateGameResponse create_game_response = 1;
inline bool LobbyResponses::_internal_has_create_game_response() const {
  return responses_case() == kCreateGameResponse;
}
inline bool LobbyResponses::has_create_game_response() const {
  return _internal_has_create_game_response();
}
inline void LobbyResponses::set_has_create_game_response() {
  _impl_._oneof_case_[0] = kCreateGameResponse;
}
inline void LobbyResponses::clear_create_game_response() {
  if (_internal_has_create_game_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.create_game_response_;
    }
    clear_has_responses();
  }
}
inline ::game::CreateGameResponse* LobbyResponses::release_create_game_response() {
  // @@protoc_insertion_point(field_release:game.LobbyResponses.create_game_response)
  if (_internal_has_create_game_response()) {
    clear_has_responses();
    ::game::CreateGameResponse* temp = _impl_.responses_.create_game_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.create_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::CreateGameResponse& LobbyResponses::_internal_create_game_response() const {
  return _internal_has_create_game_response()
      ? *_impl_.responses_.create_game_response_
      : reinterpret_cast< ::game::CreateGameResponse&>(::game::_CreateGameResponse_default_instance_);
}
inline const ::game::CreateGameResponse& LobbyResponses::create_game_response() const {
  // @@protoc_insertion_point(field_get:game.LobbyResponses.create_game_response)
  return _internal_create_game_response();
}
inline ::game::CreateGameResponse* LobbyResponses::unsafe_arena_release_create_game_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LobbyResponses.create_game_response)
  if (_internal_has_create_game_response()) {
    clear_has_responses();
    ::game::CreateGameResponse* temp = _impl_.responses_.create_game_response_;
    _impl_.responses_.create_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbyResponses::unsafe_arena_set_allocated_create_game_response(::game::CreateGameResponse* create_game_response) {
  clear_responses();
  if (create_game_response) {
    set_has_create_game_response();
    _impl_.responses_.create_game_response_ = create_game_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LobbyResponses.create_game_response)
}
inline ::game::CreateGameResponse* LobbyResponses::_internal_mutable_create_game_response() {
  if (!_internal_has_create_game_response()) {
    clear_responses();
    set_has_create_game_response();
    _impl_.responses_.create_game_response_ = CreateMaybeMessage< ::game::CreateGameResponse >(GetArenaForAllocation());
  }
  return _impl_.responses_.create_game_response_;
}
inline ::game::CreateGameResponse* LobbyResponses::mutable_create_game_response() {
  ::game::CreateGameResponse* _msg = _internal_mutable_create_game_response();
  // @@protoc_insertion_point(field_mutable:game.LobbyResponses.create_game_response)
  return _msg;
}

// .game.SearchGameResponse search_game_response = 2;
inline bool LobbyResponses::_internal_has_search_game_response() const {
  return responses_case() == kSearchGameResponse;
}
inline bool LobbyResponses::has_search_game_response() const {
  return _internal_has_search_game_response();
}
inline void LobbyResponses::set_has_search_game_response() {
  _impl_._oneof_case_[0] = kSearchGameResponse;
}
inline void LobbyResponses::clear_search_game_response() {
  if (_internal_has_search_game_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.search_game_response_;
    }
    clear_has_responses();
  }
}
inline ::game::SearchGameResponse* LobbyResponses::release_search_game_response() {
  // @@protoc_insertion_point(field_release:game.LobbyResponses.search_game_response)
  if (_internal_has_search_game_response()) {
    clear_has_responses();
    ::game::SearchGameResponse* temp = _impl_.responses_.search_game_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.search_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::SearchGameResponse& LobbyResponses::_internal_search_game_response() const {
  return _internal_has_search_game_response()
      ? *_impl_.responses_.search_game_response_
      : reinterpret_cast< ::game::SearchGameResponse&>(::game::_SearchGameResponse_default_instance_);
}
inline const ::game::SearchGameResponse& LobbyResponses::search_game_response() const {
  // @@protoc_insertion_point(field_get:game.LobbyResponses.search_game_response)
  return _internal_search_game_response();
}
inline ::game::SearchGameResponse* LobbyResponses::unsafe_arena_release_search_game_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.LobbyResponses.search_game_response)
  if (_internal_has_search_game_response()) {
    clear_has_responses();
    ::game::SearchGameResponse* temp = _impl_.responses_.search_game_response_;
    _impl_.responses_.search_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbyResponses::unsafe_arena_set_allocated_search_game_response(::game::SearchGameResponse* search_game_response) {
  clear_responses();
  if (search_game_response) {
    set_has_search_game_response();
    _impl_.responses_.search_game_response_ = search_game_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LobbyResponses.search_game_response)
}
inline ::game::SearchGameResponse* LobbyResponses::_internal_mutable_search_game_response() {
  if (!_internal_has_search_game_response()) {
    clear_responses();
    set_has_search_game_response();
    _impl_.responses_.search_game_response_ = CreateMaybeMessage< ::game::SearchGameResponse >(GetArenaForAllocation());
  }
  return _impl_.responses_.search_game_response_;
}
inline ::game::SearchGameResponse* LobbyResponses::mutable_search_game_response() {
  ::game::SearchGameResponse* _msg = _internal_mutable_search_game_response();
  // @@protoc_insertion_point(field_mutable:game.LobbyResponses.search_game_response)
  return _msg;
}

inline bool LobbyResponses::has_responses() const {
  return responses_case() != RESPONSES_NOT_SET;
}
inline void LobbyResponses::clear_has_responses() {
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}
inline LobbyResponses::ResponsesCase LobbyResponses::responses_case() const {
  return LobbyResponses::ResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateGameRequest

// uint32 game_owner_id = 1;
inline void CreateGameRequest::clear_game_owner_id() {
  _impl_.game_owner_id_ = 0u;
}
inline uint32_t CreateGameRequest::_internal_game_owner_id() const {
  return _impl_.game_owner_id_;
}
inline uint32_t CreateGameRequest::game_owner_id() const {
  // @@protoc_insertion_point(field_get:game.CreateGameRequest.game_owner_id)
  return _internal_game_owner_id();
}
inline void CreateGameRequest::_internal_set_game_owner_id(uint32_t value) {
  
  _impl_.game_owner_id_ = value;
}
inline void CreateGameRequest::set_game_owner_id(uint32_t value) {
  _internal_set_game_owner_id(value);
  // @@protoc_insertion_point(field_set:game.CreateGameRequest.game_owner_id)
}

// .game.GameParameters game_parameters = 2;
inline bool CreateGameRequest::_internal_has_game_parameters() const {
  return this != internal_default_instance() && _impl_.game_parameters_ != nullptr;
}
inline bool CreateGameRequest::has_game_parameters() const {
  return _internal_has_game_parameters();
}
inline void CreateGameRequest::clear_game_parameters() {
  if (GetArenaForAllocation() == nullptr && _impl_.game_parameters_ != nullptr) {
    delete _impl_.game_parameters_;
  }
  _impl_.game_parameters_ = nullptr;
}
inline const ::game::GameParameters& CreateGameRequest::_internal_game_parameters() const {
  const ::game::GameParameters* p = _impl_.game_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::GameParameters&>(
      ::game::_GameParameters_default_instance_);
}
inline const ::game::GameParameters& CreateGameRequest::game_parameters() const {
  // @@protoc_insertion_point(field_get:game.CreateGameRequest.game_parameters)
  return _internal_game_parameters();
}
inline void CreateGameRequest::unsafe_arena_set_allocated_game_parameters(
    ::game::GameParameters* game_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.game_parameters_);
  }
  _impl_.game_parameters_ = game_parameters;
  if (game_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.CreateGameRequest.game_parameters)
}
inline ::game::GameParameters* CreateGameRequest::release_game_parameters() {
  
  ::game::GameParameters* temp = _impl_.game_parameters_;
  _impl_.game_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::GameParameters* CreateGameRequest::unsafe_arena_release_game_parameters() {
  // @@protoc_insertion_point(field_release:game.CreateGameRequest.game_parameters)
  
  ::game::GameParameters* temp = _impl_.game_parameters_;
  _impl_.game_parameters_ = nullptr;
  return temp;
}
inline ::game::GameParameters* CreateGameRequest::_internal_mutable_game_parameters() {
  
  if (_impl_.game_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::GameParameters>(GetArenaForAllocation());
    _impl_.game_parameters_ = p;
  }
  return _impl_.game_parameters_;
}
inline ::game::GameParameters* CreateGameRequest::mutable_game_parameters() {
  ::game::GameParameters* _msg = _internal_mutable_game_parameters();
  // @@protoc_insertion_point(field_mutable:game.CreateGameRequest.game_parameters)
  return _msg;
}
inline void CreateGameRequest::set_allocated_game_parameters(::game::GameParameters* game_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.game_parameters_;
  }
  if (game_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(game_parameters);
    if (message_arena != submessage_arena) {
      game_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.game_parameters_ = game_parameters;
  // @@protoc_insertion_point(field_set_allocated:game.CreateGameRequest.game_parameters)
}

// -------------------------------------------------------------------

// CreateGameResponse

// uint32 game_id = 1;
inline bool CreateGameResponse::_internal_has_game_id() const {
  return responses_case() == kGameId;
}
inline bool CreateGameResponse::has_game_id() const {
  return _internal_has_game_id();
}
inline void CreateGameResponse::set_has_game_id() {
  _impl_._oneof_case_[0] = kGameId;
}
inline void CreateGameResponse::clear_game_id() {
  if (_internal_has_game_id()) {
    _impl_.responses_.game_id_ = 0u;
    clear_has_responses();
  }
}
inline uint32_t CreateGameResponse::_internal_game_id() const {
  if (_internal_has_game_id()) {
    return _impl_.responses_.game_id_;
  }
  return 0u;
}
inline void CreateGameResponse::_internal_set_game_id(uint32_t value) {
  if (!_internal_has_game_id()) {
    clear_responses();
    set_has_game_id();
  }
  _impl_.responses_.game_id_ = value;
}
inline uint32_t CreateGameResponse::game_id() const {
  // @@protoc_insertion_point(field_get:game.CreateGameResponse.game_id)
  return _internal_game_id();
}
inline void CreateGameResponse::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:game.CreateGameResponse.game_id)
}

// .game.ErrorMessage msg = 2;
inline bool CreateGameResponse::_internal_has_msg() const {
  return responses_case() == kMsg;
}
inline bool CreateGameResponse::has_msg() const {
  return _internal_has_msg();
}
inline void CreateGameResponse::set_has_msg() {
  _impl_._oneof_case_[0] = kMsg;
}
inline void CreateGameResponse::clear_msg() {
  if (_internal_has_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.msg_;
    }
    clear_has_responses();
  }
}
inline ::game::ErrorMessage* CreateGameResponse::release_msg() {
  // @@protoc_insertion_point(field_release:game.CreateGameResponse.msg)
  if (_internal_has_msg()) {
    clear_has_responses();
    ::game::ErrorMessage* temp = _impl_.responses_.msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ErrorMessage& CreateGameResponse::_internal_msg() const {
  return _internal_has_msg()
      ? *_impl_.responses_.msg_
      : reinterpret_cast< ::game::ErrorMessage&>(::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& CreateGameResponse::msg() const {
  // @@protoc_insertion_point(field_get:game.CreateGameResponse.msg)
  return _internal_msg();
}
inline ::game::ErrorMessage* CreateGameResponse::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.CreateGameResponse.msg)
  if (_internal_has_msg()) {
    clear_has_responses();
    ::game::ErrorMessage* temp = _impl_.responses_.msg_;
    _impl_.responses_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateGameResponse::unsafe_arena_set_allocated_msg(::game::ErrorMessage* msg) {
  clear_responses();
  if (msg) {
    set_has_msg();
    _impl_.responses_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.CreateGameResponse.msg)
}
inline ::game::ErrorMessage* CreateGameResponse::_internal_mutable_msg() {
  if (!_internal_has_msg()) {
    clear_responses();
    set_has_msg();
    _impl_.responses_.msg_ = CreateMaybeMessage< ::game::ErrorMessage >(GetArenaForAllocation());
  }
  return _impl_.responses_.msg_;
}
inline ::game::ErrorMessage* CreateGameResponse::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.CreateGameResponse.msg)
  return _msg;
}

inline bool CreateGameResponse::has_responses() const {
  return responses_case() != RESPONSES_NOT_SET;
}
inline void CreateGameResponse::clear_has_responses() {
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}
inline CreateGameResponse::ResponsesCase CreateGameResponse::responses_case() const {
  return CreateGameResponse::ResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SearchGameRequest

// uint32 id = 1;
inline void SearchGameRequest::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t SearchGameRequest::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t SearchGameRequest::id() const {
  // @@protoc_insertion_point(field_get:game.SearchGameRequest.id)
  return _internal_id();
}
inline void SearchGameRequest::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void SearchGameRequest::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.SearchGameRequest.id)
}

// .game.GameParameters game_parameters = 2;
inline bool SearchGameRequest::_internal_has_game_parameters() const {
  return this != internal_default_instance() && _impl_.game_parameters_ != nullptr;
}
inline bool SearchGameRequest::has_game_parameters() const {
  return _internal_has_game_parameters();
}
inline void SearchGameRequest::clear_game_parameters() {
  if (GetArenaForAllocation() == nullptr && _impl_.game_parameters_ != nullptr) {
    delete _impl_.game_parameters_;
  }
  _impl_.game_parameters_ = nullptr;
}
inline const ::game::GameParameters& SearchGameRequest::_internal_game_parameters() const {
  const ::game::GameParameters* p = _impl_.game_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::GameParameters&>(
      ::game::_GameParameters_default_instance_);
}
inline const ::game::GameParameters& SearchGameRequest::game_parameters() const {
  // @@protoc_insertion_point(field_get:game.SearchGameRequest.game_parameters)
  return _internal_game_parameters();
}
inline void SearchGameRequest::unsafe_arena_set_allocated_game_parameters(
    ::game::GameParameters* game_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.game_parameters_);
  }
  _impl_.game_parameters_ = game_parameters;
  if (game_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.SearchGameRequest.game_parameters)
}
inline ::game::GameParameters* SearchGameRequest::release_game_parameters() {
  
  ::game::GameParameters* temp = _impl_.game_parameters_;
  _impl_.game_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::GameParameters* SearchGameRequest::unsafe_arena_release_game_parameters() {
  // @@protoc_insertion_point(field_release:game.SearchGameRequest.game_parameters)
  
  ::game::GameParameters* temp = _impl_.game_parameters_;
  _impl_.game_parameters_ = nullptr;
  return temp;
}
inline ::game::GameParameters* SearchGameRequest::_internal_mutable_game_parameters() {
  
  if (_impl_.game_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::GameParameters>(GetArenaForAllocation());
    _impl_.game_parameters_ = p;
  }
  return _impl_.game_parameters_;
}
inline ::game::GameParameters* SearchGameRequest::mutable_game_parameters() {
  ::game::GameParameters* _msg = _internal_mutable_game_parameters();
  // @@protoc_insertion_point(field_mutable:game.SearchGameRequest.game_parameters)
  return _msg;
}
inline void SearchGameRequest::set_allocated_game_parameters(::game::GameParameters* game_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.game_parameters_;
  }
  if (game_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(game_parameters);
    if (message_arena != submessage_arena) {
      game_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.game_parameters_ = game_parameters;
  // @@protoc_insertion_point(field_set_allocated:game.SearchGameRequest.game_parameters)
}

// -------------------------------------------------------------------

// SearchGameResponse

// uint32 game_id = 1;
inline bool SearchGameResponse::_internal_has_game_id() const {
  return responses_case() == kGameId;
}
inline bool SearchGameResponse::has_game_id() const {
  return _internal_has_game_id();
}
inline void SearchGameResponse::set_has_game_id() {
  _impl_._oneof_case_[0] = kGameId;
}
inline void SearchGameResponse::clear_game_id() {
  if (_internal_has_game_id()) {
    _impl_.responses_.game_id_ = 0u;
    clear_has_responses();
  }
}
inline uint32_t SearchGameResponse::_internal_game_id() const {
  if (_internal_has_game_id()) {
    return _impl_.responses_.game_id_;
  }
  return 0u;
}
inline void SearchGameResponse::_internal_set_game_id(uint32_t value) {
  if (!_internal_has_game_id()) {
    clear_responses();
    set_has_game_id();
  }
  _impl_.responses_.game_id_ = value;
}
inline uint32_t SearchGameResponse::game_id() const {
  // @@protoc_insertion_point(field_get:game.SearchGameResponse.game_id)
  return _internal_game_id();
}
inline void SearchGameResponse::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:game.SearchGameResponse.game_id)
}

// .game.ErrorMessage msg = 2;
inline bool SearchGameResponse::_internal_has_msg() const {
  return responses_case() == kMsg;
}
inline bool SearchGameResponse::has_msg() const {
  return _internal_has_msg();
}
inline void SearchGameResponse::set_has_msg() {
  _impl_._oneof_case_[0] = kMsg;
}
inline void SearchGameResponse::clear_msg() {
  if (_internal_has_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.msg_;
    }
    clear_has_responses();
  }
}
inline ::game::ErrorMessage* SearchGameResponse::release_msg() {
  // @@protoc_insertion_point(field_release:game.SearchGameResponse.msg)
  if (_internal_has_msg()) {
    clear_has_responses();
    ::game::ErrorMessage* temp = _impl_.responses_.msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ErrorMessage& SearchGameResponse::_internal_msg() const {
  return _internal_has_msg()
      ? *_impl_.responses_.msg_
      : reinterpret_cast< ::game::ErrorMessage&>(::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& SearchGameResponse::msg() const {
  // @@protoc_insertion_point(field_get:game.SearchGameResponse.msg)
  return _internal_msg();
}
inline ::game::ErrorMessage* SearchGameResponse::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.SearchGameResponse.msg)
  if (_internal_has_msg()) {
    clear_has_responses();
    ::game::ErrorMessage* temp = _impl_.responses_.msg_;
    _impl_.responses_.msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SearchGameResponse::unsafe_arena_set_allocated_msg(::game::ErrorMessage* msg) {
  clear_responses();
  if (msg) {
    set_has_msg();
    _impl_.responses_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.SearchGameResponse.msg)
}
inline ::game::ErrorMessage* SearchGameResponse::_internal_mutable_msg() {
  if (!_internal_has_msg()) {
    clear_responses();
    set_has_msg();
    _impl_.responses_.msg_ = CreateMaybeMessage< ::game::ErrorMessage >(GetArenaForAllocation());
  }
  return _impl_.responses_.msg_;
}
inline ::game::ErrorMessage* SearchGameResponse::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.SearchGameResponse.msg)
  return _msg;
}

inline bool SearchGameResponse::has_responses() const {
  return responses_case() != RESPONSES_NOT_SET;
}
inline void SearchGameResponse::clear_has_responses() {
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}
inline SearchGameResponse::ResponsesCase SearchGameResponse::responses_case() const {
  return SearchGameResponse::ResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GameParameters

// string game_name = 1;
inline void GameParameters::clear_game_name() {
  _impl_.game_name_.ClearToEmpty();
}
inline const std::string& GameParameters::game_name() const {
  // @@protoc_insertion_point(field_get:game.GameParameters.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameParameters::set_game_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.GameParameters.game_name)
}
inline std::string* GameParameters::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:game.GameParameters.game_name)
  return _s;
}
inline const std::string& GameParameters::_internal_game_name() const {
  return _impl_.game_name_.Get();
}
inline void GameParameters::_internal_set_game_name(const std::string& value) {
  
  _impl_.game_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GameParameters::_internal_mutable_game_name() {
  
  return _impl_.game_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GameParameters::release_game_name() {
  // @@protoc_insertion_point(field_release:game.GameParameters.game_name)
  return _impl_.game_name_.Release();
}
inline void GameParameters::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    
  } else {
    
  }
  _impl_.game_name_.SetAllocated(game_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_name_.IsDefault()) {
    _impl_.game_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.GameParameters.game_name)
}

// uint32 number_of_players = 2;
inline void GameParameters::clear_number_of_players() {
  _impl_.number_of_players_ = 0u;
}
inline uint32_t GameParameters::_internal_number_of_players() const {
  return _impl_.number_of_players_;
}
inline uint32_t GameParameters::number_of_players() const {
  // @@protoc_insertion_point(field_get:game.GameParameters.number_of_players)
  return _internal_number_of_players();
}
inline void GameParameters::_internal_set_number_of_players(uint32_t value) {
  
  _impl_.number_of_players_ = value;
}
inline void GameParameters::set_number_of_players(uint32_t value) {
  _internal_set_number_of_players(value);
  // @@protoc_insertion_point(field_set:game.GameParameters.number_of_players)
}

// uint32 minimal_bet = 3;
inline void GameParameters::clear_minimal_bet() {
  _impl_.minimal_bet_ = 0u;
}
inline uint32_t GameParameters::_internal_minimal_bet() const {
  return _impl_.minimal_bet_;
}
inline uint32_t GameParameters::minimal_bet() const {
  // @@protoc_insertion_point(field_get:game.GameParameters.minimal_bet)
  return _internal_minimal_bet();
}
inline void GameParameters::_internal_set_minimal_bet(uint32_t value) {
  
  _impl_.minimal_bet_ = value;
}
inline void GameParameters::set_minimal_bet(uint32_t value) {
  _internal_set_minimal_bet(value);
  // @@protoc_insertion_point(field_set:game.GameParameters.minimal_bet)
}

// uint32 game_enter_balance = 4;
inline void GameParameters::clear_game_enter_balance() {
  _impl_.game_enter_balance_ = 0u;
}
inline uint32_t GameParameters::_internal_game_enter_balance() const {
  return _impl_.game_enter_balance_;
}
inline uint32_t GameParameters::game_enter_balance() const {
  // @@protoc_insertion_point(field_get:game.GameParameters.game_enter_balance)
  return _internal_game_enter_balance();
}
inline void GameParameters::_internal_set_game_enter_balance(uint32_t value) {
  
  _impl_.game_enter_balance_ = value;
}
inline void GameParameters::set_game_enter_balance(uint32_t value) {
  _internal_set_game_enter_balance(value);
  // @@protoc_insertion_point(field_set:game.GameParameters.game_enter_balance)
}

// -------------------------------------------------------------------

// PlayerInfo

// uint32 client_id = 1;
inline void PlayerInfo::clear_client_id() {
  _impl_.client_id_ = 0u;
}
inline uint32_t PlayerInfo::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t PlayerInfo::client_id() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.client_id)
  return _internal_client_id();
}
inline void PlayerInfo::_internal_set_client_id(uint32_t value) {
  
  _impl_.client_id_ = value;
}
inline void PlayerInfo::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.client_id)
}

// uint32 client_games = 2;
inline void PlayerInfo::clear_client_games() {
  _impl_.client_games_ = 0u;
}
inline uint32_t PlayerInfo::_internal_client_games() const {
  return _impl_.client_games_;
}
inline uint32_t PlayerInfo::client_games() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.client_games)
  return _internal_client_games();
}
inline void PlayerInfo::_internal_set_client_games(uint32_t value) {
  
  _impl_.client_games_ = value;
}
inline void PlayerInfo::set_client_games(uint32_t value) {
  _internal_set_client_games(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.client_games)
}

// uint32 client_wins = 3;
inline void PlayerInfo::clear_client_wins() {
  _impl_.client_wins_ = 0u;
}
inline uint32_t PlayerInfo::_internal_client_wins() const {
  return _impl_.client_wins_;
}
inline uint32_t PlayerInfo::client_wins() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.client_wins)
  return _internal_client_wins();
}
inline void PlayerInfo::_internal_set_client_wins(uint32_t value) {
  
  _impl_.client_wins_ = value;
}
inline void PlayerInfo::set_client_wins(uint32_t value) {
  _internal_set_client_wins(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.client_wins)
}

// uint32 client_balance = 4;
inline void PlayerInfo::clear_client_balance() {
  _impl_.client_balance_ = 0u;
}
inline uint32_t PlayerInfo::_internal_client_balance() const {
  return _impl_.client_balance_;
}
inline uint32_t PlayerInfo::client_balance() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.client_balance)
  return _internal_client_balance();
}
inline void PlayerInfo::_internal_set_client_balance(uint32_t value) {
  
  _impl_.client_balance_ = value;
}
inline void PlayerInfo::set_client_balance(uint32_t value) {
  _internal_set_client_balance(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.client_balance)
}

// -------------------------------------------------------------------

// GameRequests

// .game.MakeMoveRequest make_move_request = 1;
inline bool GameRequests::_internal_has_make_move_request() const {
  return requests_case() == kMakeMoveRequest;
}
inline bool GameRequests::has_make_move_request() const {
  return _internal_has_make_move_request();
}
inline void GameRequests::set_has_make_move_request() {
  _impl_._oneof_case_[0] = kMakeMoveRequest;
}
inline void GameRequests::clear_make_move_request() {
  if (_internal_has_make_move_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.requests_.make_move_request_;
    }
    clear_has_requests();
  }
}
inline ::game::MakeMoveRequest* GameRequests::release_make_move_request() {
  // @@protoc_insertion_point(field_release:game.GameRequests.make_move_request)
  if (_internal_has_make_move_request()) {
    clear_has_requests();
    ::game::MakeMoveRequest* temp = _impl_.requests_.make_move_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requests_.make_move_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::MakeMoveRequest& GameRequests::_internal_make_move_request() const {
  return _internal_has_make_move_request()
      ? *_impl_.requests_.make_move_request_
      : reinterpret_cast< ::game::MakeMoveRequest&>(::game::_MakeMoveRequest_default_instance_);
}
inline const ::game::MakeMoveRequest& GameRequests::make_move_request() const {
  // @@protoc_insertion_point(field_get:game.GameRequests.make_move_request)
  return _internal_make_move_request();
}
inline ::game::MakeMoveRequest* GameRequests::unsafe_arena_release_make_move_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameRequests.make_move_request)
  if (_internal_has_make_move_request()) {
    clear_has_requests();
    ::game::MakeMoveRequest* temp = _impl_.requests_.make_move_request_;
    _impl_.requests_.make_move_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameRequests::unsafe_arena_set_allocated_make_move_request(::game::MakeMoveRequest* make_move_request) {
  clear_requests();
  if (make_move_request) {
    set_has_make_move_request();
    _impl_.requests_.make_move_request_ = make_move_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameRequests.make_move_request)
}
inline ::game::MakeMoveRequest* GameRequests::_internal_mutable_make_move_request() {
  if (!_internal_has_make_move_request()) {
    clear_requests();
    set_has_make_move_request();
    _impl_.requests_.make_move_request_ = CreateMaybeMessage< ::game::MakeMoveRequest >(GetArenaForAllocation());
  }
  return _impl_.requests_.make_move_request_;
}
inline ::game::MakeMoveRequest* GameRequests::mutable_make_move_request() {
  ::game::MakeMoveRequest* _msg = _internal_mutable_make_move_request();
  // @@protoc_insertion_point(field_mutable:game.GameRequests.make_move_request)
  return _msg;
}

// .game.JoinGameRequest join_game_request = 2;
inline bool GameRequests::_internal_has_join_game_request() const {
  return requests_case() == kJoinGameRequest;
}
inline bool GameRequests::has_join_game_request() const {
  return _internal_has_join_game_request();
}
inline void GameRequests::set_has_join_game_request() {
  _impl_._oneof_case_[0] = kJoinGameRequest;
}
inline void GameRequests::clear_join_game_request() {
  if (_internal_has_join_game_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.requests_.join_game_request_;
    }
    clear_has_requests();
  }
}
inline ::game::JoinGameRequest* GameRequests::release_join_game_request() {
  // @@protoc_insertion_point(field_release:game.GameRequests.join_game_request)
  if (_internal_has_join_game_request()) {
    clear_has_requests();
    ::game::JoinGameRequest* temp = _impl_.requests_.join_game_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requests_.join_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::JoinGameRequest& GameRequests::_internal_join_game_request() const {
  return _internal_has_join_game_request()
      ? *_impl_.requests_.join_game_request_
      : reinterpret_cast< ::game::JoinGameRequest&>(::game::_JoinGameRequest_default_instance_);
}
inline const ::game::JoinGameRequest& GameRequests::join_game_request() const {
  // @@protoc_insertion_point(field_get:game.GameRequests.join_game_request)
  return _internal_join_game_request();
}
inline ::game::JoinGameRequest* GameRequests::unsafe_arena_release_join_game_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameRequests.join_game_request)
  if (_internal_has_join_game_request()) {
    clear_has_requests();
    ::game::JoinGameRequest* temp = _impl_.requests_.join_game_request_;
    _impl_.requests_.join_game_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameRequests::unsafe_arena_set_allocated_join_game_request(::game::JoinGameRequest* join_game_request) {
  clear_requests();
  if (join_game_request) {
    set_has_join_game_request();
    _impl_.requests_.join_game_request_ = join_game_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameRequests.join_game_request)
}
inline ::game::JoinGameRequest* GameRequests::_internal_mutable_join_game_request() {
  if (!_internal_has_join_game_request()) {
    clear_requests();
    set_has_join_game_request();
    _impl_.requests_.join_game_request_ = CreateMaybeMessage< ::game::JoinGameRequest >(GetArenaForAllocation());
  }
  return _impl_.requests_.join_game_request_;
}
inline ::game::JoinGameRequest* GameRequests::mutable_join_game_request() {
  ::game::JoinGameRequest* _msg = _internal_mutable_join_game_request();
  // @@protoc_insertion_point(field_mutable:game.GameRequests.join_game_request)
  return _msg;
}

// .game.JoinGameAsOwnerRequest join_game_as_owner_request = 3;
inline bool GameRequests::_internal_has_join_game_as_owner_request() const {
  return requests_case() == kJoinGameAsOwnerRequest;
}
inline bool GameRequests::has_join_game_as_owner_request() const {
  return _internal_has_join_game_as_owner_request();
}
inline void GameRequests::set_has_join_game_as_owner_request() {
  _impl_._oneof_case_[0] = kJoinGameAsOwnerRequest;
}
inline void GameRequests::clear_join_game_as_owner_request() {
  if (_internal_has_join_game_as_owner_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.requests_.join_game_as_owner_request_;
    }
    clear_has_requests();
  }
}
inline ::game::JoinGameAsOwnerRequest* GameRequests::release_join_game_as_owner_request() {
  // @@protoc_insertion_point(field_release:game.GameRequests.join_game_as_owner_request)
  if (_internal_has_join_game_as_owner_request()) {
    clear_has_requests();
    ::game::JoinGameAsOwnerRequest* temp = _impl_.requests_.join_game_as_owner_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requests_.join_game_as_owner_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::JoinGameAsOwnerRequest& GameRequests::_internal_join_game_as_owner_request() const {
  return _internal_has_join_game_as_owner_request()
      ? *_impl_.requests_.join_game_as_owner_request_
      : reinterpret_cast< ::game::JoinGameAsOwnerRequest&>(::game::_JoinGameAsOwnerRequest_default_instance_);
}
inline const ::game::JoinGameAsOwnerRequest& GameRequests::join_game_as_owner_request() const {
  // @@protoc_insertion_point(field_get:game.GameRequests.join_game_as_owner_request)
  return _internal_join_game_as_owner_request();
}
inline ::game::JoinGameAsOwnerRequest* GameRequests::unsafe_arena_release_join_game_as_owner_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameRequests.join_game_as_owner_request)
  if (_internal_has_join_game_as_owner_request()) {
    clear_has_requests();
    ::game::JoinGameAsOwnerRequest* temp = _impl_.requests_.join_game_as_owner_request_;
    _impl_.requests_.join_game_as_owner_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameRequests::unsafe_arena_set_allocated_join_game_as_owner_request(::game::JoinGameAsOwnerRequest* join_game_as_owner_request) {
  clear_requests();
  if (join_game_as_owner_request) {
    set_has_join_game_as_owner_request();
    _impl_.requests_.join_game_as_owner_request_ = join_game_as_owner_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameRequests.join_game_as_owner_request)
}
inline ::game::JoinGameAsOwnerRequest* GameRequests::_internal_mutable_join_game_as_owner_request() {
  if (!_internal_has_join_game_as_owner_request()) {
    clear_requests();
    set_has_join_game_as_owner_request();
    _impl_.requests_.join_game_as_owner_request_ = CreateMaybeMessage< ::game::JoinGameAsOwnerRequest >(GetArenaForAllocation());
  }
  return _impl_.requests_.join_game_as_owner_request_;
}
inline ::game::JoinGameAsOwnerRequest* GameRequests::mutable_join_game_as_owner_request() {
  ::game::JoinGameAsOwnerRequest* _msg = _internal_mutable_join_game_as_owner_request();
  // @@protoc_insertion_point(field_mutable:game.GameRequests.join_game_as_owner_request)
  return _msg;
}

inline bool GameRequests::has_requests() const {
  return requests_case() != REQUESTS_NOT_SET;
}
inline void GameRequests::clear_has_requests() {
  _impl_._oneof_case_[0] = REQUESTS_NOT_SET;
}
inline GameRequests::RequestsCase GameRequests::requests_case() const {
  return GameRequests::RequestsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GameResponses

// .game.MakeMoveResponse make_move_response = 1;
inline bool GameResponses::_internal_has_make_move_response() const {
  return responses_case() == kMakeMoveResponse;
}
inline bool GameResponses::has_make_move_response() const {
  return _internal_has_make_move_response();
}
inline void GameResponses::set_has_make_move_response() {
  _impl_._oneof_case_[0] = kMakeMoveResponse;
}
inline void GameResponses::clear_make_move_response() {
  if (_internal_has_make_move_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.make_move_response_;
    }
    clear_has_responses();
  }
}
inline ::game::MakeMoveResponse* GameResponses::release_make_move_response() {
  // @@protoc_insertion_point(field_release:game.GameResponses.make_move_response)
  if (_internal_has_make_move_response()) {
    clear_has_responses();
    ::game::MakeMoveResponse* temp = _impl_.responses_.make_move_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.make_move_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::MakeMoveResponse& GameResponses::_internal_make_move_response() const {
  return _internal_has_make_move_response()
      ? *_impl_.responses_.make_move_response_
      : reinterpret_cast< ::game::MakeMoveResponse&>(::game::_MakeMoveResponse_default_instance_);
}
inline const ::game::MakeMoveResponse& GameResponses::make_move_response() const {
  // @@protoc_insertion_point(field_get:game.GameResponses.make_move_response)
  return _internal_make_move_response();
}
inline ::game::MakeMoveResponse* GameResponses::unsafe_arena_release_make_move_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameResponses.make_move_response)
  if (_internal_has_make_move_response()) {
    clear_has_responses();
    ::game::MakeMoveResponse* temp = _impl_.responses_.make_move_response_;
    _impl_.responses_.make_move_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameResponses::unsafe_arena_set_allocated_make_move_response(::game::MakeMoveResponse* make_move_response) {
  clear_responses();
  if (make_move_response) {
    set_has_make_move_response();
    _impl_.responses_.make_move_response_ = make_move_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameResponses.make_move_response)
}
inline ::game::MakeMoveResponse* GameResponses::_internal_mutable_make_move_response() {
  if (!_internal_has_make_move_response()) {
    clear_responses();
    set_has_make_move_response();
    _impl_.responses_.make_move_response_ = CreateMaybeMessage< ::game::MakeMoveResponse >(GetArenaForAllocation());
  }
  return _impl_.responses_.make_move_response_;
}
inline ::game::MakeMoveResponse* GameResponses::mutable_make_move_response() {
  ::game::MakeMoveResponse* _msg = _internal_mutable_make_move_response();
  // @@protoc_insertion_point(field_mutable:game.GameResponses.make_move_response)
  return _msg;
}

// .game.GameState game_state = 2;
inline bool GameResponses::_internal_has_game_state() const {
  return responses_case() == kGameState;
}
inline bool GameResponses::has_game_state() const {
  return _internal_has_game_state();
}
inline void GameResponses::set_has_game_state() {
  _impl_._oneof_case_[0] = kGameState;
}
inline void GameResponses::clear_game_state() {
  if (_internal_has_game_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.game_state_;
    }
    clear_has_responses();
  }
}
inline ::game::GameState* GameResponses::release_game_state() {
  // @@protoc_insertion_point(field_release:game.GameResponses.game_state)
  if (_internal_has_game_state()) {
    clear_has_responses();
    ::game::GameState* temp = _impl_.responses_.game_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.game_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::GameState& GameResponses::_internal_game_state() const {
  return _internal_has_game_state()
      ? *_impl_.responses_.game_state_
      : reinterpret_cast< ::game::GameState&>(::game::_GameState_default_instance_);
}
inline const ::game::GameState& GameResponses::game_state() const {
  // @@protoc_insertion_point(field_get:game.GameResponses.game_state)
  return _internal_game_state();
}
inline ::game::GameState* GameResponses::unsafe_arena_release_game_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameResponses.game_state)
  if (_internal_has_game_state()) {
    clear_has_responses();
    ::game::GameState* temp = _impl_.responses_.game_state_;
    _impl_.responses_.game_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameResponses::unsafe_arena_set_allocated_game_state(::game::GameState* game_state) {
  clear_responses();
  if (game_state) {
    set_has_game_state();
    _impl_.responses_.game_state_ = game_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameResponses.game_state)
}
inline ::game::GameState* GameResponses::_internal_mutable_game_state() {
  if (!_internal_has_game_state()) {
    clear_responses();
    set_has_game_state();
    _impl_.responses_.game_state_ = CreateMaybeMessage< ::game::GameState >(GetArenaForAllocation());
  }
  return _impl_.responses_.game_state_;
}
inline ::game::GameState* GameResponses::mutable_game_state() {
  ::game::GameState* _msg = _internal_mutable_game_state();
  // @@protoc_insertion_point(field_mutable:game.GameResponses.game_state)
  return _msg;
}

// .game.JoinGameResponse join_game_response = 3;
inline bool GameResponses::_internal_has_join_game_response() const {
  return responses_case() == kJoinGameResponse;
}
inline bool GameResponses::has_join_game_response() const {
  return _internal_has_join_game_response();
}
inline void GameResponses::set_has_join_game_response() {
  _impl_._oneof_case_[0] = kJoinGameResponse;
}
inline void GameResponses::clear_join_game_response() {
  if (_internal_has_join_game_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.join_game_response_;
    }
    clear_has_responses();
  }
}
inline ::game::JoinGameResponse* GameResponses::release_join_game_response() {
  // @@protoc_insertion_point(field_release:game.GameResponses.join_game_response)
  if (_internal_has_join_game_response()) {
    clear_has_responses();
    ::game::JoinGameResponse* temp = _impl_.responses_.join_game_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.join_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::JoinGameResponse& GameResponses::_internal_join_game_response() const {
  return _internal_has_join_game_response()
      ? *_impl_.responses_.join_game_response_
      : reinterpret_cast< ::game::JoinGameResponse&>(::game::_JoinGameResponse_default_instance_);
}
inline const ::game::JoinGameResponse& GameResponses::join_game_response() const {
  // @@protoc_insertion_point(field_get:game.GameResponses.join_game_response)
  return _internal_join_game_response();
}
inline ::game::JoinGameResponse* GameResponses::unsafe_arena_release_join_game_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameResponses.join_game_response)
  if (_internal_has_join_game_response()) {
    clear_has_responses();
    ::game::JoinGameResponse* temp = _impl_.responses_.join_game_response_;
    _impl_.responses_.join_game_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameResponses::unsafe_arena_set_allocated_join_game_response(::game::JoinGameResponse* join_game_response) {
  clear_responses();
  if (join_game_response) {
    set_has_join_game_response();
    _impl_.responses_.join_game_response_ = join_game_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameResponses.join_game_response)
}
inline ::game::JoinGameResponse* GameResponses::_internal_mutable_join_game_response() {
  if (!_internal_has_join_game_response()) {
    clear_responses();
    set_has_join_game_response();
    _impl_.responses_.join_game_response_ = CreateMaybeMessage< ::game::JoinGameResponse >(GetArenaForAllocation());
  }
  return _impl_.responses_.join_game_response_;
}
inline ::game::JoinGameResponse* GameResponses::mutable_join_game_response() {
  ::game::JoinGameResponse* _msg = _internal_mutable_join_game_response();
  // @@protoc_insertion_point(field_mutable:game.GameResponses.join_game_response)
  return _msg;
}

// .game.JoinGameAsOwnerResponse join_game_as_owner_response = 4;
inline bool GameResponses::_internal_has_join_game_as_owner_response() const {
  return responses_case() == kJoinGameAsOwnerResponse;
}
inline bool GameResponses::has_join_game_as_owner_response() const {
  return _internal_has_join_game_as_owner_response();
}
inline void GameResponses::set_has_join_game_as_owner_response() {
  _impl_._oneof_case_[0] = kJoinGameAsOwnerResponse;
}
inline void GameResponses::clear_join_game_as_owner_response() {
  if (_internal_has_join_game_as_owner_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.responses_.join_game_as_owner_response_;
    }
    clear_has_responses();
  }
}
inline ::game::JoinGameAsOwnerResponse* GameResponses::release_join_game_as_owner_response() {
  // @@protoc_insertion_point(field_release:game.GameResponses.join_game_as_owner_response)
  if (_internal_has_join_game_as_owner_response()) {
    clear_has_responses();
    ::game::JoinGameAsOwnerResponse* temp = _impl_.responses_.join_game_as_owner_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.responses_.join_game_as_owner_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::JoinGameAsOwnerResponse& GameResponses::_internal_join_game_as_owner_response() const {
  return _internal_has_join_game_as_owner_response()
      ? *_impl_.responses_.join_game_as_owner_response_
      : reinterpret_cast< ::game::JoinGameAsOwnerResponse&>(::game::_JoinGameAsOwnerResponse_default_instance_);
}
inline const ::game::JoinGameAsOwnerResponse& GameResponses::join_game_as_owner_response() const {
  // @@protoc_insertion_point(field_get:game.GameResponses.join_game_as_owner_response)
  return _internal_join_game_as_owner_response();
}
inline ::game::JoinGameAsOwnerResponse* GameResponses::unsafe_arena_release_join_game_as_owner_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameResponses.join_game_as_owner_response)
  if (_internal_has_join_game_as_owner_response()) {
    clear_has_responses();
    ::game::JoinGameAsOwnerResponse* temp = _impl_.responses_.join_game_as_owner_response_;
    _impl_.responses_.join_game_as_owner_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameResponses::unsafe_arena_set_allocated_join_game_as_owner_response(::game::JoinGameAsOwnerResponse* join_game_as_owner_response) {
  clear_responses();
  if (join_game_as_owner_response) {
    set_has_join_game_as_owner_response();
    _impl_.responses_.join_game_as_owner_response_ = join_game_as_owner_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameResponses.join_game_as_owner_response)
}
inline ::game::JoinGameAsOwnerResponse* GameResponses::_internal_mutable_join_game_as_owner_response() {
  if (!_internal_has_join_game_as_owner_response()) {
    clear_responses();
    set_has_join_game_as_owner_response();
    _impl_.responses_.join_game_as_owner_response_ = CreateMaybeMessage< ::game::JoinGameAsOwnerResponse >(GetArenaForAllocation());
  }
  return _impl_.responses_.join_game_as_owner_response_;
}
inline ::game::JoinGameAsOwnerResponse* GameResponses::mutable_join_game_as_owner_response() {
  ::game::JoinGameAsOwnerResponse* _msg = _internal_mutable_join_game_as_owner_response();
  // @@protoc_insertion_point(field_mutable:game.GameResponses.join_game_as_owner_response)
  return _msg;
}

inline bool GameResponses::has_responses() const {
  return responses_case() != RESPONSES_NOT_SET;
}
inline void GameResponses::clear_has_responses() {
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}
inline GameResponses::ResponsesCase GameResponses::responses_case() const {
  return GameResponses::ResponsesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// JoinGameRequest

// uint32 game_id = 1;
inline void JoinGameRequest::clear_game_id() {
  _impl_.game_id_ = 0u;
}
inline uint32_t JoinGameRequest::_internal_game_id() const {
  return _impl_.game_id_;
}
inline uint32_t JoinGameRequest::game_id() const {
  // @@protoc_insertion_point(field_get:game.JoinGameRequest.game_id)
  return _internal_game_id();
}
inline void JoinGameRequest::_internal_set_game_id(uint32_t value) {
  
  _impl_.game_id_ = value;
}
inline void JoinGameRequest::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:game.JoinGameRequest.game_id)
}

// string player_name = 2;
inline void JoinGameRequest::clear_player_name() {
  _impl_.player_name_.ClearToEmpty();
}
inline const std::string& JoinGameRequest::player_name() const {
  // @@protoc_insertion_point(field_get:game.JoinGameRequest.player_name)
  return _internal_player_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGameRequest::set_player_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.JoinGameRequest.player_name)
}
inline std::string* JoinGameRequest::mutable_player_name() {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:game.JoinGameRequest.player_name)
  return _s;
}
inline const std::string& JoinGameRequest::_internal_player_name() const {
  return _impl_.player_name_.Get();
}
inline void JoinGameRequest::_internal_set_player_name(const std::string& value) {
  
  _impl_.player_name_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGameRequest::_internal_mutable_player_name() {
  
  return _impl_.player_name_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGameRequest::release_player_name() {
  // @@protoc_insertion_point(field_release:game.JoinGameRequest.player_name)
  return _impl_.player_name_.Release();
}
inline void JoinGameRequest::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    
  } else {
    
  }
  _impl_.player_name_.SetAllocated(player_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_name_.IsDefault()) {
    _impl_.player_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.JoinGameRequest.player_name)
}

// .game.PlayerInfo player_info = 3;
inline bool JoinGameRequest::_internal_has_player_info() const {
  return this != internal_default_instance() && _impl_.player_info_ != nullptr;
}
inline bool JoinGameRequest::has_player_info() const {
  return _internal_has_player_info();
}
inline void JoinGameRequest::clear_player_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_info_ != nullptr) {
    delete _impl_.player_info_;
  }
  _impl_.player_info_ = nullptr;
}
inline const ::game::PlayerInfo& JoinGameRequest::_internal_player_info() const {
  const ::game::PlayerInfo* p = _impl_.player_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::PlayerInfo&>(
      ::game::_PlayerInfo_default_instance_);
}
inline const ::game::PlayerInfo& JoinGameRequest::player_info() const {
  // @@protoc_insertion_point(field_get:game.JoinGameRequest.player_info)
  return _internal_player_info();
}
inline void JoinGameRequest::unsafe_arena_set_allocated_player_info(
    ::game::PlayerInfo* player_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_info_);
  }
  _impl_.player_info_ = player_info;
  if (player_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.JoinGameRequest.player_info)
}
inline ::game::PlayerInfo* JoinGameRequest::release_player_info() {
  
  ::game::PlayerInfo* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::PlayerInfo* JoinGameRequest::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_release:game.JoinGameRequest.player_info)
  
  ::game::PlayerInfo* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
  return temp;
}
inline ::game::PlayerInfo* JoinGameRequest::_internal_mutable_player_info() {
  
  if (_impl_.player_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::PlayerInfo>(GetArenaForAllocation());
    _impl_.player_info_ = p;
  }
  return _impl_.player_info_;
}
inline ::game::PlayerInfo* JoinGameRequest::mutable_player_info() {
  ::game::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:game.JoinGameRequest.player_info)
  return _msg;
}
inline void JoinGameRequest::set_allocated_player_info(::game::PlayerInfo* player_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_info_;
  }
  if (player_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_info);
    if (message_arena != submessage_arena) {
      player_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:game.JoinGameRequest.player_info)
}

// -------------------------------------------------------------------

// JoinGameResponse

// .game.GameState game_state = 1;
inline bool JoinGameResponse::_internal_has_game_state() const {
  return this != internal_default_instance() && _impl_.game_state_ != nullptr;
}
inline bool JoinGameResponse::has_game_state() const {
  return _internal_has_game_state();
}
inline void JoinGameResponse::clear_game_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.game_state_ != nullptr) {
    delete _impl_.game_state_;
  }
  _impl_.game_state_ = nullptr;
}
inline const ::game::GameState& JoinGameResponse::_internal_game_state() const {
  const ::game::GameState* p = _impl_.game_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::GameState&>(
      ::game::_GameState_default_instance_);
}
inline const ::game::GameState& JoinGameResponse::game_state() const {
  // @@protoc_insertion_point(field_get:game.JoinGameResponse.game_state)
  return _internal_game_state();
}
inline void JoinGameResponse::unsafe_arena_set_allocated_game_state(
    ::game::GameState* game_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.game_state_);
  }
  _impl_.game_state_ = game_state;
  if (game_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.JoinGameResponse.game_state)
}
inline ::game::GameState* JoinGameResponse::release_game_state() {
  
  ::game::GameState* temp = _impl_.game_state_;
  _impl_.game_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::GameState* JoinGameResponse::unsafe_arena_release_game_state() {
  // @@protoc_insertion_point(field_release:game.JoinGameResponse.game_state)
  
  ::game::GameState* temp = _impl_.game_state_;
  _impl_.game_state_ = nullptr;
  return temp;
}
inline ::game::GameState* JoinGameResponse::_internal_mutable_game_state() {
  
  if (_impl_.game_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::GameState>(GetArenaForAllocation());
    _impl_.game_state_ = p;
  }
  return _impl_.game_state_;
}
inline ::game::GameState* JoinGameResponse::mutable_game_state() {
  ::game::GameState* _msg = _internal_mutable_game_state();
  // @@protoc_insertion_point(field_mutable:game.JoinGameResponse.game_state)
  return _msg;
}
inline void JoinGameResponse::set_allocated_game_state(::game::GameState* game_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.game_state_;
  }
  if (game_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(game_state);
    if (message_arena != submessage_arena) {
      game_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.game_state_ = game_state;
  // @@protoc_insertion_point(field_set_allocated:game.JoinGameResponse.game_state)
}

// .game.ErrorMessage msg = 2;
inline bool JoinGameResponse::_internal_has_msg() const {
  return this != internal_default_instance() && _impl_.msg_ != nullptr;
}
inline bool JoinGameResponse::has_msg() const {
  return _internal_has_msg();
}
inline void JoinGameResponse::clear_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.msg_ != nullptr) {
    delete _impl_.msg_;
  }
  _impl_.msg_ = nullptr;
}
inline const ::game::ErrorMessage& JoinGameResponse::_internal_msg() const {
  const ::game::ErrorMessage* p = _impl_.msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::ErrorMessage&>(
      ::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& JoinGameResponse::msg() const {
  // @@protoc_insertion_point(field_get:game.JoinGameResponse.msg)
  return _internal_msg();
}
inline void JoinGameResponse::unsafe_arena_set_allocated_msg(
    ::game::ErrorMessage* msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msg_);
  }
  _impl_.msg_ = msg;
  if (msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.JoinGameResponse.msg)
}
inline ::game::ErrorMessage* JoinGameResponse::release_msg() {
  
  ::game::ErrorMessage* temp = _impl_.msg_;
  _impl_.msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::ErrorMessage* JoinGameResponse::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_release:game.JoinGameResponse.msg)
  
  ::game::ErrorMessage* temp = _impl_.msg_;
  _impl_.msg_ = nullptr;
  return temp;
}
inline ::game::ErrorMessage* JoinGameResponse::_internal_mutable_msg() {
  
  if (_impl_.msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::ErrorMessage>(GetArenaForAllocation());
    _impl_.msg_ = p;
  }
  return _impl_.msg_;
}
inline ::game::ErrorMessage* JoinGameResponse::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.JoinGameResponse.msg)
  return _msg;
}
inline void JoinGameResponse::set_allocated_msg(::game::ErrorMessage* msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.msg_;
  }
  if (msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg);
    if (message_arena != submessage_arena) {
      msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:game.JoinGameResponse.msg)
}

// -------------------------------------------------------------------

// JoinGameAsOwnerRequest

// uint32 game_id = 1;
inline void JoinGameAsOwnerRequest::clear_game_id() {
  _impl_.game_id_ = 0u;
}
inline uint32_t JoinGameAsOwnerRequest::_internal_game_id() const {
  return _impl_.game_id_;
}
inline uint32_t JoinGameAsOwnerRequest::game_id() const {
  // @@protoc_insertion_point(field_get:game.JoinGameAsOwnerRequest.game_id)
  return _internal_game_id();
}
inline void JoinGameAsOwnerRequest::_internal_set_game_id(uint32_t value) {
  
  _impl_.game_id_ = value;
}
inline void JoinGameAsOwnerRequest::set_game_id(uint32_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:game.JoinGameAsOwnerRequest.game_id)
}

// string player_name = 2;
inline void JoinGameAsOwnerRequest::clear_player_name() {
  _impl_.player_name_.ClearToEmpty();
}
inline const std::string& JoinGameAsOwnerRequest::player_name() const {
  // @@protoc_insertion_point(field_get:game.JoinGameAsOwnerRequest.player_name)
  return _internal_player_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinGameAsOwnerRequest::set_player_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.JoinGameAsOwnerRequest.player_name)
}
inline std::string* JoinGameAsOwnerRequest::mutable_player_name() {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:game.JoinGameAsOwnerRequest.player_name)
  return _s;
}
inline const std::string& JoinGameAsOwnerRequest::_internal_player_name() const {
  return _impl_.player_name_.Get();
}
inline void JoinGameAsOwnerRequest::_internal_set_player_name(const std::string& value) {
  
  _impl_.player_name_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinGameAsOwnerRequest::_internal_mutable_player_name() {
  
  return _impl_.player_name_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinGameAsOwnerRequest::release_player_name() {
  // @@protoc_insertion_point(field_release:game.JoinGameAsOwnerRequest.player_name)
  return _impl_.player_name_.Release();
}
inline void JoinGameAsOwnerRequest::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    
  } else {
    
  }
  _impl_.player_name_.SetAllocated(player_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_name_.IsDefault()) {
    _impl_.player_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.JoinGameAsOwnerRequest.player_name)
}

// .game.PlayerInfo player_info = 3;
inline bool JoinGameAsOwnerRequest::_internal_has_player_info() const {
  return this != internal_default_instance() && _impl_.player_info_ != nullptr;
}
inline bool JoinGameAsOwnerRequest::has_player_info() const {
  return _internal_has_player_info();
}
inline void JoinGameAsOwnerRequest::clear_player_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_info_ != nullptr) {
    delete _impl_.player_info_;
  }
  _impl_.player_info_ = nullptr;
}
inline const ::game::PlayerInfo& JoinGameAsOwnerRequest::_internal_player_info() const {
  const ::game::PlayerInfo* p = _impl_.player_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::PlayerInfo&>(
      ::game::_PlayerInfo_default_instance_);
}
inline const ::game::PlayerInfo& JoinGameAsOwnerRequest::player_info() const {
  // @@protoc_insertion_point(field_get:game.JoinGameAsOwnerRequest.player_info)
  return _internal_player_info();
}
inline void JoinGameAsOwnerRequest::unsafe_arena_set_allocated_player_info(
    ::game::PlayerInfo* player_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_info_);
  }
  _impl_.player_info_ = player_info;
  if (player_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.JoinGameAsOwnerRequest.player_info)
}
inline ::game::PlayerInfo* JoinGameAsOwnerRequest::release_player_info() {
  
  ::game::PlayerInfo* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::PlayerInfo* JoinGameAsOwnerRequest::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_release:game.JoinGameAsOwnerRequest.player_info)
  
  ::game::PlayerInfo* temp = _impl_.player_info_;
  _impl_.player_info_ = nullptr;
  return temp;
}
inline ::game::PlayerInfo* JoinGameAsOwnerRequest::_internal_mutable_player_info() {
  
  if (_impl_.player_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::PlayerInfo>(GetArenaForAllocation());
    _impl_.player_info_ = p;
  }
  return _impl_.player_info_;
}
inline ::game::PlayerInfo* JoinGameAsOwnerRequest::mutable_player_info() {
  ::game::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:game.JoinGameAsOwnerRequest.player_info)
  return _msg;
}
inline void JoinGameAsOwnerRequest::set_allocated_player_info(::game::PlayerInfo* player_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_info_;
  }
  if (player_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_info);
    if (message_arena != submessage_arena) {
      player_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:game.JoinGameAsOwnerRequest.player_info)
}

// -------------------------------------------------------------------

// JoinGameAsOwnerResponse

// .game.GameState game_state = 1;
inline bool JoinGameAsOwnerResponse::_internal_has_game_state() const {
  return this != internal_default_instance() && _impl_.game_state_ != nullptr;
}
inline bool JoinGameAsOwnerResponse::has_game_state() const {
  return _internal_has_game_state();
}
inline void JoinGameAsOwnerResponse::clear_game_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.game_state_ != nullptr) {
    delete _impl_.game_state_;
  }
  _impl_.game_state_ = nullptr;
}
inline const ::game::GameState& JoinGameAsOwnerResponse::_internal_game_state() const {
  const ::game::GameState* p = _impl_.game_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::GameState&>(
      ::game::_GameState_default_instance_);
}
inline const ::game::GameState& JoinGameAsOwnerResponse::game_state() const {
  // @@protoc_insertion_point(field_get:game.JoinGameAsOwnerResponse.game_state)
  return _internal_game_state();
}
inline void JoinGameAsOwnerResponse::unsafe_arena_set_allocated_game_state(
    ::game::GameState* game_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.game_state_);
  }
  _impl_.game_state_ = game_state;
  if (game_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.JoinGameAsOwnerResponse.game_state)
}
inline ::game::GameState* JoinGameAsOwnerResponse::release_game_state() {
  
  ::game::GameState* temp = _impl_.game_state_;
  _impl_.game_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::GameState* JoinGameAsOwnerResponse::unsafe_arena_release_game_state() {
  // @@protoc_insertion_point(field_release:game.JoinGameAsOwnerResponse.game_state)
  
  ::game::GameState* temp = _impl_.game_state_;
  _impl_.game_state_ = nullptr;
  return temp;
}
inline ::game::GameState* JoinGameAsOwnerResponse::_internal_mutable_game_state() {
  
  if (_impl_.game_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::GameState>(GetArenaForAllocation());
    _impl_.game_state_ = p;
  }
  return _impl_.game_state_;
}
inline ::game::GameState* JoinGameAsOwnerResponse::mutable_game_state() {
  ::game::GameState* _msg = _internal_mutable_game_state();
  // @@protoc_insertion_point(field_mutable:game.JoinGameAsOwnerResponse.game_state)
  return _msg;
}
inline void JoinGameAsOwnerResponse::set_allocated_game_state(::game::GameState* game_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.game_state_;
  }
  if (game_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(game_state);
    if (message_arena != submessage_arena) {
      game_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.game_state_ = game_state;
  // @@protoc_insertion_point(field_set_allocated:game.JoinGameAsOwnerResponse.game_state)
}

// .game.ErrorMessage msg = 2;
inline bool JoinGameAsOwnerResponse::_internal_has_msg() const {
  return this != internal_default_instance() && _impl_.msg_ != nullptr;
}
inline bool JoinGameAsOwnerResponse::has_msg() const {
  return _internal_has_msg();
}
inline void JoinGameAsOwnerResponse::clear_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.msg_ != nullptr) {
    delete _impl_.msg_;
  }
  _impl_.msg_ = nullptr;
}
inline const ::game::ErrorMessage& JoinGameAsOwnerResponse::_internal_msg() const {
  const ::game::ErrorMessage* p = _impl_.msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::ErrorMessage&>(
      ::game::_ErrorMessage_default_instance_);
}
inline const ::game::ErrorMessage& JoinGameAsOwnerResponse::msg() const {
  // @@protoc_insertion_point(field_get:game.JoinGameAsOwnerResponse.msg)
  return _internal_msg();
}
inline void JoinGameAsOwnerResponse::unsafe_arena_set_allocated_msg(
    ::game::ErrorMessage* msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msg_);
  }
  _impl_.msg_ = msg;
  if (msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.JoinGameAsOwnerResponse.msg)
}
inline ::game::ErrorMessage* JoinGameAsOwnerResponse::release_msg() {
  
  ::game::ErrorMessage* temp = _impl_.msg_;
  _impl_.msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::game::ErrorMessage* JoinGameAsOwnerResponse::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_release:game.JoinGameAsOwnerResponse.msg)
  
  ::game::ErrorMessage* temp = _impl_.msg_;
  _impl_.msg_ = nullptr;
  return temp;
}
inline ::game::ErrorMessage* JoinGameAsOwnerResponse::_internal_mutable_msg() {
  
  if (_impl_.msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::ErrorMessage>(GetArenaForAllocation());
    _impl_.msg_ = p;
  }
  return _impl_.msg_;
}
inline ::game::ErrorMessage* JoinGameAsOwnerResponse::mutable_msg() {
  ::game::ErrorMessage* _msg = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:game.JoinGameAsOwnerResponse.msg)
  return _msg;
}
inline void JoinGameAsOwnerResponse::set_allocated_msg(::game::ErrorMessage* msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.msg_;
  }
  if (msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg);
    if (message_arena != submessage_arena) {
      msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:game.JoinGameAsOwnerResponse.msg)
}

// -------------------------------------------------------------------

// GameState

// repeated .game.Card player_cards = 1;
inline int GameState::_internal_player_cards_size() const {
  return _impl_.player_cards_.size();
}
inline int GameState::player_cards_size() const {
  return _internal_player_cards_size();
}
inline void GameState::clear_player_cards() {
  _impl_.player_cards_.Clear();
}
inline ::game::Card* GameState::mutable_player_cards(int index) {
  // @@protoc_insertion_point(field_mutable:game.GameState.player_cards)
  return _impl_.player_cards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card >*
GameState::mutable_player_cards() {
  // @@protoc_insertion_point(field_mutable_list:game.GameState.player_cards)
  return &_impl_.player_cards_;
}
inline const ::game::Card& GameState::_internal_player_cards(int index) const {
  return _impl_.player_cards_.Get(index);
}
inline const ::game::Card& GameState::player_cards(int index) const {
  // @@protoc_insertion_point(field_get:game.GameState.player_cards)
  return _internal_player_cards(index);
}
inline ::game::Card* GameState::_internal_add_player_cards() {
  return _impl_.player_cards_.Add();
}
inline ::game::Card* GameState::add_player_cards() {
  ::game::Card* _add = _internal_add_player_cards();
  // @@protoc_insertion_point(field_add:game.GameState.player_cards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card >&
GameState::player_cards() const {
  // @@protoc_insertion_point(field_list:game.GameState.player_cards)
  return _impl_.player_cards_;
}

// repeated .game.Card board_cards = 2;
inline int GameState::_internal_board_cards_size() const {
  return _impl_.board_cards_.size();
}
inline int GameState::board_cards_size() const {
  return _internal_board_cards_size();
}
inline void GameState::clear_board_cards() {
  _impl_.board_cards_.Clear();
}
inline ::game::Card* GameState::mutable_board_cards(int index) {
  // @@protoc_insertion_point(field_mutable:game.GameState.board_cards)
  return _impl_.board_cards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card >*
GameState::mutable_board_cards() {
  // @@protoc_insertion_point(field_mutable_list:game.GameState.board_cards)
  return &_impl_.board_cards_;
}
inline const ::game::Card& GameState::_internal_board_cards(int index) const {
  return _impl_.board_cards_.Get(index);
}
inline const ::game::Card& GameState::board_cards(int index) const {
  // @@protoc_insertion_point(field_get:game.GameState.board_cards)
  return _internal_board_cards(index);
}
inline ::game::Card* GameState::_internal_add_board_cards() {
  return _impl_.board_cards_.Add();
}
inline ::game::Card* GameState::add_board_cards() {
  ::game::Card* _add = _internal_add_board_cards();
  // @@protoc_insertion_point(field_add:game.GameState.board_cards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Card >&
GameState::board_cards() const {
  // @@protoc_insertion_point(field_list:game.GameState.board_cards)
  return _impl_.board_cards_;
}

// repeated .game.Player players = 3;
inline int GameState::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int GameState::players_size() const {
  return _internal_players_size();
}
inline void GameState::clear_players() {
  _impl_.players_.Clear();
}
inline ::game::Player* GameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:game.GameState.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >*
GameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:game.GameState.players)
  return &_impl_.players_;
}
inline const ::game::Player& GameState::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::game::Player& GameState::players(int index) const {
  // @@protoc_insertion_point(field_get:game.GameState.players)
  return _internal_players(index);
}
inline ::game::Player* GameState::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::game::Player* GameState::add_players() {
  ::game::Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:game.GameState.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::game::Player >&
GameState::players() const {
  // @@protoc_insertion_point(field_list:game.GameState.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// MakeMoveRequest

// uint32 player_id = 1;
inline void MakeMoveRequest::clear_player_id() {
  _impl_.player_id_ = 0u;
}
inline uint32_t MakeMoveRequest::_internal_player_id() const {
  return _impl_.player_id_;
}
inline uint32_t MakeMoveRequest::player_id() const {
  // @@protoc_insertion_point(field_get:game.MakeMoveRequest.player_id)
  return _internal_player_id();
}
inline void MakeMoveRequest::_internal_set_player_id(uint32_t value) {
  
  _impl_.player_id_ = value;
}
inline void MakeMoveRequest::set_player_id(uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:game.MakeMoveRequest.player_id)
}

// .game.MoveType move_type = 2;
inline void MakeMoveRequest::clear_move_type() {
  _impl_.move_type_ = 0;
}
inline ::game::MoveType MakeMoveRequest::_internal_move_type() const {
  return static_cast< ::game::MoveType >(_impl_.move_type_);
}
inline ::game::MoveType MakeMoveRequest::move_type() const {
  // @@protoc_insertion_point(field_get:game.MakeMoveRequest.move_type)
  return _internal_move_type();
}
inline void MakeMoveRequest::_internal_set_move_type(::game::MoveType value) {
  
  _impl_.move_type_ = value;
}
inline void MakeMoveRequest::set_move_type(::game::MoveType value) {
  _internal_set_move_type(value);
  // @@protoc_insertion_point(field_set:game.MakeMoveRequest.move_type)
}

// optional uint32 blind_size = 3;
inline bool MakeMoveRequest::_internal_has_blind_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MakeMoveRequest::has_blind_size() const {
  return _internal_has_blind_size();
}
inline void MakeMoveRequest::clear_blind_size() {
  _impl_.blind_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MakeMoveRequest::_internal_blind_size() const {
  return _impl_.blind_size_;
}
inline uint32_t MakeMoveRequest::blind_size() const {
  // @@protoc_insertion_point(field_get:game.MakeMoveRequest.blind_size)
  return _internal_blind_size();
}
inline void MakeMoveRequest::_internal_set_blind_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blind_size_ = value;
}
inline void MakeMoveRequest::set_blind_size(uint32_t value) {
  _internal_set_blind_size(value);
  // @@protoc_insertion_point(field_set:game.MakeMoveRequest.blind_size)
}

// -------------------------------------------------------------------

// MakeMoveResponse

// -------------------------------------------------------------------

// Card

// .game.Suits suit = 1;
inline void Card::clear_suit() {
  _impl_.suit_ = 0;
}
inline ::game::Suits Card::_internal_suit() const {
  return static_cast< ::game::Suits >(_impl_.suit_);
}
inline ::game::Suits Card::suit() const {
  // @@protoc_insertion_point(field_get:game.Card.suit)
  return _internal_suit();
}
inline void Card::_internal_set_suit(::game::Suits value) {
  
  _impl_.suit_ = value;
}
inline void Card::set_suit(::game::Suits value) {
  _internal_set_suit(value);
  // @@protoc_insertion_point(field_set:game.Card.suit)
}

// .game.Values value = 2;
inline void Card::clear_value() {
  _impl_.value_ = 0;
}
inline ::game::Values Card::_internal_value() const {
  return static_cast< ::game::Values >(_impl_.value_);
}
inline ::game::Values Card::value() const {
  // @@protoc_insertion_point(field_get:game.Card.value)
  return _internal_value();
}
inline void Card::_internal_set_value(::game::Values value) {
  
  _impl_.value_ = value;
}
inline void Card::set_value(::game::Values value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:game.Card.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace game

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::game::error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::error>() {
  return ::game::error_descriptor();
}
template <> struct is_proto_enum< ::game::PlayerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::PlayerStatus>() {
  return ::game::PlayerStatus_descriptor();
}
template <> struct is_proto_enum< ::game::MoveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::MoveType>() {
  return ::game::MoveType_descriptor();
}
template <> struct is_proto_enum< ::game::Suits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::Suits>() {
  return ::game::Suits_descriptor();
}
template <> struct is_proto_enum< ::game::Values> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::Values>() {
  return ::game::Values_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_game_2eproto
