// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#include "game.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace game {
PROTOBUF_CONSTEXPR ErrorMessage::ErrorMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/0} {}
struct ErrorMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ErrorMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ErrorMessageDefaultTypeInternal() {}
  union {
    ErrorMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ErrorMessageDefaultTypeInternal _ErrorMessage_default_instance_;
PROTOBUF_CONSTEXPR LoginRequest::LoginRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.login_requests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LoginRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginRequestDefaultTypeInternal() {}
  union {
    LoginRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
PROTOBUF_CONSTEXPR LoginResponse::LoginResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.login_responses_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LoginResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginResponseDefaultTypeInternal() {}
  union {
    LoginResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
PROTOBUF_CONSTEXPR LoginRequestFirst::LoginRequestFirst(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginRequestFirstDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginRequestFirstDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginRequestFirstDefaultTypeInternal() {}
  union {
    LoginRequestFirst _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginRequestFirstDefaultTypeInternal _LoginRequestFirst_default_instance_;
PROTOBUF_CONSTEXPR LoginRequestSecond::LoginRequestSecond(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hashed_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginRequestSecondDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginRequestSecondDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginRequestSecondDefaultTypeInternal() {}
  union {
    LoginRequestSecond _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginRequestSecondDefaultTypeInternal _LoginRequestSecond_default_instance_;
PROTOBUF_CONSTEXPR LoginResponseFirst::LoginResponseFirst(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.login_responses_first_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LoginResponseFirstDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginResponseFirstDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginResponseFirstDefaultTypeInternal() {}
  union {
    LoginResponseFirst _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginResponseFirstDefaultTypeInternal _LoginResponseFirst_default_instance_;
PROTOBUF_CONSTEXPR LoginResponseSecond::LoginResponseSecond(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.login_responses_second_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LoginResponseSecondDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginResponseSecondDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginResponseSecondDefaultTypeInternal() {}
  union {
    LoginResponseSecond _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginResponseSecondDefaultTypeInternal _LoginResponseSecond_default_instance_;
PROTOBUF_CONSTEXPR RegisterRequest::RegisterRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.salt_hash_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RegisterRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegisterRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegisterRequestDefaultTypeInternal() {}
  union {
    RegisterRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
PROTOBUF_CONSTEXPR RegisterResponse::RegisterResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.register_responses_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RegisterResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegisterResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegisterResponseDefaultTypeInternal() {}
  union {
    RegisterResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
PROTOBUF_CONSTEXPR SaltHash::SaltHash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.salt_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SaltHashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaltHashDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaltHashDefaultTypeInternal() {}
  union {
    SaltHash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaltHashDefaultTypeInternal _SaltHash_default_instance_;
PROTOBUF_CONSTEXPR Player::Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_.balance_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerDefaultTypeInternal() {}
  union {
    Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerDefaultTypeInternal _Player_default_instance_;
PROTOBUF_CONSTEXPR LobbyRequests::LobbyRequests(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LobbyRequestsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LobbyRequestsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LobbyRequestsDefaultTypeInternal() {}
  union {
    LobbyRequests _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LobbyRequestsDefaultTypeInternal _LobbyRequests_default_instance_;
PROTOBUF_CONSTEXPR LobbyResponses::LobbyResponses(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.responses_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LobbyResponsesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LobbyResponsesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LobbyResponsesDefaultTypeInternal() {}
  union {
    LobbyResponses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LobbyResponsesDefaultTypeInternal _LobbyResponses_default_instance_;
PROTOBUF_CONSTEXPR CreateGameRequest::CreateGameRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.game_parameters_)*/nullptr
  , /*decltype(_impl_.game_owner_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateGameRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateGameRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateGameRequestDefaultTypeInternal() {}
  union {
    CreateGameRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateGameRequestDefaultTypeInternal _CreateGameRequest_default_instance_;
PROTOBUF_CONSTEXPR CreateGameResponse::CreateGameResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.responses_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CreateGameResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateGameResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateGameResponseDefaultTypeInternal() {}
  union {
    CreateGameResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateGameResponseDefaultTypeInternal _CreateGameResponse_default_instance_;
PROTOBUF_CONSTEXPR SearchGameRequest::SearchGameRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.game_parameters_)*/nullptr
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SearchGameRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SearchGameRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SearchGameRequestDefaultTypeInternal() {}
  union {
    SearchGameRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SearchGameRequestDefaultTypeInternal _SearchGameRequest_default_instance_;
PROTOBUF_CONSTEXPR SearchGameResponse::SearchGameResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.responses_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SearchGameResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SearchGameResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SearchGameResponseDefaultTypeInternal() {}
  union {
    SearchGameResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SearchGameResponseDefaultTypeInternal _SearchGameResponse_default_instance_;
PROTOBUF_CONSTEXPR GameParameters::GameParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.game_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.number_of_players_)*/0u
  , /*decltype(_impl_.minimal_bet_)*/0u
  , /*decltype(_impl_.game_enter_balance_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GameParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameParametersDefaultTypeInternal() {}
  union {
    GameParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameParametersDefaultTypeInternal _GameParameters_default_instance_;
PROTOBUF_CONSTEXPR PlayerInfo::PlayerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.client_id_)*/0u
  , /*decltype(_impl_.client_games_)*/0u
  , /*decltype(_impl_.client_wins_)*/0u
  , /*decltype(_impl_.client_balance_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerInfoDefaultTypeInternal() {}
  union {
    PlayerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
PROTOBUF_CONSTEXPR GameRequests::GameRequests(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct GameRequestsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameRequestsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameRequestsDefaultTypeInternal() {}
  union {
    GameRequests _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameRequestsDefaultTypeInternal _GameRequests_default_instance_;
PROTOBUF_CONSTEXPR GameResponses::GameResponses(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.responses_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct GameResponsesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameResponsesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameResponsesDefaultTypeInternal() {}
  union {
    GameResponses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameResponsesDefaultTypeInternal _GameResponses_default_instance_;
PROTOBUF_CONSTEXPR JoinGameRequest::JoinGameRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.player_info_)*/nullptr
  , /*decltype(_impl_.game_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct JoinGameRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinGameRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinGameRequestDefaultTypeInternal() {}
  union {
    JoinGameRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinGameRequestDefaultTypeInternal _JoinGameRequest_default_instance_;
PROTOBUF_CONSTEXPR JoinGameResponse::JoinGameResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.game_state_)*/nullptr
  , /*decltype(_impl_.msg_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct JoinGameResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinGameResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinGameResponseDefaultTypeInternal() {}
  union {
    JoinGameResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinGameResponseDefaultTypeInternal _JoinGameResponse_default_instance_;
PROTOBUF_CONSTEXPR JoinGameAsOwnerRequest::JoinGameAsOwnerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.player_info_)*/nullptr
  , /*decltype(_impl_.game_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct JoinGameAsOwnerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinGameAsOwnerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinGameAsOwnerRequestDefaultTypeInternal() {}
  union {
    JoinGameAsOwnerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinGameAsOwnerRequestDefaultTypeInternal _JoinGameAsOwnerRequest_default_instance_;
PROTOBUF_CONSTEXPR JoinGameAsOwnerResponse::JoinGameAsOwnerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.game_state_)*/nullptr
  , /*decltype(_impl_.msg_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct JoinGameAsOwnerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinGameAsOwnerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinGameAsOwnerResponseDefaultTypeInternal() {}
  union {
    JoinGameAsOwnerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinGameAsOwnerResponseDefaultTypeInternal _JoinGameAsOwnerResponse_default_instance_;
PROTOBUF_CONSTEXPR GameState::GameState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_cards_)*/{}
  , /*decltype(_impl_.board_cards_)*/{}
  , /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GameStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameStateDefaultTypeInternal() {}
  union {
    GameState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameStateDefaultTypeInternal _GameState_default_instance_;
PROTOBUF_CONSTEXPR MakeMoveRequest::MakeMoveRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/0u
  , /*decltype(_impl_.move_type_)*/0
  , /*decltype(_impl_.blind_size_)*/0u} {}
struct MakeMoveRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MakeMoveRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MakeMoveRequestDefaultTypeInternal() {}
  union {
    MakeMoveRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MakeMoveRequestDefaultTypeInternal _MakeMoveRequest_default_instance_;
PROTOBUF_CONSTEXPR MakeMoveResponse::MakeMoveResponse(
    ::_pbi::ConstantInitialized) {}
struct MakeMoveResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MakeMoveResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MakeMoveResponseDefaultTypeInternal() {}
  union {
    MakeMoveResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MakeMoveResponseDefaultTypeInternal _MakeMoveResponse_default_instance_;
PROTOBUF_CONSTEXPR Card::Card(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.suit_)*/0
  , /*decltype(_impl_.value_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CardDefaultTypeInternal() {}
  union {
    Card _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CardDefaultTypeInternal _Card_default_instance_;
}  // namespace game
static ::_pb::Metadata file_level_metadata_game_2eproto[29];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_game_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_game_2eproto = nullptr;

const uint32_t TableStruct_game_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::game::ErrorMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::ErrorMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::ErrorMessage, _impl_.error_),
  PROTOBUF_FIELD_OFFSET(::game::ErrorMessage, _impl_.message_string_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::LoginRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::LoginRequest, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::LoginRequest, _impl_.login_requests_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::LoginResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::LoginResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::LoginResponse, _impl_.login_responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::LoginRequestFirst, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::LoginRequestFirst, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::LoginRequestSecond, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::LoginRequestSecond, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::game::LoginRequestSecond, _impl_.hashed_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::LoginResponseFirst, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::LoginResponseFirst, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::LoginResponseFirst, _impl_.login_responses_first_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::LoginResponseSecond, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::LoginResponseSecond, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::LoginResponseSecond, _impl_.login_responses_second_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::RegisterRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::RegisterRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::game::RegisterRequest, _impl_.salt_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::RegisterResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::RegisterResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::RegisterResponse, _impl_.register_responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::SaltHash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::SaltHash, _impl_.salt_),
  PROTOBUF_FIELD_OFFSET(::game::SaltHash, _impl_.hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::Player, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::game::Player, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::game::Player, _impl_.balance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::LobbyRequests, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::LobbyRequests, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::LobbyRequests, _impl_.requests_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::LobbyResponses, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::LobbyResponses, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::LobbyResponses, _impl_.responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::CreateGameRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::CreateGameRequest, _impl_.game_owner_id_),
  PROTOBUF_FIELD_OFFSET(::game::CreateGameRequest, _impl_.game_parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::CreateGameResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::CreateGameResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::CreateGameResponse, _impl_.responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::SearchGameRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::SearchGameRequest, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::game::SearchGameRequest, _impl_.game_parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::SearchGameResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::SearchGameResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::SearchGameResponse, _impl_.responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::GameParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::GameParameters, _impl_.game_name_),
  PROTOBUF_FIELD_OFFSET(::game::GameParameters, _impl_.number_of_players_),
  PROTOBUF_FIELD_OFFSET(::game::GameParameters, _impl_.minimal_bet_),
  PROTOBUF_FIELD_OFFSET(::game::GameParameters, _impl_.game_enter_balance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::PlayerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::PlayerInfo, _impl_.client_id_),
  PROTOBUF_FIELD_OFFSET(::game::PlayerInfo, _impl_.client_games_),
  PROTOBUF_FIELD_OFFSET(::game::PlayerInfo, _impl_.client_wins_),
  PROTOBUF_FIELD_OFFSET(::game::PlayerInfo, _impl_.client_balance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::GameRequests, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::GameRequests, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::GameRequests, _impl_.requests_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::GameResponses, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::game::GameResponses, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::game::GameResponses, _impl_.responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::JoinGameRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::JoinGameRequest, _impl_.game_id_),
  PROTOBUF_FIELD_OFFSET(::game::JoinGameRequest, _impl_.player_name_),
  PROTOBUF_FIELD_OFFSET(::game::JoinGameRequest, _impl_.player_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::JoinGameResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::JoinGameResponse, _impl_.game_state_),
  PROTOBUF_FIELD_OFFSET(::game::JoinGameResponse, _impl_.msg_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::JoinGameAsOwnerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::JoinGameAsOwnerRequest, _impl_.game_id_),
  PROTOBUF_FIELD_OFFSET(::game::JoinGameAsOwnerRequest, _impl_.player_name_),
  PROTOBUF_FIELD_OFFSET(::game::JoinGameAsOwnerRequest, _impl_.player_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::JoinGameAsOwnerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::JoinGameAsOwnerResponse, _impl_.game_state_),
  PROTOBUF_FIELD_OFFSET(::game::JoinGameAsOwnerResponse, _impl_.msg_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::GameState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::GameState, _impl_.player_cards_),
  PROTOBUF_FIELD_OFFSET(::game::GameState, _impl_.board_cards_),
  PROTOBUF_FIELD_OFFSET(::game::GameState, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::game::MakeMoveRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::MakeMoveRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::MakeMoveRequest, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::game::MakeMoveRequest, _impl_.move_type_),
  PROTOBUF_FIELD_OFFSET(::game::MakeMoveRequest, _impl_.blind_size_),
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::MakeMoveResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::Card, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::Card, _impl_.suit_),
  PROTOBUF_FIELD_OFFSET(::game::Card, _impl_.value_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::game::ErrorMessage)},
  { 10, -1, -1, sizeof(::game::LoginRequest)},
  { 19, -1, -1, sizeof(::game::LoginResponse)},
  { 28, -1, -1, sizeof(::game::LoginRequestFirst)},
  { 35, -1, -1, sizeof(::game::LoginRequestSecond)},
  { 43, -1, -1, sizeof(::game::LoginResponseFirst)},
  { 52, -1, -1, sizeof(::game::LoginResponseSecond)},
  { 61, -1, -1, sizeof(::game::RegisterRequest)},
  { 69, -1, -1, sizeof(::game::RegisterResponse)},
  { 78, -1, -1, sizeof(::game::SaltHash)},
  { 86, -1, -1, sizeof(::game::Player)},
  { 95, -1, -1, sizeof(::game::LobbyRequests)},
  { 104, -1, -1, sizeof(::game::LobbyResponses)},
  { 113, -1, -1, sizeof(::game::CreateGameRequest)},
  { 121, -1, -1, sizeof(::game::CreateGameResponse)},
  { 130, -1, -1, sizeof(::game::SearchGameRequest)},
  { 138, -1, -1, sizeof(::game::SearchGameResponse)},
  { 147, -1, -1, sizeof(::game::GameParameters)},
  { 157, -1, -1, sizeof(::game::PlayerInfo)},
  { 167, -1, -1, sizeof(::game::GameRequests)},
  { 177, -1, -1, sizeof(::game::GameResponses)},
  { 188, -1, -1, sizeof(::game::JoinGameRequest)},
  { 197, -1, -1, sizeof(::game::JoinGameResponse)},
  { 205, -1, -1, sizeof(::game::JoinGameAsOwnerRequest)},
  { 214, -1, -1, sizeof(::game::JoinGameAsOwnerResponse)},
  { 222, -1, -1, sizeof(::game::GameState)},
  { 231, 240, -1, sizeof(::game::MakeMoveRequest)},
  { 243, -1, -1, sizeof(::game::MakeMoveResponse)},
  { 249, -1, -1, sizeof(::game::Card)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::game::_ErrorMessage_default_instance_._instance,
  &::game::_LoginRequest_default_instance_._instance,
  &::game::_LoginResponse_default_instance_._instance,
  &::game::_LoginRequestFirst_default_instance_._instance,
  &::game::_LoginRequestSecond_default_instance_._instance,
  &::game::_LoginResponseFirst_default_instance_._instance,
  &::game::_LoginResponseSecond_default_instance_._instance,
  &::game::_RegisterRequest_default_instance_._instance,
  &::game::_RegisterResponse_default_instance_._instance,
  &::game::_SaltHash_default_instance_._instance,
  &::game::_Player_default_instance_._instance,
  &::game::_LobbyRequests_default_instance_._instance,
  &::game::_LobbyResponses_default_instance_._instance,
  &::game::_CreateGameRequest_default_instance_._instance,
  &::game::_CreateGameResponse_default_instance_._instance,
  &::game::_SearchGameRequest_default_instance_._instance,
  &::game::_SearchGameResponse_default_instance_._instance,
  &::game::_GameParameters_default_instance_._instance,
  &::game::_PlayerInfo_default_instance_._instance,
  &::game::_GameRequests_default_instance_._instance,
  &::game::_GameResponses_default_instance_._instance,
  &::game::_JoinGameRequest_default_instance_._instance,
  &::game::_JoinGameResponse_default_instance_._instance,
  &::game::_JoinGameAsOwnerRequest_default_instance_._instance,
  &::game::_JoinGameAsOwnerResponse_default_instance_._instance,
  &::game::_GameState_default_instance_._instance,
  &::game::_MakeMoveRequest_default_instance_._instance,
  &::game::_MakeMoveResponse_default_instance_._instance,
  &::game::_Card_default_instance_._instance,
};

const char descriptor_table_protodef_game_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ngame.proto\022\004game\"Z\n\014ErrorMessage\022\032\n\005er"
  "ror\030\001 \001(\0162\013.game.error\022\033\n\016message_string"
  "\030\002 \001(\tH\000\210\001\001B\021\n\017_message_string\"\222\001\n\014Login"
  "Request\0226\n\023login_request_first\030\001 \001(\0132\027.g"
  "ame.LoginRequestFirstH\000\0228\n\024login_request"
  "_second\030\002 \001(\0132\030.game.LoginRequestSecondH"
  "\000B\020\n\016login_requests\"\230\001\n\rLoginResponse\0228\n"
  "\024login_response_first\030\001 \001(\0132\030.game.Login"
  "ResponseFirstH\000\022:\n\025login_response_second"
  "\030\002 \001(\0132\031.game.LoginResponseSecondH\000B\021\n\017l"
  "ogin_responses\"!\n\021LoginRequestFirst\022\014\n\004n"
  "ame\030\001 \001(\t\"2\n\022LoginRequestSecond\022\014\n\004name\030"
  "\001 \001(\t\022\016\n\006hashed\030\002 \001(\t\"`\n\022LoginResponseFi"
  "rst\022\016\n\004salt\030\001 \001(\tH\000\022!\n\003msg\030\002 \001(\0132\022.game."
  "ErrorMessageH\000B\027\n\025login_responses_first\""
  "{\n\023LoginResponseSecond\022\'\n\013player_info\030\001 "
  "\001(\0132\020.game.PlayerInfoH\000\022!\n\003msg\030\002 \001(\0132\022.g"
  "ame.ErrorMessageH\000B\030\n\026login_responses_se"
  "cond\"B\n\017RegisterRequest\022\014\n\004name\030\001 \001(\t\022!\n"
  "\tsalt_hash\030\002 \001(\0132\016.game.SaltHash\"t\n\020Regi"
  "sterResponse\022\'\n\013player_info\030\001 \001(\0132\020.game"
  ".PlayerInfoH\000\022!\n\003msg\030\002 \001(\0132\022.game.ErrorM"
  "essageH\000B\024\n\022register_responses\"&\n\010SaltHa"
  "sh\022\014\n\004salt\030\001 \001(\t\022\014\n\004hash\030\002 \001(\t\"K\n\006Player"
  "\022\014\n\004name\030\001 \001(\t\022\"\n\006status\030\002 \001(\0162\022.game.Pl"
  "ayerStatus\022\017\n\007balance\030\003 \001(\r\"\213\001\n\rLobbyReq"
  "uests\0226\n\023create_game_request\030\001 \001(\0132\027.gam"
  "e.CreateGameRequestH\000\0226\n\023search_game_req"
  "uest\030\002 \001(\0132\027.game.SearchGameRequestH\000B\n\n"
  "\010requests\"\221\001\n\016LobbyResponses\0228\n\024create_g"
  "ame_response\030\001 \001(\0132\030.game.CreateGameResp"
  "onseH\000\0228\n\024search_game_response\030\002 \001(\0132\030.g"
  "ame.SearchGameResponseH\000B\013\n\tresponses\"Y\n"
  "\021CreateGameRequest\022\025\n\rgame_owner_id\030\001 \001("
  "\r\022-\n\017game_parameters\030\002 \001(\0132\024.game.GamePa"
  "rameters\"W\n\022CreateGameResponse\022\021\n\007game_i"
  "d\030\001 \001(\rH\000\022!\n\003msg\030\002 \001(\0132\022.game.ErrorMessa"
  "geH\000B\013\n\tresponses\"N\n\021SearchGameRequest\022\n"
  "\n\002id\030\001 \001(\r\022-\n\017game_parameters\030\002 \001(\0132\024.ga"
  "me.GameParameters\"W\n\022SearchGameResponse\022"
  "\021\n\007game_id\030\001 \001(\rH\000\022!\n\003msg\030\002 \001(\0132\022.game.E"
  "rrorMessageH\000B\013\n\tresponses\"o\n\016GameParame"
  "ters\022\021\n\tgame_name\030\001 \001(\t\022\031\n\021number_of_pla"
  "yers\030\002 \001(\r\022\023\n\013minimal_bet\030\003 \001(\r\022\032\n\022game_"
  "enter_balance\030\004 \001(\r\"b\n\nPlayerInfo\022\021\n\tcli"
  "ent_id\030\001 \001(\r\022\024\n\014client_games\030\002 \001(\r\022\023\n\013cl"
  "ient_wins\030\003 \001(\r\022\026\n\016client_balance\030\004 \001(\r\""
  "\306\001\n\014GameRequests\0222\n\021make_move_request\030\001 "
  "\001(\0132\025.game.MakeMoveRequestH\000\0222\n\021join_gam"
  "e_request\030\002 \001(\0132\025.game.JoinGameRequestH\000"
  "\022B\n\032join_game_as_owner_request\030\003 \001(\0132\034.g"
  "ame.JoinGameAsOwnerRequestH\000B\n\n\010requests"
  "\"\365\001\n\rGameResponses\0224\n\022make_move_response"
  "\030\001 \001(\0132\026.game.MakeMoveResponseH\000\022%\n\ngame"
  "_state\030\002 \001(\0132\017.game.GameStateH\000\0224\n\022join_"
  "game_response\030\003 \001(\0132\026.game.JoinGameRespo"
  "nseH\000\022D\n\033join_game_as_owner_response\030\004 \001"
  "(\0132\035.game.JoinGameAsOwnerResponseH\000B\013\n\tr"
  "esponses\"^\n\017JoinGameRequest\022\017\n\007game_id\030\001"
  " \001(\r\022\023\n\013player_name\030\002 \001(\t\022%\n\013player_info"
  "\030\003 \001(\0132\020.game.PlayerInfo\"X\n\020JoinGameResp"
  "onse\022#\n\ngame_state\030\001 \001(\0132\017.game.GameStat"
  "e\022\037\n\003msg\030\002 \001(\0132\022.game.ErrorMessage\"e\n\026Jo"
  "inGameAsOwnerRequest\022\017\n\007game_id\030\001 \001(\r\022\023\n"
  "\013player_name\030\002 \001(\t\022%\n\013player_info\030\003 \001(\0132"
  "\020.game.PlayerInfo\"_\n\027JoinGameAsOwnerResp"
  "onse\022#\n\ngame_state\030\001 \001(\0132\017.game.GameStat"
  "e\022\037\n\003msg\030\002 \001(\0132\022.game.ErrorMessage\"m\n\tGa"
  "meState\022 \n\014player_cards\030\001 \003(\0132\n.game.Car"
  "d\022\037\n\013board_cards\030\002 \003(\0132\n.game.Card\022\035\n\007pl"
  "ayers\030\003 \003(\0132\014.game.Player\"o\n\017MakeMoveReq"
  "uest\022\021\n\tplayer_id\030\001 \001(\r\022!\n\tmove_type\030\002 \001"
  "(\0162\016.game.MoveType\022\027\n\nblind_size\030\003 \001(\rH\000"
  "\210\001\001B\r\n\013_blind_size\"\022\n\020MakeMoveResponse\">"
  "\n\004Card\022\031\n\004suit\030\001 \001(\0162\013.game.Suits\022\033\n\005val"
  "ue\030\002 \001(\0162\014.game.Values*\246\001\n\005error\022!\n\035ERRO"
  "R_NO_USER_WITH_THIS_LOGIN\020\000\022-\n)ERROR_USE"
  "R_WITH_THIS_LOGIN_ALREADY_EXISTS\020\001\022\034\n\030ER"
  "ROR_UNCORRECT_PASSWORD\020\002\022\023\n\017ERROR_EXCEPT"
  "ION\020\003\022\030\n\024ERROR_GAME_NOT_FOUND\020\004*X\n\014Playe"
  "rStatus\022\026\n\022PLAYER_STATUS_FOLD\020\000\022\031\n\025PLAYE"
  "R_STATUS_PLAYING\020\001\022\025\n\021PLAYER_STATUS_WIN\020"
  "\002*d\n\010MoveType\022\022\n\016MOVE_TYPE_FOLD\020\000\022\024\n\020MOV"
  "E_TYPE_ALL_IN\020\001\022\023\n\017MOVE_TYPE_CHECK\020\002\022\031\n\025"
  "MOVE_TYPE_RAISE_BLIND\020\003*P\n\005Suits\022\022\n\016SUIT"
  "S_DIAMONDS\020\000\022\020\n\014SUITS_HEARTS\020\001\022\017\n\013SUITS_"
  "CLUBS\020\002\022\020\n\014SUITS_SPADES\020\003*\345\001\n\006Values\022\016\n\n"
  "VALUES_TWO\020\000\022\020\n\014VALUES_THREE\020\001\022\017\n\013VALUES"
  "_FOUR\020\002\022\017\n\013VALUES_FIVE\020\003\022\016\n\nVALUES_SIX\020\004"
  "\022\020\n\014VALUES_SEVEN\020\005\022\020\n\014VALUES_EIGHT\020\006\022\017\n\013"
  "VALUES_NINE\020\007\022\016\n\nVALUES_TEN\020\010\022\017\n\013VALUES_"
  "JACK\020\t\022\020\n\014VALUES_QUEEN\020\n\022\017\n\013VALUES_KING\020"
  "\013\022\016\n\nVALUES_ACE\020\0142\200\001\n\rAuthorization\0220\n\005L"
  "ogin\022\022.game.LoginRequest\032\023.game.LoginRes"
  "ponse\022=\n\014Registration\022\025.game.RegisterReq"
  "uest\032\026.game.RegisterResponse2C\n\005Lobby\022:\n"
  "\tLobbyFunc\022\023.game.LobbyRequests\032\024.game.L"
  "obbyResponses(\0010\0012D\n\tPokerGame\0227\n\010GameFu"
  "nc\022\022.game.GameRequests\032\023.game.GameRespon"
  "ses(\0010\001b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_game_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_game_2eproto = {
    false, false, 3975, descriptor_table_protodef_game_2eproto,
    "game.proto",
    &descriptor_table_game_2eproto_once, nullptr, 0, 29,
    schemas, file_default_instances, TableStruct_game_2eproto::offsets,
    file_level_metadata_game_2eproto, file_level_enum_descriptors_game_2eproto,
    file_level_service_descriptors_game_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_game_2eproto_getter() {
  return &descriptor_table_game_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_game_2eproto(&descriptor_table_game_2eproto);
namespace game {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* error_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[0];
}
bool error_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[1];
}
bool PlayerStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[2];
}
bool MoveType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Suits_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[3];
}
bool Suits_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Values_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[4];
}
bool Values_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ErrorMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ErrorMessage>()._impl_._has_bits_);
  static void set_has_message_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ErrorMessage::ErrorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.ErrorMessage)
}
ErrorMessage::ErrorMessage(const ErrorMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ErrorMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_string_){}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message_string()) {
    _this->_impl_.message_string_.Set(from._internal_message_string(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.error_ = from._impl_.error_;
  // @@protoc_insertion_point(copy_constructor:game.ErrorMessage)
}

inline void ErrorMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_string_){}
    , decltype(_impl_.error_){0}
  };
  _impl_.message_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ErrorMessage::~ErrorMessage() {
  // @@protoc_insertion_point(destructor:game.ErrorMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ErrorMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_string_.Destroy();
}

void ErrorMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ErrorMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:game.ErrorMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_string_.ClearNonDefaultToEmpty();
  }
  _impl_.error_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ErrorMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.error error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_error(static_cast<::game::error>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string message_string = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.ErrorMessage.message_string"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ErrorMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.ErrorMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.error error = 1;
  if (this->_internal_error() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_error(), target);
  }

  // optional string message_string = 2;
  if (_internal_has_message_string()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message_string().data(), static_cast<int>(this->_internal_message_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.ErrorMessage.message_string");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.ErrorMessage)
  return target;
}

size_t ErrorMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.ErrorMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message_string = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message_string());
  }

  // .game.error error = 1;
  if (this->_internal_error() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ErrorMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ErrorMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ErrorMessage::GetClassData() const { return &_class_data_; }


void ErrorMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ErrorMessage*>(&to_msg);
  auto& from = static_cast<const ErrorMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.ErrorMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_message_string()) {
    _this->_internal_set_message_string(from._internal_message_string());
  }
  if (from._internal_error() != 0) {
    _this->_internal_set_error(from._internal_error());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ErrorMessage::CopyFrom(const ErrorMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.ErrorMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorMessage::IsInitialized() const {
  return true;
}

void ErrorMessage::InternalSwap(ErrorMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_string_, lhs_arena,
      &other->_impl_.message_string_, rhs_arena
  );
  swap(_impl_.error_, other->_impl_.error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ErrorMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[0]);
}

// ===================================================================

class LoginRequest::_Internal {
 public:
  static const ::game::LoginRequestFirst& login_request_first(const LoginRequest* msg);
  static const ::game::LoginRequestSecond& login_request_second(const LoginRequest* msg);
};

const ::game::LoginRequestFirst&
LoginRequest::_Internal::login_request_first(const LoginRequest* msg) {
  return *msg->_impl_.login_requests_.login_request_first_;
}
const ::game::LoginRequestSecond&
LoginRequest::_Internal::login_request_second(const LoginRequest* msg) {
  return *msg->_impl_.login_requests_.login_request_second_;
}
void LoginRequest::set_allocated_login_request_first(::game::LoginRequestFirst* login_request_first) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_login_requests();
  if (login_request_first) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_request_first);
    if (message_arena != submessage_arena) {
      login_request_first = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_request_first, submessage_arena);
    }
    set_has_login_request_first();
    _impl_.login_requests_.login_request_first_ = login_request_first;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequest.login_request_first)
}
void LoginRequest::set_allocated_login_request_second(::game::LoginRequestSecond* login_request_second) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_login_requests();
  if (login_request_second) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_request_second);
    if (message_arena != submessage_arena) {
      login_request_second = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_request_second, submessage_arena);
    }
    set_has_login_request_second();
    _impl_.login_requests_.login_request_second_ = login_request_second;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequest.login_request_second)
}
LoginRequest::LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.LoginRequest)
}
LoginRequest::LoginRequest(const LoginRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoginRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.login_requests_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_login_requests();
  switch (from.login_requests_case()) {
    case kLoginRequestFirst: {
      _this->_internal_mutable_login_request_first()->::game::LoginRequestFirst::MergeFrom(
          from._internal_login_request_first());
      break;
    }
    case kLoginRequestSecond: {
      _this->_internal_mutable_login_request_second()->::game::LoginRequestSecond::MergeFrom(
          from._internal_login_request_second());
      break;
    }
    case LOGIN_REQUESTS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.LoginRequest)
}

inline void LoginRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.login_requests_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_login_requests();
}

LoginRequest::~LoginRequest() {
  // @@protoc_insertion_point(destructor:game.LoginRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_login_requests()) {
    clear_login_requests();
  }
}

void LoginRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginRequest::clear_login_requests() {
// @@protoc_insertion_point(one_of_clear_start:game.LoginRequest)
  switch (login_requests_case()) {
    case kLoginRequestFirst: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.login_requests_.login_request_first_;
      }
      break;
    }
    case kLoginRequestSecond: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.login_requests_.login_request_second_;
      }
      break;
    }
    case LOGIN_REQUESTS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LOGIN_REQUESTS_NOT_SET;
}


void LoginRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:game.LoginRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_login_requests();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.LoginRequestFirst login_request_first = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_request_first(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.LoginRequestSecond login_request_second = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_request_second(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.LoginRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.LoginRequestFirst login_request_first = 1;
  if (_internal_has_login_request_first()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::login_request_first(this),
        _Internal::login_request_first(this).GetCachedSize(), target, stream);
  }

  // .game.LoginRequestSecond login_request_second = 2;
  if (_internal_has_login_request_second()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::login_request_second(this),
        _Internal::login_request_second(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.LoginRequest)
  return target;
}

size_t LoginRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.LoginRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (login_requests_case()) {
    // .game.LoginRequestFirst login_request_first = 1;
    case kLoginRequestFirst: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_requests_.login_request_first_);
      break;
    }
    // .game.LoginRequestSecond login_request_second = 2;
    case kLoginRequestSecond: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_requests_.login_request_second_);
      break;
    }
    case LOGIN_REQUESTS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginRequest::GetClassData() const { return &_class_data_; }


void LoginRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoginRequest*>(&to_msg);
  auto& from = static_cast<const LoginRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.LoginRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.login_requests_case()) {
    case kLoginRequestFirst: {
      _this->_internal_mutable_login_request_first()->::game::LoginRequestFirst::MergeFrom(
          from._internal_login_request_first());
      break;
    }
    case kLoginRequestSecond: {
      _this->_internal_mutable_login_request_second()->::game::LoginRequestSecond::MergeFrom(
          from._internal_login_request_second());
      break;
    }
    case LOGIN_REQUESTS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginRequest::CopyFrom(const LoginRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.LoginRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRequest::IsInitialized() const {
  return true;
}

void LoginRequest::InternalSwap(LoginRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.login_requests_, other->_impl_.login_requests_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[1]);
}

// ===================================================================

class LoginResponse::_Internal {
 public:
  static const ::game::LoginResponseFirst& login_response_first(const LoginResponse* msg);
  static const ::game::LoginResponseSecond& login_response_second(const LoginResponse* msg);
};

const ::game::LoginResponseFirst&
LoginResponse::_Internal::login_response_first(const LoginResponse* msg) {
  return *msg->_impl_.login_responses_.login_response_first_;
}
const ::game::LoginResponseSecond&
LoginResponse::_Internal::login_response_second(const LoginResponse* msg) {
  return *msg->_impl_.login_responses_.login_response_second_;
}
void LoginResponse::set_allocated_login_response_first(::game::LoginResponseFirst* login_response_first) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_login_responses();
  if (login_response_first) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_response_first);
    if (message_arena != submessage_arena) {
      login_response_first = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_response_first, submessage_arena);
    }
    set_has_login_response_first();
    _impl_.login_responses_.login_response_first_ = login_response_first;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LoginResponse.login_response_first)
}
void LoginResponse::set_allocated_login_response_second(::game::LoginResponseSecond* login_response_second) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_login_responses();
  if (login_response_second) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_response_second);
    if (message_arena != submessage_arena) {
      login_response_second = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_response_second, submessage_arena);
    }
    set_has_login_response_second();
    _impl_.login_responses_.login_response_second_ = login_response_second;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LoginResponse.login_response_second)
}
LoginResponse::LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.LoginResponse)
}
LoginResponse::LoginResponse(const LoginResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoginResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.login_responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_login_responses();
  switch (from.login_responses_case()) {
    case kLoginResponseFirst: {
      _this->_internal_mutable_login_response_first()->::game::LoginResponseFirst::MergeFrom(
          from._internal_login_response_first());
      break;
    }
    case kLoginResponseSecond: {
      _this->_internal_mutable_login_response_second()->::game::LoginResponseSecond::MergeFrom(
          from._internal_login_response_second());
      break;
    }
    case LOGIN_RESPONSES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.LoginResponse)
}

inline void LoginResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.login_responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_login_responses();
}

LoginResponse::~LoginResponse() {
  // @@protoc_insertion_point(destructor:game.LoginResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_login_responses()) {
    clear_login_responses();
  }
}

void LoginResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginResponse::clear_login_responses() {
// @@protoc_insertion_point(one_of_clear_start:game.LoginResponse)
  switch (login_responses_case()) {
    case kLoginResponseFirst: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.login_responses_.login_response_first_;
      }
      break;
    }
    case kLoginResponseSecond: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.login_responses_.login_response_second_;
      }
      break;
    }
    case LOGIN_RESPONSES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LOGIN_RESPONSES_NOT_SET;
}


void LoginResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:game.LoginResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_login_responses();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.LoginResponseFirst login_response_first = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_response_first(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.LoginResponseSecond login_response_second = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_response_second(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.LoginResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.LoginResponseFirst login_response_first = 1;
  if (_internal_has_login_response_first()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::login_response_first(this),
        _Internal::login_response_first(this).GetCachedSize(), target, stream);
  }

  // .game.LoginResponseSecond login_response_second = 2;
  if (_internal_has_login_response_second()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::login_response_second(this),
        _Internal::login_response_second(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.LoginResponse)
  return target;
}

size_t LoginResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.LoginResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (login_responses_case()) {
    // .game.LoginResponseFirst login_response_first = 1;
    case kLoginResponseFirst: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_responses_.login_response_first_);
      break;
    }
    // .game.LoginResponseSecond login_response_second = 2;
    case kLoginResponseSecond: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_responses_.login_response_second_);
      break;
    }
    case LOGIN_RESPONSES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginResponse::GetClassData() const { return &_class_data_; }


void LoginResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoginResponse*>(&to_msg);
  auto& from = static_cast<const LoginResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.LoginResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.login_responses_case()) {
    case kLoginResponseFirst: {
      _this->_internal_mutable_login_response_first()->::game::LoginResponseFirst::MergeFrom(
          from._internal_login_response_first());
      break;
    }
    case kLoginResponseSecond: {
      _this->_internal_mutable_login_response_second()->::game::LoginResponseSecond::MergeFrom(
          from._internal_login_response_second());
      break;
    }
    case LOGIN_RESPONSES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginResponse::CopyFrom(const LoginResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.LoginResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginResponse::IsInitialized() const {
  return true;
}

void LoginResponse::InternalSwap(LoginResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.login_responses_, other->_impl_.login_responses_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[2]);
}

// ===================================================================

class LoginRequestFirst::_Internal {
 public:
};

LoginRequestFirst::LoginRequestFirst(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.LoginRequestFirst)
}
LoginRequestFirst::LoginRequestFirst(const LoginRequestFirst& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoginRequestFirst* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:game.LoginRequestFirst)
}

inline void LoginRequestFirst::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginRequestFirst::~LoginRequestFirst() {
  // @@protoc_insertion_point(destructor:game.LoginRequestFirst)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginRequestFirst::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void LoginRequestFirst::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginRequestFirst::Clear() {
// @@protoc_insertion_point(message_clear_start:game.LoginRequestFirst)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginRequestFirst::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.LoginRequestFirst.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginRequestFirst::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.LoginRequestFirst)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.LoginRequestFirst.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.LoginRequestFirst)
  return target;
}

size_t LoginRequestFirst::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.LoginRequestFirst)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginRequestFirst::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginRequestFirst::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginRequestFirst::GetClassData() const { return &_class_data_; }


void LoginRequestFirst::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoginRequestFirst*>(&to_msg);
  auto& from = static_cast<const LoginRequestFirst&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.LoginRequestFirst)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginRequestFirst::CopyFrom(const LoginRequestFirst& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.LoginRequestFirst)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRequestFirst::IsInitialized() const {
  return true;
}

void LoginRequestFirst::InternalSwap(LoginRequestFirst* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginRequestFirst::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[3]);
}

// ===================================================================

class LoginRequestSecond::_Internal {
 public:
};

LoginRequestSecond::LoginRequestSecond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.LoginRequestSecond)
}
LoginRequestSecond::LoginRequestSecond(const LoginRequestSecond& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoginRequestSecond* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.hashed_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hashed_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hashed_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hashed().empty()) {
    _this->_impl_.hashed_.Set(from._internal_hashed(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:game.LoginRequestSecond)
}

inline void LoginRequestSecond::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.hashed_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hashed_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hashed_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginRequestSecond::~LoginRequestSecond() {
  // @@protoc_insertion_point(destructor:game.LoginRequestSecond)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginRequestSecond::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.hashed_.Destroy();
}

void LoginRequestSecond::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginRequestSecond::Clear() {
// @@protoc_insertion_point(message_clear_start:game.LoginRequestSecond)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.hashed_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginRequestSecond::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.LoginRequestSecond.name"));
        } else
          goto handle_unusual;
        continue;
      // string hashed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hashed();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.LoginRequestSecond.hashed"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginRequestSecond::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.LoginRequestSecond)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.LoginRequestSecond.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string hashed = 2;
  if (!this->_internal_hashed().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hashed().data(), static_cast<int>(this->_internal_hashed().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.LoginRequestSecond.hashed");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_hashed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.LoginRequestSecond)
  return target;
}

size_t LoginRequestSecond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.LoginRequestSecond)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string hashed = 2;
  if (!this->_internal_hashed().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hashed());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginRequestSecond::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginRequestSecond::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginRequestSecond::GetClassData() const { return &_class_data_; }


void LoginRequestSecond::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoginRequestSecond*>(&to_msg);
  auto& from = static_cast<const LoginRequestSecond&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.LoginRequestSecond)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_hashed().empty()) {
    _this->_internal_set_hashed(from._internal_hashed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginRequestSecond::CopyFrom(const LoginRequestSecond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.LoginRequestSecond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRequestSecond::IsInitialized() const {
  return true;
}

void LoginRequestSecond::InternalSwap(LoginRequestSecond* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hashed_, lhs_arena,
      &other->_impl_.hashed_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginRequestSecond::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[4]);
}

// ===================================================================

class LoginResponseFirst::_Internal {
 public:
  static const ::game::ErrorMessage& msg(const LoginResponseFirst* msg);
};

const ::game::ErrorMessage&
LoginResponseFirst::_Internal::msg(const LoginResponseFirst* msg) {
  return *msg->_impl_.login_responses_first_.msg_;
}
void LoginResponseFirst::set_allocated_msg(::game::ErrorMessage* msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_login_responses_first();
  if (msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg);
    if (message_arena != submessage_arena) {
      msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
    _impl_.login_responses_first_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LoginResponseFirst.msg)
}
LoginResponseFirst::LoginResponseFirst(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.LoginResponseFirst)
}
LoginResponseFirst::LoginResponseFirst(const LoginResponseFirst& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoginResponseFirst* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.login_responses_first_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_login_responses_first();
  switch (from.login_responses_first_case()) {
    case kSalt: {
      _this->_internal_set_salt(from._internal_salt());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case LOGIN_RESPONSES_FIRST_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.LoginResponseFirst)
}

inline void LoginResponseFirst::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.login_responses_first_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_login_responses_first();
}

LoginResponseFirst::~LoginResponseFirst() {
  // @@protoc_insertion_point(destructor:game.LoginResponseFirst)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginResponseFirst::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_login_responses_first()) {
    clear_login_responses_first();
  }
}

void LoginResponseFirst::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginResponseFirst::clear_login_responses_first() {
// @@protoc_insertion_point(one_of_clear_start:game.LoginResponseFirst)
  switch (login_responses_first_case()) {
    case kSalt: {
      _impl_.login_responses_first_.salt_.Destroy();
      break;
    }
    case kMsg: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.login_responses_first_.msg_;
      }
      break;
    }
    case LOGIN_RESPONSES_FIRST_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LOGIN_RESPONSES_FIRST_NOT_SET;
}


void LoginResponseFirst::Clear() {
// @@protoc_insertion_point(message_clear_start:game.LoginResponseFirst)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_login_responses_first();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginResponseFirst::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string salt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.LoginResponseFirst.salt"));
        } else
          goto handle_unusual;
        continue;
      // .game.ErrorMessage msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginResponseFirst::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.LoginResponseFirst)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string salt = 1;
  if (_internal_has_salt()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_salt().data(), static_cast<int>(this->_internal_salt().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.LoginResponseFirst.salt");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_salt(), target);
  }

  // .game.ErrorMessage msg = 2;
  if (_internal_has_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::msg(this),
        _Internal::msg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.LoginResponseFirst)
  return target;
}

size_t LoginResponseFirst::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.LoginResponseFirst)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (login_responses_first_case()) {
    // string salt = 1;
    case kSalt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_salt());
      break;
    }
    // .game.ErrorMessage msg = 2;
    case kMsg: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_responses_first_.msg_);
      break;
    }
    case LOGIN_RESPONSES_FIRST_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginResponseFirst::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginResponseFirst::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginResponseFirst::GetClassData() const { return &_class_data_; }


void LoginResponseFirst::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoginResponseFirst*>(&to_msg);
  auto& from = static_cast<const LoginResponseFirst&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.LoginResponseFirst)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.login_responses_first_case()) {
    case kSalt: {
      _this->_internal_set_salt(from._internal_salt());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case LOGIN_RESPONSES_FIRST_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginResponseFirst::CopyFrom(const LoginResponseFirst& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.LoginResponseFirst)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginResponseFirst::IsInitialized() const {
  return true;
}

void LoginResponseFirst::InternalSwap(LoginResponseFirst* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.login_responses_first_, other->_impl_.login_responses_first_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginResponseFirst::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[5]);
}

// ===================================================================

class LoginResponseSecond::_Internal {
 public:
  static const ::game::PlayerInfo& player_info(const LoginResponseSecond* msg);
  static const ::game::ErrorMessage& msg(const LoginResponseSecond* msg);
};

const ::game::PlayerInfo&
LoginResponseSecond::_Internal::player_info(const LoginResponseSecond* msg) {
  return *msg->_impl_.login_responses_second_.player_info_;
}
const ::game::ErrorMessage&
LoginResponseSecond::_Internal::msg(const LoginResponseSecond* msg) {
  return *msg->_impl_.login_responses_second_.msg_;
}
void LoginResponseSecond::set_allocated_player_info(::game::PlayerInfo* player_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_login_responses_second();
  if (player_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_info);
    if (message_arena != submessage_arena) {
      player_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    set_has_player_info();
    _impl_.login_responses_second_.player_info_ = player_info;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LoginResponseSecond.player_info)
}
void LoginResponseSecond::set_allocated_msg(::game::ErrorMessage* msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_login_responses_second();
  if (msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg);
    if (message_arena != submessage_arena) {
      msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
    _impl_.login_responses_second_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LoginResponseSecond.msg)
}
LoginResponseSecond::LoginResponseSecond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.LoginResponseSecond)
}
LoginResponseSecond::LoginResponseSecond(const LoginResponseSecond& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoginResponseSecond* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.login_responses_second_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_login_responses_second();
  switch (from.login_responses_second_case()) {
    case kPlayerInfo: {
      _this->_internal_mutable_player_info()->::game::PlayerInfo::MergeFrom(
          from._internal_player_info());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case LOGIN_RESPONSES_SECOND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.LoginResponseSecond)
}

inline void LoginResponseSecond::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.login_responses_second_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_login_responses_second();
}

LoginResponseSecond::~LoginResponseSecond() {
  // @@protoc_insertion_point(destructor:game.LoginResponseSecond)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginResponseSecond::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_login_responses_second()) {
    clear_login_responses_second();
  }
}

void LoginResponseSecond::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginResponseSecond::clear_login_responses_second() {
// @@protoc_insertion_point(one_of_clear_start:game.LoginResponseSecond)
  switch (login_responses_second_case()) {
    case kPlayerInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.login_responses_second_.player_info_;
      }
      break;
    }
    case kMsg: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.login_responses_second_.msg_;
      }
      break;
    }
    case LOGIN_RESPONSES_SECOND_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LOGIN_RESPONSES_SECOND_NOT_SET;
}


void LoginResponseSecond::Clear() {
// @@protoc_insertion_point(message_clear_start:game.LoginResponseSecond)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_login_responses_second();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginResponseSecond::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.PlayerInfo player_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.ErrorMessage msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginResponseSecond::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.LoginResponseSecond)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.PlayerInfo player_info = 1;
  if (_internal_has_player_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_info(this),
        _Internal::player_info(this).GetCachedSize(), target, stream);
  }

  // .game.ErrorMessage msg = 2;
  if (_internal_has_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::msg(this),
        _Internal::msg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.LoginResponseSecond)
  return target;
}

size_t LoginResponseSecond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.LoginResponseSecond)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (login_responses_second_case()) {
    // .game.PlayerInfo player_info = 1;
    case kPlayerInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_responses_second_.player_info_);
      break;
    }
    // .game.ErrorMessage msg = 2;
    case kMsg: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.login_responses_second_.msg_);
      break;
    }
    case LOGIN_RESPONSES_SECOND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginResponseSecond::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginResponseSecond::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginResponseSecond::GetClassData() const { return &_class_data_; }


void LoginResponseSecond::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoginResponseSecond*>(&to_msg);
  auto& from = static_cast<const LoginResponseSecond&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.LoginResponseSecond)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.login_responses_second_case()) {
    case kPlayerInfo: {
      _this->_internal_mutable_player_info()->::game::PlayerInfo::MergeFrom(
          from._internal_player_info());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case LOGIN_RESPONSES_SECOND_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginResponseSecond::CopyFrom(const LoginResponseSecond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.LoginResponseSecond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginResponseSecond::IsInitialized() const {
  return true;
}

void LoginResponseSecond::InternalSwap(LoginResponseSecond* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.login_responses_second_, other->_impl_.login_responses_second_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginResponseSecond::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[6]);
}

// ===================================================================

class RegisterRequest::_Internal {
 public:
  static const ::game::SaltHash& salt_hash(const RegisterRequest* msg);
};

const ::game::SaltHash&
RegisterRequest::_Internal::salt_hash(const RegisterRequest* msg) {
  return *msg->_impl_.salt_hash_;
}
RegisterRequest::RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.RegisterRequest)
}
RegisterRequest::RegisterRequest(const RegisterRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RegisterRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.salt_hash_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_salt_hash()) {
    _this->_impl_.salt_hash_ = new ::game::SaltHash(*from._impl_.salt_hash_);
  }
  // @@protoc_insertion_point(copy_constructor:game.RegisterRequest)
}

inline void RegisterRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.salt_hash_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RegisterRequest::~RegisterRequest() {
  // @@protoc_insertion_point(destructor:game.RegisterRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegisterRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.salt_hash_;
}

void RegisterRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RegisterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:game.RegisterRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.salt_hash_ != nullptr) {
    delete _impl_.salt_hash_;
  }
  _impl_.salt_hash_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegisterRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.RegisterRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // .game.SaltHash salt_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_salt_hash(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegisterRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.RegisterRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.RegisterRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .game.SaltHash salt_hash = 2;
  if (this->_internal_has_salt_hash()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::salt_hash(this),
        _Internal::salt_hash(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.RegisterRequest)
  return target;
}

size_t RegisterRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.RegisterRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .game.SaltHash salt_hash = 2;
  if (this->_internal_has_salt_hash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.salt_hash_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegisterRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RegisterRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegisterRequest::GetClassData() const { return &_class_data_; }


void RegisterRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RegisterRequest*>(&to_msg);
  auto& from = static_cast<const RegisterRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.RegisterRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_salt_hash()) {
    _this->_internal_mutable_salt_hash()->::game::SaltHash::MergeFrom(
        from._internal_salt_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegisterRequest::CopyFrom(const RegisterRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.RegisterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterRequest::IsInitialized() const {
  return true;
}

void RegisterRequest::InternalSwap(RegisterRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.salt_hash_, other->_impl_.salt_hash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RegisterRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[7]);
}

// ===================================================================

class RegisterResponse::_Internal {
 public:
  static const ::game::PlayerInfo& player_info(const RegisterResponse* msg);
  static const ::game::ErrorMessage& msg(const RegisterResponse* msg);
};

const ::game::PlayerInfo&
RegisterResponse::_Internal::player_info(const RegisterResponse* msg) {
  return *msg->_impl_.register_responses_.player_info_;
}
const ::game::ErrorMessage&
RegisterResponse::_Internal::msg(const RegisterResponse* msg) {
  return *msg->_impl_.register_responses_.msg_;
}
void RegisterResponse::set_allocated_player_info(::game::PlayerInfo* player_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_register_responses();
  if (player_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_info);
    if (message_arena != submessage_arena) {
      player_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    set_has_player_info();
    _impl_.register_responses_.player_info_ = player_info;
  }
  // @@protoc_insertion_point(field_set_allocated:game.RegisterResponse.player_info)
}
void RegisterResponse::set_allocated_msg(::game::ErrorMessage* msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_register_responses();
  if (msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg);
    if (message_arena != submessage_arena) {
      msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
    _impl_.register_responses_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_set_allocated:game.RegisterResponse.msg)
}
RegisterResponse::RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.RegisterResponse)
}
RegisterResponse::RegisterResponse(const RegisterResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RegisterResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.register_responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_register_responses();
  switch (from.register_responses_case()) {
    case kPlayerInfo: {
      _this->_internal_mutable_player_info()->::game::PlayerInfo::MergeFrom(
          from._internal_player_info());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case REGISTER_RESPONSES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.RegisterResponse)
}

inline void RegisterResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.register_responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_register_responses();
}

RegisterResponse::~RegisterResponse() {
  // @@protoc_insertion_point(destructor:game.RegisterResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegisterResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_register_responses()) {
    clear_register_responses();
  }
}

void RegisterResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RegisterResponse::clear_register_responses() {
// @@protoc_insertion_point(one_of_clear_start:game.RegisterResponse)
  switch (register_responses_case()) {
    case kPlayerInfo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.register_responses_.player_info_;
      }
      break;
    }
    case kMsg: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.register_responses_.msg_;
      }
      break;
    }
    case REGISTER_RESPONSES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = REGISTER_RESPONSES_NOT_SET;
}


void RegisterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:game.RegisterResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_register_responses();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegisterResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.PlayerInfo player_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.ErrorMessage msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegisterResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.RegisterResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.PlayerInfo player_info = 1;
  if (_internal_has_player_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_info(this),
        _Internal::player_info(this).GetCachedSize(), target, stream);
  }

  // .game.ErrorMessage msg = 2;
  if (_internal_has_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::msg(this),
        _Internal::msg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.RegisterResponse)
  return target;
}

size_t RegisterResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.RegisterResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (register_responses_case()) {
    // .game.PlayerInfo player_info = 1;
    case kPlayerInfo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.register_responses_.player_info_);
      break;
    }
    // .game.ErrorMessage msg = 2;
    case kMsg: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.register_responses_.msg_);
      break;
    }
    case REGISTER_RESPONSES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegisterResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RegisterResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegisterResponse::GetClassData() const { return &_class_data_; }


void RegisterResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RegisterResponse*>(&to_msg);
  auto& from = static_cast<const RegisterResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.RegisterResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.register_responses_case()) {
    case kPlayerInfo: {
      _this->_internal_mutable_player_info()->::game::PlayerInfo::MergeFrom(
          from._internal_player_info());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case REGISTER_RESPONSES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegisterResponse::CopyFrom(const RegisterResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.RegisterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterResponse::IsInitialized() const {
  return true;
}

void RegisterResponse::InternalSwap(RegisterResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.register_responses_, other->_impl_.register_responses_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata RegisterResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[8]);
}

// ===================================================================

class SaltHash::_Internal {
 public:
};

SaltHash::SaltHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.SaltHash)
}
SaltHash::SaltHash(const SaltHash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SaltHash* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.salt_){}
    , decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_salt().empty()) {
    _this->_impl_.salt_.Set(from._internal_salt(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash().empty()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:game.SaltHash)
}

inline void SaltHash::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.salt_){}
    , decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SaltHash::~SaltHash() {
  // @@protoc_insertion_point(destructor:game.SaltHash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaltHash::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.salt_.Destroy();
  _impl_.hash_.Destroy();
}

void SaltHash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SaltHash::Clear() {
// @@protoc_insertion_point(message_clear_start:game.SaltHash)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.salt_.ClearToEmpty();
  _impl_.hash_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SaltHash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string salt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.SaltHash.salt"));
        } else
          goto handle_unusual;
        continue;
      // string hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.SaltHash.hash"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaltHash::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.SaltHash)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string salt = 1;
  if (!this->_internal_salt().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_salt().data(), static_cast<int>(this->_internal_salt().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.SaltHash.salt");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_salt(), target);
  }

  // string hash = 2;
  if (!this->_internal_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hash().data(), static_cast<int>(this->_internal_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.SaltHash.hash");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.SaltHash)
  return target;
}

size_t SaltHash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.SaltHash)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string salt = 1;
  if (!this->_internal_salt().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_salt());
  }

  // string hash = 2;
  if (!this->_internal_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SaltHash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SaltHash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SaltHash::GetClassData() const { return &_class_data_; }


void SaltHash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SaltHash*>(&to_msg);
  auto& from = static_cast<const SaltHash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.SaltHash)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_salt().empty()) {
    _this->_internal_set_salt(from._internal_salt());
  }
  if (!from._internal_hash().empty()) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SaltHash::CopyFrom(const SaltHash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.SaltHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaltHash::IsInitialized() const {
  return true;
}

void SaltHash::InternalSwap(SaltHash* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.salt_, lhs_arena,
      &other->_impl_.salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SaltHash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[9]);
}

// ===================================================================

class Player::_Internal {
 public:
};

Player::Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.Player)
}
Player::Player(const Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.balance_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.status_, &from._impl_.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.balance_) -
    reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.balance_));
  // @@protoc_insertion_point(copy_constructor:game.Player)
}

inline void Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.status_){0}
    , decltype(_impl_.balance_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Player::~Player() {
  // @@protoc_insertion_point(destructor:game.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Player::Clear() {
// @@protoc_insertion_point(message_clear_start:game.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.balance_) -
      reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.balance_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.Player.name"));
        } else
          goto handle_unusual;
        continue;
      // .game.PlayerStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::game::PlayerStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 balance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.balance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.Player.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .game.PlayerStatus status = 2;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // uint32 balance = 3;
  if (this->_internal_balance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_balance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.Player)
  return target;
}

size_t Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .game.PlayerStatus status = 2;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // uint32 balance = 3;
  if (this->_internal_balance() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_balance());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Player::GetClassData() const { return &_class_data_; }


void Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Player*>(&to_msg);
  auto& from = static_cast<const Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_balance() != 0) {
    _this->_internal_set_balance(from._internal_balance());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Player::CopyFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player::IsInitialized() const {
  return true;
}

void Player::InternalSwap(Player* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Player, _impl_.balance_)
      + sizeof(Player::_impl_.balance_)
      - PROTOBUF_FIELD_OFFSET(Player, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[10]);
}

// ===================================================================

class LobbyRequests::_Internal {
 public:
  static const ::game::CreateGameRequest& create_game_request(const LobbyRequests* msg);
  static const ::game::SearchGameRequest& search_game_request(const LobbyRequests* msg);
};

const ::game::CreateGameRequest&
LobbyRequests::_Internal::create_game_request(const LobbyRequests* msg) {
  return *msg->_impl_.requests_.create_game_request_;
}
const ::game::SearchGameRequest&
LobbyRequests::_Internal::search_game_request(const LobbyRequests* msg) {
  return *msg->_impl_.requests_.search_game_request_;
}
void LobbyRequests::set_allocated_create_game_request(::game::CreateGameRequest* create_game_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_requests();
  if (create_game_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_game_request);
    if (message_arena != submessage_arena) {
      create_game_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_game_request, submessage_arena);
    }
    set_has_create_game_request();
    _impl_.requests_.create_game_request_ = create_game_request;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LobbyRequests.create_game_request)
}
void LobbyRequests::set_allocated_search_game_request(::game::SearchGameRequest* search_game_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_requests();
  if (search_game_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(search_game_request);
    if (message_arena != submessage_arena) {
      search_game_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search_game_request, submessage_arena);
    }
    set_has_search_game_request();
    _impl_.requests_.search_game_request_ = search_game_request;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LobbyRequests.search_game_request)
}
LobbyRequests::LobbyRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.LobbyRequests)
}
LobbyRequests::LobbyRequests(const LobbyRequests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LobbyRequests* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_requests();
  switch (from.requests_case()) {
    case kCreateGameRequest: {
      _this->_internal_mutable_create_game_request()->::game::CreateGameRequest::MergeFrom(
          from._internal_create_game_request());
      break;
    }
    case kSearchGameRequest: {
      _this->_internal_mutable_search_game_request()->::game::SearchGameRequest::MergeFrom(
          from._internal_search_game_request());
      break;
    }
    case REQUESTS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.LobbyRequests)
}

inline void LobbyRequests::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_requests();
}

LobbyRequests::~LobbyRequests() {
  // @@protoc_insertion_point(destructor:game.LobbyRequests)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LobbyRequests::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_requests()) {
    clear_requests();
  }
}

void LobbyRequests::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LobbyRequests::clear_requests() {
// @@protoc_insertion_point(one_of_clear_start:game.LobbyRequests)
  switch (requests_case()) {
    case kCreateGameRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.requests_.create_game_request_;
      }
      break;
    }
    case kSearchGameRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.requests_.search_game_request_;
      }
      break;
    }
    case REQUESTS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = REQUESTS_NOT_SET;
}


void LobbyRequests::Clear() {
// @@protoc_insertion_point(message_clear_start:game.LobbyRequests)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_requests();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LobbyRequests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.CreateGameRequest create_game_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_game_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.SearchGameRequest search_game_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_search_game_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LobbyRequests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.LobbyRequests)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.CreateGameRequest create_game_request = 1;
  if (_internal_has_create_game_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::create_game_request(this),
        _Internal::create_game_request(this).GetCachedSize(), target, stream);
  }

  // .game.SearchGameRequest search_game_request = 2;
  if (_internal_has_search_game_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::search_game_request(this),
        _Internal::search_game_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.LobbyRequests)
  return target;
}

size_t LobbyRequests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.LobbyRequests)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (requests_case()) {
    // .game.CreateGameRequest create_game_request = 1;
    case kCreateGameRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.requests_.create_game_request_);
      break;
    }
    // .game.SearchGameRequest search_game_request = 2;
    case kSearchGameRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.requests_.search_game_request_);
      break;
    }
    case REQUESTS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LobbyRequests::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LobbyRequests::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LobbyRequests::GetClassData() const { return &_class_data_; }


void LobbyRequests::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LobbyRequests*>(&to_msg);
  auto& from = static_cast<const LobbyRequests&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.LobbyRequests)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.requests_case()) {
    case kCreateGameRequest: {
      _this->_internal_mutable_create_game_request()->::game::CreateGameRequest::MergeFrom(
          from._internal_create_game_request());
      break;
    }
    case kSearchGameRequest: {
      _this->_internal_mutable_search_game_request()->::game::SearchGameRequest::MergeFrom(
          from._internal_search_game_request());
      break;
    }
    case REQUESTS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LobbyRequests::CopyFrom(const LobbyRequests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.LobbyRequests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LobbyRequests::IsInitialized() const {
  return true;
}

void LobbyRequests::InternalSwap(LobbyRequests* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.requests_, other->_impl_.requests_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LobbyRequests::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[11]);
}

// ===================================================================

class LobbyResponses::_Internal {
 public:
  static const ::game::CreateGameResponse& create_game_response(const LobbyResponses* msg);
  static const ::game::SearchGameResponse& search_game_response(const LobbyResponses* msg);
};

const ::game::CreateGameResponse&
LobbyResponses::_Internal::create_game_response(const LobbyResponses* msg) {
  return *msg->_impl_.responses_.create_game_response_;
}
const ::game::SearchGameResponse&
LobbyResponses::_Internal::search_game_response(const LobbyResponses* msg) {
  return *msg->_impl_.responses_.search_game_response_;
}
void LobbyResponses::set_allocated_create_game_response(::game::CreateGameResponse* create_game_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_responses();
  if (create_game_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_game_response);
    if (message_arena != submessage_arena) {
      create_game_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_game_response, submessage_arena);
    }
    set_has_create_game_response();
    _impl_.responses_.create_game_response_ = create_game_response;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LobbyResponses.create_game_response)
}
void LobbyResponses::set_allocated_search_game_response(::game::SearchGameResponse* search_game_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_responses();
  if (search_game_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(search_game_response);
    if (message_arena != submessage_arena) {
      search_game_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search_game_response, submessage_arena);
    }
    set_has_search_game_response();
    _impl_.responses_.search_game_response_ = search_game_response;
  }
  // @@protoc_insertion_point(field_set_allocated:game.LobbyResponses.search_game_response)
}
LobbyResponses::LobbyResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.LobbyResponses)
}
LobbyResponses::LobbyResponses(const LobbyResponses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LobbyResponses* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_responses();
  switch (from.responses_case()) {
    case kCreateGameResponse: {
      _this->_internal_mutable_create_game_response()->::game::CreateGameResponse::MergeFrom(
          from._internal_create_game_response());
      break;
    }
    case kSearchGameResponse: {
      _this->_internal_mutable_search_game_response()->::game::SearchGameResponse::MergeFrom(
          from._internal_search_game_response());
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.LobbyResponses)
}

inline void LobbyResponses::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_responses();
}

LobbyResponses::~LobbyResponses() {
  // @@protoc_insertion_point(destructor:game.LobbyResponses)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LobbyResponses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_responses()) {
    clear_responses();
  }
}

void LobbyResponses::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LobbyResponses::clear_responses() {
// @@protoc_insertion_point(one_of_clear_start:game.LobbyResponses)
  switch (responses_case()) {
    case kCreateGameResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.responses_.create_game_response_;
      }
      break;
    }
    case kSearchGameResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.responses_.search_game_response_;
      }
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}


void LobbyResponses::Clear() {
// @@protoc_insertion_point(message_clear_start:game.LobbyResponses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_responses();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LobbyResponses::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.CreateGameResponse create_game_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_game_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.SearchGameResponse search_game_response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_search_game_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LobbyResponses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.LobbyResponses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.CreateGameResponse create_game_response = 1;
  if (_internal_has_create_game_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::create_game_response(this),
        _Internal::create_game_response(this).GetCachedSize(), target, stream);
  }

  // .game.SearchGameResponse search_game_response = 2;
  if (_internal_has_search_game_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::search_game_response(this),
        _Internal::search_game_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.LobbyResponses)
  return target;
}

size_t LobbyResponses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.LobbyResponses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (responses_case()) {
    // .game.CreateGameResponse create_game_response = 1;
    case kCreateGameResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.responses_.create_game_response_);
      break;
    }
    // .game.SearchGameResponse search_game_response = 2;
    case kSearchGameResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.responses_.search_game_response_);
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LobbyResponses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LobbyResponses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LobbyResponses::GetClassData() const { return &_class_data_; }


void LobbyResponses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LobbyResponses*>(&to_msg);
  auto& from = static_cast<const LobbyResponses&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.LobbyResponses)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.responses_case()) {
    case kCreateGameResponse: {
      _this->_internal_mutable_create_game_response()->::game::CreateGameResponse::MergeFrom(
          from._internal_create_game_response());
      break;
    }
    case kSearchGameResponse: {
      _this->_internal_mutable_search_game_response()->::game::SearchGameResponse::MergeFrom(
          from._internal_search_game_response());
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LobbyResponses::CopyFrom(const LobbyResponses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.LobbyResponses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LobbyResponses::IsInitialized() const {
  return true;
}

void LobbyResponses::InternalSwap(LobbyResponses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.responses_, other->_impl_.responses_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LobbyResponses::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[12]);
}

// ===================================================================

class CreateGameRequest::_Internal {
 public:
  static const ::game::GameParameters& game_parameters(const CreateGameRequest* msg);
};

const ::game::GameParameters&
CreateGameRequest::_Internal::game_parameters(const CreateGameRequest* msg) {
  return *msg->_impl_.game_parameters_;
}
CreateGameRequest::CreateGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.CreateGameRequest)
}
CreateGameRequest::CreateGameRequest(const CreateGameRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateGameRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.game_parameters_){nullptr}
    , decltype(_impl_.game_owner_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_game_parameters()) {
    _this->_impl_.game_parameters_ = new ::game::GameParameters(*from._impl_.game_parameters_);
  }
  _this->_impl_.game_owner_id_ = from._impl_.game_owner_id_;
  // @@protoc_insertion_point(copy_constructor:game.CreateGameRequest)
}

inline void CreateGameRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.game_parameters_){nullptr}
    , decltype(_impl_.game_owner_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CreateGameRequest::~CreateGameRequest() {
  // @@protoc_insertion_point(destructor:game.CreateGameRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateGameRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.game_parameters_;
}

void CreateGameRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateGameRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:game.CreateGameRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.game_parameters_ != nullptr) {
    delete _impl_.game_parameters_;
  }
  _impl_.game_parameters_ = nullptr;
  _impl_.game_owner_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateGameRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 game_owner_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.game_owner_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.GameParameters game_parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateGameRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.CreateGameRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 game_owner_id = 1;
  if (this->_internal_game_owner_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_game_owner_id(), target);
  }

  // .game.GameParameters game_parameters = 2;
  if (this->_internal_has_game_parameters()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::game_parameters(this),
        _Internal::game_parameters(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.CreateGameRequest)
  return target;
}

size_t CreateGameRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.CreateGameRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .game.GameParameters game_parameters = 2;
  if (this->_internal_has_game_parameters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.game_parameters_);
  }

  // uint32 game_owner_id = 1;
  if (this->_internal_game_owner_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_owner_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateGameRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateGameRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateGameRequest::GetClassData() const { return &_class_data_; }


void CreateGameRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateGameRequest*>(&to_msg);
  auto& from = static_cast<const CreateGameRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.CreateGameRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_game_parameters()) {
    _this->_internal_mutable_game_parameters()->::game::GameParameters::MergeFrom(
        from._internal_game_parameters());
  }
  if (from._internal_game_owner_id() != 0) {
    _this->_internal_set_game_owner_id(from._internal_game_owner_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateGameRequest::CopyFrom(const CreateGameRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.CreateGameRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateGameRequest::IsInitialized() const {
  return true;
}

void CreateGameRequest::InternalSwap(CreateGameRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateGameRequest, _impl_.game_owner_id_)
      + sizeof(CreateGameRequest::_impl_.game_owner_id_)
      - PROTOBUF_FIELD_OFFSET(CreateGameRequest, _impl_.game_parameters_)>(
          reinterpret_cast<char*>(&_impl_.game_parameters_),
          reinterpret_cast<char*>(&other->_impl_.game_parameters_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateGameRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[13]);
}

// ===================================================================

class CreateGameResponse::_Internal {
 public:
  static const ::game::ErrorMessage& msg(const CreateGameResponse* msg);
};

const ::game::ErrorMessage&
CreateGameResponse::_Internal::msg(const CreateGameResponse* msg) {
  return *msg->_impl_.responses_.msg_;
}
void CreateGameResponse::set_allocated_msg(::game::ErrorMessage* msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_responses();
  if (msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg);
    if (message_arena != submessage_arena) {
      msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
    _impl_.responses_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_set_allocated:game.CreateGameResponse.msg)
}
CreateGameResponse::CreateGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.CreateGameResponse)
}
CreateGameResponse::CreateGameResponse(const CreateGameResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateGameResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_responses();
  switch (from.responses_case()) {
    case kGameId: {
      _this->_internal_set_game_id(from._internal_game_id());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.CreateGameResponse)
}

inline void CreateGameResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_responses();
}

CreateGameResponse::~CreateGameResponse() {
  // @@protoc_insertion_point(destructor:game.CreateGameResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateGameResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_responses()) {
    clear_responses();
  }
}

void CreateGameResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateGameResponse::clear_responses() {
// @@protoc_insertion_point(one_of_clear_start:game.CreateGameResponse)
  switch (responses_case()) {
    case kGameId: {
      // No need to clear
      break;
    }
    case kMsg: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.responses_.msg_;
      }
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}


void CreateGameResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:game.CreateGameResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_responses();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateGameResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 game_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_game_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.ErrorMessage msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateGameResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.CreateGameResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 game_id = 1;
  if (_internal_has_game_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_game_id(), target);
  }

  // .game.ErrorMessage msg = 2;
  if (_internal_has_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::msg(this),
        _Internal::msg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.CreateGameResponse)
  return target;
}

size_t CreateGameResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.CreateGameResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (responses_case()) {
    // uint32 game_id = 1;
    case kGameId: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_id());
      break;
    }
    // .game.ErrorMessage msg = 2;
    case kMsg: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.responses_.msg_);
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateGameResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateGameResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateGameResponse::GetClassData() const { return &_class_data_; }


void CreateGameResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateGameResponse*>(&to_msg);
  auto& from = static_cast<const CreateGameResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.CreateGameResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.responses_case()) {
    case kGameId: {
      _this->_internal_set_game_id(from._internal_game_id());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateGameResponse::CopyFrom(const CreateGameResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.CreateGameResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateGameResponse::IsInitialized() const {
  return true;
}

void CreateGameResponse::InternalSwap(CreateGameResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.responses_, other->_impl_.responses_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateGameResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[14]);
}

// ===================================================================

class SearchGameRequest::_Internal {
 public:
  static const ::game::GameParameters& game_parameters(const SearchGameRequest* msg);
};

const ::game::GameParameters&
SearchGameRequest::_Internal::game_parameters(const SearchGameRequest* msg) {
  return *msg->_impl_.game_parameters_;
}
SearchGameRequest::SearchGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.SearchGameRequest)
}
SearchGameRequest::SearchGameRequest(const SearchGameRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SearchGameRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.game_parameters_){nullptr}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_game_parameters()) {
    _this->_impl_.game_parameters_ = new ::game::GameParameters(*from._impl_.game_parameters_);
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:game.SearchGameRequest)
}

inline void SearchGameRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.game_parameters_){nullptr}
    , decltype(_impl_.id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SearchGameRequest::~SearchGameRequest() {
  // @@protoc_insertion_point(destructor:game.SearchGameRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SearchGameRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.game_parameters_;
}

void SearchGameRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SearchGameRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:game.SearchGameRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.game_parameters_ != nullptr) {
    delete _impl_.game_parameters_;
  }
  _impl_.game_parameters_ = nullptr;
  _impl_.id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SearchGameRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.GameParameters game_parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SearchGameRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.SearchGameRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // .game.GameParameters game_parameters = 2;
  if (this->_internal_has_game_parameters()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::game_parameters(this),
        _Internal::game_parameters(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.SearchGameRequest)
  return target;
}

size_t SearchGameRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.SearchGameRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .game.GameParameters game_parameters = 2;
  if (this->_internal_has_game_parameters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.game_parameters_);
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SearchGameRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SearchGameRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SearchGameRequest::GetClassData() const { return &_class_data_; }


void SearchGameRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SearchGameRequest*>(&to_msg);
  auto& from = static_cast<const SearchGameRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.SearchGameRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_game_parameters()) {
    _this->_internal_mutable_game_parameters()->::game::GameParameters::MergeFrom(
        from._internal_game_parameters());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SearchGameRequest::CopyFrom(const SearchGameRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.SearchGameRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SearchGameRequest::IsInitialized() const {
  return true;
}

void SearchGameRequest::InternalSwap(SearchGameRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SearchGameRequest, _impl_.id_)
      + sizeof(SearchGameRequest::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(SearchGameRequest, _impl_.game_parameters_)>(
          reinterpret_cast<char*>(&_impl_.game_parameters_),
          reinterpret_cast<char*>(&other->_impl_.game_parameters_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SearchGameRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[15]);
}

// ===================================================================

class SearchGameResponse::_Internal {
 public:
  static const ::game::ErrorMessage& msg(const SearchGameResponse* msg);
};

const ::game::ErrorMessage&
SearchGameResponse::_Internal::msg(const SearchGameResponse* msg) {
  return *msg->_impl_.responses_.msg_;
}
void SearchGameResponse::set_allocated_msg(::game::ErrorMessage* msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_responses();
  if (msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg);
    if (message_arena != submessage_arena) {
      msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
    _impl_.responses_.msg_ = msg;
  }
  // @@protoc_insertion_point(field_set_allocated:game.SearchGameResponse.msg)
}
SearchGameResponse::SearchGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.SearchGameResponse)
}
SearchGameResponse::SearchGameResponse(const SearchGameResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SearchGameResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_responses();
  switch (from.responses_case()) {
    case kGameId: {
      _this->_internal_set_game_id(from._internal_game_id());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.SearchGameResponse)
}

inline void SearchGameResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_responses();
}

SearchGameResponse::~SearchGameResponse() {
  // @@protoc_insertion_point(destructor:game.SearchGameResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SearchGameResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_responses()) {
    clear_responses();
  }
}

void SearchGameResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SearchGameResponse::clear_responses() {
// @@protoc_insertion_point(one_of_clear_start:game.SearchGameResponse)
  switch (responses_case()) {
    case kGameId: {
      // No need to clear
      break;
    }
    case kMsg: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.responses_.msg_;
      }
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}


void SearchGameResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:game.SearchGameResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_responses();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SearchGameResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 game_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_game_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.ErrorMessage msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SearchGameResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.SearchGameResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 game_id = 1;
  if (_internal_has_game_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_game_id(), target);
  }

  // .game.ErrorMessage msg = 2;
  if (_internal_has_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::msg(this),
        _Internal::msg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.SearchGameResponse)
  return target;
}

size_t SearchGameResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.SearchGameResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (responses_case()) {
    // uint32 game_id = 1;
    case kGameId: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_id());
      break;
    }
    // .game.ErrorMessage msg = 2;
    case kMsg: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.responses_.msg_);
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SearchGameResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SearchGameResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SearchGameResponse::GetClassData() const { return &_class_data_; }


void SearchGameResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SearchGameResponse*>(&to_msg);
  auto& from = static_cast<const SearchGameResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.SearchGameResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.responses_case()) {
    case kGameId: {
      _this->_internal_set_game_id(from._internal_game_id());
      break;
    }
    case kMsg: {
      _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
          from._internal_msg());
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SearchGameResponse::CopyFrom(const SearchGameResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.SearchGameResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SearchGameResponse::IsInitialized() const {
  return true;
}

void SearchGameResponse::InternalSwap(SearchGameResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.responses_, other->_impl_.responses_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SearchGameResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[16]);
}

// ===================================================================

class GameParameters::_Internal {
 public:
};

GameParameters::GameParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.GameParameters)
}
GameParameters::GameParameters(const GameParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.game_name_){}
    , decltype(_impl_.number_of_players_){}
    , decltype(_impl_.minimal_bet_){}
    , decltype(_impl_.game_enter_balance_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.game_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_game_name().empty()) {
    _this->_impl_.game_name_.Set(from._internal_game_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.number_of_players_, &from._impl_.number_of_players_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.game_enter_balance_) -
    reinterpret_cast<char*>(&_impl_.number_of_players_)) + sizeof(_impl_.game_enter_balance_));
  // @@protoc_insertion_point(copy_constructor:game.GameParameters)
}

inline void GameParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.game_name_){}
    , decltype(_impl_.number_of_players_){0u}
    , decltype(_impl_.minimal_bet_){0u}
    , decltype(_impl_.game_enter_balance_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.game_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GameParameters::~GameParameters() {
  // @@protoc_insertion_point(destructor:game.GameParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.game_name_.Destroy();
}

void GameParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:game.GameParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.game_name_.ClearToEmpty();
  ::memset(&_impl_.number_of_players_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.game_enter_balance_) -
      reinterpret_cast<char*>(&_impl_.number_of_players_)) + sizeof(_impl_.game_enter_balance_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string game_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_game_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.GameParameters.game_name"));
        } else
          goto handle_unusual;
        continue;
      // uint32 number_of_players = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.number_of_players_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 minimal_bet = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.minimal_bet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 game_enter_balance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.game_enter_balance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.GameParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string game_name = 1;
  if (!this->_internal_game_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_game_name().data(), static_cast<int>(this->_internal_game_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.GameParameters.game_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_game_name(), target);
  }

  // uint32 number_of_players = 2;
  if (this->_internal_number_of_players() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_number_of_players(), target);
  }

  // uint32 minimal_bet = 3;
  if (this->_internal_minimal_bet() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_minimal_bet(), target);
  }

  // uint32 game_enter_balance = 4;
  if (this->_internal_game_enter_balance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_game_enter_balance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.GameParameters)
  return target;
}

size_t GameParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.GameParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string game_name = 1;
  if (!this->_internal_game_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_game_name());
  }

  // uint32 number_of_players = 2;
  if (this->_internal_number_of_players() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_players());
  }

  // uint32 minimal_bet = 3;
  if (this->_internal_minimal_bet() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_minimal_bet());
  }

  // uint32 game_enter_balance = 4;
  if (this->_internal_game_enter_balance() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_enter_balance());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameParameters::GetClassData() const { return &_class_data_; }


void GameParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameParameters*>(&to_msg);
  auto& from = static_cast<const GameParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.GameParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_game_name().empty()) {
    _this->_internal_set_game_name(from._internal_game_name());
  }
  if (from._internal_number_of_players() != 0) {
    _this->_internal_set_number_of_players(from._internal_number_of_players());
  }
  if (from._internal_minimal_bet() != 0) {
    _this->_internal_set_minimal_bet(from._internal_minimal_bet());
  }
  if (from._internal_game_enter_balance() != 0) {
    _this->_internal_set_game_enter_balance(from._internal_game_enter_balance());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameParameters::CopyFrom(const GameParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.GameParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameParameters::IsInitialized() const {
  return true;
}

void GameParameters::InternalSwap(GameParameters* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_name_, lhs_arena,
      &other->_impl_.game_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameParameters, _impl_.game_enter_balance_)
      + sizeof(GameParameters::_impl_.game_enter_balance_)
      - PROTOBUF_FIELD_OFFSET(GameParameters, _impl_.number_of_players_)>(
          reinterpret_cast<char*>(&_impl_.number_of_players_),
          reinterpret_cast<char*>(&other->_impl_.number_of_players_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[17]);
}

// ===================================================================

class PlayerInfo::_Internal {
 public:
};

PlayerInfo::PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.PlayerInfo)
}
PlayerInfo::PlayerInfo(const PlayerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.client_id_){}
    , decltype(_impl_.client_games_){}
    , decltype(_impl_.client_wins_){}
    , decltype(_impl_.client_balance_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.client_id_, &from._impl_.client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.client_balance_) -
    reinterpret_cast<char*>(&_impl_.client_id_)) + sizeof(_impl_.client_balance_));
  // @@protoc_insertion_point(copy_constructor:game.PlayerInfo)
}

inline void PlayerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.client_id_){0u}
    , decltype(_impl_.client_games_){0u}
    , decltype(_impl_.client_wins_){0u}
    , decltype(_impl_.client_balance_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerInfo::~PlayerInfo() {
  // @@protoc_insertion_point(destructor:game.PlayerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:game.PlayerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.client_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.client_balance_) -
      reinterpret_cast<char*>(&_impl_.client_id_)) + sizeof(_impl_.client_balance_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 client_games = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.client_games_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 client_wins = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.client_wins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 client_balance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.client_balance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.PlayerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 client_id = 1;
  if (this->_internal_client_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_client_id(), target);
  }

  // uint32 client_games = 2;
  if (this->_internal_client_games() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_client_games(), target);
  }

  // uint32 client_wins = 3;
  if (this->_internal_client_wins() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_client_wins(), target);
  }

  // uint32 client_balance = 4;
  if (this->_internal_client_balance() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_client_balance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.PlayerInfo)
  return target;
}

size_t PlayerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.PlayerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 client_id = 1;
  if (this->_internal_client_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_id());
  }

  // uint32 client_games = 2;
  if (this->_internal_client_games() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_games());
  }

  // uint32 client_wins = 3;
  if (this->_internal_client_wins() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_wins());
  }

  // uint32 client_balance = 4;
  if (this->_internal_client_balance() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_balance());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerInfo::GetClassData() const { return &_class_data_; }


void PlayerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerInfo*>(&to_msg);
  auto& from = static_cast<const PlayerInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.PlayerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_client_id() != 0) {
    _this->_internal_set_client_id(from._internal_client_id());
  }
  if (from._internal_client_games() != 0) {
    _this->_internal_set_client_games(from._internal_client_games());
  }
  if (from._internal_client_wins() != 0) {
    _this->_internal_set_client_wins(from._internal_client_wins());
  }
  if (from._internal_client_balance() != 0) {
    _this->_internal_set_client_balance(from._internal_client_balance());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerInfo::CopyFrom(const PlayerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.PlayerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerInfo::IsInitialized() const {
  return true;
}

void PlayerInfo::InternalSwap(PlayerInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerInfo, _impl_.client_balance_)
      + sizeof(PlayerInfo::_impl_.client_balance_)
      - PROTOBUF_FIELD_OFFSET(PlayerInfo, _impl_.client_id_)>(
          reinterpret_cast<char*>(&_impl_.client_id_),
          reinterpret_cast<char*>(&other->_impl_.client_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[18]);
}

// ===================================================================

class GameRequests::_Internal {
 public:
  static const ::game::MakeMoveRequest& make_move_request(const GameRequests* msg);
  static const ::game::JoinGameRequest& join_game_request(const GameRequests* msg);
  static const ::game::JoinGameAsOwnerRequest& join_game_as_owner_request(const GameRequests* msg);
};

const ::game::MakeMoveRequest&
GameRequests::_Internal::make_move_request(const GameRequests* msg) {
  return *msg->_impl_.requests_.make_move_request_;
}
const ::game::JoinGameRequest&
GameRequests::_Internal::join_game_request(const GameRequests* msg) {
  return *msg->_impl_.requests_.join_game_request_;
}
const ::game::JoinGameAsOwnerRequest&
GameRequests::_Internal::join_game_as_owner_request(const GameRequests* msg) {
  return *msg->_impl_.requests_.join_game_as_owner_request_;
}
void GameRequests::set_allocated_make_move_request(::game::MakeMoveRequest* make_move_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_requests();
  if (make_move_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(make_move_request);
    if (message_arena != submessage_arena) {
      make_move_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, make_move_request, submessage_arena);
    }
    set_has_make_move_request();
    _impl_.requests_.make_move_request_ = make_move_request;
  }
  // @@protoc_insertion_point(field_set_allocated:game.GameRequests.make_move_request)
}
void GameRequests::set_allocated_join_game_request(::game::JoinGameRequest* join_game_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_requests();
  if (join_game_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join_game_request);
    if (message_arena != submessage_arena) {
      join_game_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join_game_request, submessage_arena);
    }
    set_has_join_game_request();
    _impl_.requests_.join_game_request_ = join_game_request;
  }
  // @@protoc_insertion_point(field_set_allocated:game.GameRequests.join_game_request)
}
void GameRequests::set_allocated_join_game_as_owner_request(::game::JoinGameAsOwnerRequest* join_game_as_owner_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_requests();
  if (join_game_as_owner_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join_game_as_owner_request);
    if (message_arena != submessage_arena) {
      join_game_as_owner_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join_game_as_owner_request, submessage_arena);
    }
    set_has_join_game_as_owner_request();
    _impl_.requests_.join_game_as_owner_request_ = join_game_as_owner_request;
  }
  // @@protoc_insertion_point(field_set_allocated:game.GameRequests.join_game_as_owner_request)
}
GameRequests::GameRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.GameRequests)
}
GameRequests::GameRequests(const GameRequests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameRequests* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_requests();
  switch (from.requests_case()) {
    case kMakeMoveRequest: {
      _this->_internal_mutable_make_move_request()->::game::MakeMoveRequest::MergeFrom(
          from._internal_make_move_request());
      break;
    }
    case kJoinGameRequest: {
      _this->_internal_mutable_join_game_request()->::game::JoinGameRequest::MergeFrom(
          from._internal_join_game_request());
      break;
    }
    case kJoinGameAsOwnerRequest: {
      _this->_internal_mutable_join_game_as_owner_request()->::game::JoinGameAsOwnerRequest::MergeFrom(
          from._internal_join_game_as_owner_request());
      break;
    }
    case REQUESTS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.GameRequests)
}

inline void GameRequests::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_requests();
}

GameRequests::~GameRequests() {
  // @@protoc_insertion_point(destructor:game.GameRequests)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameRequests::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_requests()) {
    clear_requests();
  }
}

void GameRequests::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameRequests::clear_requests() {
// @@protoc_insertion_point(one_of_clear_start:game.GameRequests)
  switch (requests_case()) {
    case kMakeMoveRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.requests_.make_move_request_;
      }
      break;
    }
    case kJoinGameRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.requests_.join_game_request_;
      }
      break;
    }
    case kJoinGameAsOwnerRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.requests_.join_game_as_owner_request_;
      }
      break;
    }
    case REQUESTS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = REQUESTS_NOT_SET;
}


void GameRequests::Clear() {
// @@protoc_insertion_point(message_clear_start:game.GameRequests)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_requests();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameRequests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.MakeMoveRequest make_move_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_make_move_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.JoinGameRequest join_game_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_join_game_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.JoinGameAsOwnerRequest join_game_as_owner_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_join_game_as_owner_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameRequests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.GameRequests)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.MakeMoveRequest make_move_request = 1;
  if (_internal_has_make_move_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::make_move_request(this),
        _Internal::make_move_request(this).GetCachedSize(), target, stream);
  }

  // .game.JoinGameRequest join_game_request = 2;
  if (_internal_has_join_game_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::join_game_request(this),
        _Internal::join_game_request(this).GetCachedSize(), target, stream);
  }

  // .game.JoinGameAsOwnerRequest join_game_as_owner_request = 3;
  if (_internal_has_join_game_as_owner_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::join_game_as_owner_request(this),
        _Internal::join_game_as_owner_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.GameRequests)
  return target;
}

size_t GameRequests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.GameRequests)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (requests_case()) {
    // .game.MakeMoveRequest make_move_request = 1;
    case kMakeMoveRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.requests_.make_move_request_);
      break;
    }
    // .game.JoinGameRequest join_game_request = 2;
    case kJoinGameRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.requests_.join_game_request_);
      break;
    }
    // .game.JoinGameAsOwnerRequest join_game_as_owner_request = 3;
    case kJoinGameAsOwnerRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.requests_.join_game_as_owner_request_);
      break;
    }
    case REQUESTS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameRequests::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameRequests::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameRequests::GetClassData() const { return &_class_data_; }


void GameRequests::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameRequests*>(&to_msg);
  auto& from = static_cast<const GameRequests&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.GameRequests)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.requests_case()) {
    case kMakeMoveRequest: {
      _this->_internal_mutable_make_move_request()->::game::MakeMoveRequest::MergeFrom(
          from._internal_make_move_request());
      break;
    }
    case kJoinGameRequest: {
      _this->_internal_mutable_join_game_request()->::game::JoinGameRequest::MergeFrom(
          from._internal_join_game_request());
      break;
    }
    case kJoinGameAsOwnerRequest: {
      _this->_internal_mutable_join_game_as_owner_request()->::game::JoinGameAsOwnerRequest::MergeFrom(
          from._internal_join_game_as_owner_request());
      break;
    }
    case REQUESTS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameRequests::CopyFrom(const GameRequests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.GameRequests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameRequests::IsInitialized() const {
  return true;
}

void GameRequests::InternalSwap(GameRequests* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.requests_, other->_impl_.requests_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameRequests::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[19]);
}

// ===================================================================

class GameResponses::_Internal {
 public:
  static const ::game::MakeMoveResponse& make_move_response(const GameResponses* msg);
  static const ::game::GameState& game_state(const GameResponses* msg);
  static const ::game::JoinGameResponse& join_game_response(const GameResponses* msg);
  static const ::game::JoinGameAsOwnerResponse& join_game_as_owner_response(const GameResponses* msg);
};

const ::game::MakeMoveResponse&
GameResponses::_Internal::make_move_response(const GameResponses* msg) {
  return *msg->_impl_.responses_.make_move_response_;
}
const ::game::GameState&
GameResponses::_Internal::game_state(const GameResponses* msg) {
  return *msg->_impl_.responses_.game_state_;
}
const ::game::JoinGameResponse&
GameResponses::_Internal::join_game_response(const GameResponses* msg) {
  return *msg->_impl_.responses_.join_game_response_;
}
const ::game::JoinGameAsOwnerResponse&
GameResponses::_Internal::join_game_as_owner_response(const GameResponses* msg) {
  return *msg->_impl_.responses_.join_game_as_owner_response_;
}
void GameResponses::set_allocated_make_move_response(::game::MakeMoveResponse* make_move_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_responses();
  if (make_move_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(make_move_response);
    if (message_arena != submessage_arena) {
      make_move_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, make_move_response, submessage_arena);
    }
    set_has_make_move_response();
    _impl_.responses_.make_move_response_ = make_move_response;
  }
  // @@protoc_insertion_point(field_set_allocated:game.GameResponses.make_move_response)
}
void GameResponses::set_allocated_game_state(::game::GameState* game_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_responses();
  if (game_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(game_state);
    if (message_arena != submessage_arena) {
      game_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_state, submessage_arena);
    }
    set_has_game_state();
    _impl_.responses_.game_state_ = game_state;
  }
  // @@protoc_insertion_point(field_set_allocated:game.GameResponses.game_state)
}
void GameResponses::set_allocated_join_game_response(::game::JoinGameResponse* join_game_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_responses();
  if (join_game_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join_game_response);
    if (message_arena != submessage_arena) {
      join_game_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join_game_response, submessage_arena);
    }
    set_has_join_game_response();
    _impl_.responses_.join_game_response_ = join_game_response;
  }
  // @@protoc_insertion_point(field_set_allocated:game.GameResponses.join_game_response)
}
void GameResponses::set_allocated_join_game_as_owner_response(::game::JoinGameAsOwnerResponse* join_game_as_owner_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_responses();
  if (join_game_as_owner_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join_game_as_owner_response);
    if (message_arena != submessage_arena) {
      join_game_as_owner_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join_game_as_owner_response, submessage_arena);
    }
    set_has_join_game_as_owner_response();
    _impl_.responses_.join_game_as_owner_response_ = join_game_as_owner_response;
  }
  // @@protoc_insertion_point(field_set_allocated:game.GameResponses.join_game_as_owner_response)
}
GameResponses::GameResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.GameResponses)
}
GameResponses::GameResponses(const GameResponses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameResponses* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_responses();
  switch (from.responses_case()) {
    case kMakeMoveResponse: {
      _this->_internal_mutable_make_move_response()->::game::MakeMoveResponse::MergeFrom(
          from._internal_make_move_response());
      break;
    }
    case kGameState: {
      _this->_internal_mutable_game_state()->::game::GameState::MergeFrom(
          from._internal_game_state());
      break;
    }
    case kJoinGameResponse: {
      _this->_internal_mutable_join_game_response()->::game::JoinGameResponse::MergeFrom(
          from._internal_join_game_response());
      break;
    }
    case kJoinGameAsOwnerResponse: {
      _this->_internal_mutable_join_game_as_owner_response()->::game::JoinGameAsOwnerResponse::MergeFrom(
          from._internal_join_game_as_owner_response());
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:game.GameResponses)
}

inline void GameResponses::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_responses();
}

GameResponses::~GameResponses() {
  // @@protoc_insertion_point(destructor:game.GameResponses)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameResponses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_responses()) {
    clear_responses();
  }
}

void GameResponses::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameResponses::clear_responses() {
// @@protoc_insertion_point(one_of_clear_start:game.GameResponses)
  switch (responses_case()) {
    case kMakeMoveResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.responses_.make_move_response_;
      }
      break;
    }
    case kGameState: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.responses_.game_state_;
      }
      break;
    }
    case kJoinGameResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.responses_.join_game_response_;
      }
      break;
    }
    case kJoinGameAsOwnerResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.responses_.join_game_as_owner_response_;
      }
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESPONSES_NOT_SET;
}


void GameResponses::Clear() {
// @@protoc_insertion_point(message_clear_start:game.GameResponses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_responses();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameResponses::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.MakeMoveResponse make_move_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_make_move_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.GameState game_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.JoinGameResponse join_game_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_join_game_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.JoinGameAsOwnerResponse join_game_as_owner_response = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_join_game_as_owner_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameResponses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.GameResponses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.MakeMoveResponse make_move_response = 1;
  if (_internal_has_make_move_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::make_move_response(this),
        _Internal::make_move_response(this).GetCachedSize(), target, stream);
  }

  // .game.GameState game_state = 2;
  if (_internal_has_game_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::game_state(this),
        _Internal::game_state(this).GetCachedSize(), target, stream);
  }

  // .game.JoinGameResponse join_game_response = 3;
  if (_internal_has_join_game_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::join_game_response(this),
        _Internal::join_game_response(this).GetCachedSize(), target, stream);
  }

  // .game.JoinGameAsOwnerResponse join_game_as_owner_response = 4;
  if (_internal_has_join_game_as_owner_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::join_game_as_owner_response(this),
        _Internal::join_game_as_owner_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.GameResponses)
  return target;
}

size_t GameResponses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.GameResponses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (responses_case()) {
    // .game.MakeMoveResponse make_move_response = 1;
    case kMakeMoveResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.responses_.make_move_response_);
      break;
    }
    // .game.GameState game_state = 2;
    case kGameState: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.responses_.game_state_);
      break;
    }
    // .game.JoinGameResponse join_game_response = 3;
    case kJoinGameResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.responses_.join_game_response_);
      break;
    }
    // .game.JoinGameAsOwnerResponse join_game_as_owner_response = 4;
    case kJoinGameAsOwnerResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.responses_.join_game_as_owner_response_);
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameResponses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameResponses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameResponses::GetClassData() const { return &_class_data_; }


void GameResponses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameResponses*>(&to_msg);
  auto& from = static_cast<const GameResponses&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.GameResponses)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.responses_case()) {
    case kMakeMoveResponse: {
      _this->_internal_mutable_make_move_response()->::game::MakeMoveResponse::MergeFrom(
          from._internal_make_move_response());
      break;
    }
    case kGameState: {
      _this->_internal_mutable_game_state()->::game::GameState::MergeFrom(
          from._internal_game_state());
      break;
    }
    case kJoinGameResponse: {
      _this->_internal_mutable_join_game_response()->::game::JoinGameResponse::MergeFrom(
          from._internal_join_game_response());
      break;
    }
    case kJoinGameAsOwnerResponse: {
      _this->_internal_mutable_join_game_as_owner_response()->::game::JoinGameAsOwnerResponse::MergeFrom(
          from._internal_join_game_as_owner_response());
      break;
    }
    case RESPONSES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameResponses::CopyFrom(const GameResponses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.GameResponses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameResponses::IsInitialized() const {
  return true;
}

void GameResponses::InternalSwap(GameResponses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.responses_, other->_impl_.responses_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameResponses::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[20]);
}

// ===================================================================

class JoinGameRequest::_Internal {
 public:
  static const ::game::PlayerInfo& player_info(const JoinGameRequest* msg);
};

const ::game::PlayerInfo&
JoinGameRequest::_Internal::player_info(const JoinGameRequest* msg) {
  return *msg->_impl_.player_info_;
}
JoinGameRequest::JoinGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.JoinGameRequest)
}
JoinGameRequest::JoinGameRequest(const JoinGameRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  JoinGameRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_name_){}
    , decltype(_impl_.player_info_){nullptr}
    , decltype(_impl_.game_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_player_name().empty()) {
    _this->_impl_.player_name_.Set(from._internal_player_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_player_info()) {
    _this->_impl_.player_info_ = new ::game::PlayerInfo(*from._impl_.player_info_);
  }
  _this->_impl_.game_id_ = from._impl_.game_id_;
  // @@protoc_insertion_point(copy_constructor:game.JoinGameRequest)
}

inline void JoinGameRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_name_){}
    , decltype(_impl_.player_info_){nullptr}
    , decltype(_impl_.game_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

JoinGameRequest::~JoinGameRequest() {
  // @@protoc_insertion_point(destructor:game.JoinGameRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JoinGameRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.player_info_;
}

void JoinGameRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void JoinGameRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:game.JoinGameRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.player_info_ != nullptr) {
    delete _impl_.player_info_;
  }
  _impl_.player_info_ = nullptr;
  _impl_.game_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinGameRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 game_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string player_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_player_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.JoinGameRequest.player_name"));
        } else
          goto handle_unusual;
        continue;
      // .game.PlayerInfo player_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinGameRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.JoinGameRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 game_id = 1;
  if (this->_internal_game_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_game_id(), target);
  }

  // string player_name = 2;
  if (!this->_internal_player_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_player_name().data(), static_cast<int>(this->_internal_player_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.JoinGameRequest.player_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_player_name(), target);
  }

  // .game.PlayerInfo player_info = 3;
  if (this->_internal_has_player_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::player_info(this),
        _Internal::player_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.JoinGameRequest)
  return target;
}

size_t JoinGameRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.JoinGameRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string player_name = 2;
  if (!this->_internal_player_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_player_name());
  }

  // .game.PlayerInfo player_info = 3;
  if (this->_internal_has_player_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_info_);
  }

  // uint32 game_id = 1;
  if (this->_internal_game_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinGameRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    JoinGameRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinGameRequest::GetClassData() const { return &_class_data_; }


void JoinGameRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<JoinGameRequest*>(&to_msg);
  auto& from = static_cast<const JoinGameRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.JoinGameRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_player_name().empty()) {
    _this->_internal_set_player_name(from._internal_player_name());
  }
  if (from._internal_has_player_info()) {
    _this->_internal_mutable_player_info()->::game::PlayerInfo::MergeFrom(
        from._internal_player_info());
  }
  if (from._internal_game_id() != 0) {
    _this->_internal_set_game_id(from._internal_game_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinGameRequest::CopyFrom(const JoinGameRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.JoinGameRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinGameRequest::IsInitialized() const {
  return true;
}

void JoinGameRequest::InternalSwap(JoinGameRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.player_name_, lhs_arena,
      &other->_impl_.player_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinGameRequest, _impl_.game_id_)
      + sizeof(JoinGameRequest::_impl_.game_id_)
      - PROTOBUF_FIELD_OFFSET(JoinGameRequest, _impl_.player_info_)>(
          reinterpret_cast<char*>(&_impl_.player_info_),
          reinterpret_cast<char*>(&other->_impl_.player_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinGameRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[21]);
}

// ===================================================================

class JoinGameResponse::_Internal {
 public:
  static const ::game::GameState& game_state(const JoinGameResponse* msg);
  static const ::game::ErrorMessage& msg(const JoinGameResponse* msg);
};

const ::game::GameState&
JoinGameResponse::_Internal::game_state(const JoinGameResponse* msg) {
  return *msg->_impl_.game_state_;
}
const ::game::ErrorMessage&
JoinGameResponse::_Internal::msg(const JoinGameResponse* msg) {
  return *msg->_impl_.msg_;
}
JoinGameResponse::JoinGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.JoinGameResponse)
}
JoinGameResponse::JoinGameResponse(const JoinGameResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  JoinGameResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.game_state_){nullptr}
    , decltype(_impl_.msg_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_game_state()) {
    _this->_impl_.game_state_ = new ::game::GameState(*from._impl_.game_state_);
  }
  if (from._internal_has_msg()) {
    _this->_impl_.msg_ = new ::game::ErrorMessage(*from._impl_.msg_);
  }
  // @@protoc_insertion_point(copy_constructor:game.JoinGameResponse)
}

inline void JoinGameResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.game_state_){nullptr}
    , decltype(_impl_.msg_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

JoinGameResponse::~JoinGameResponse() {
  // @@protoc_insertion_point(destructor:game.JoinGameResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JoinGameResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.game_state_;
  if (this != internal_default_instance()) delete _impl_.msg_;
}

void JoinGameResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void JoinGameResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:game.JoinGameResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.game_state_ != nullptr) {
    delete _impl_.game_state_;
  }
  _impl_.game_state_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.msg_ != nullptr) {
    delete _impl_.msg_;
  }
  _impl_.msg_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinGameResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.GameState game_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.ErrorMessage msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinGameResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.JoinGameResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.GameState game_state = 1;
  if (this->_internal_has_game_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::game_state(this),
        _Internal::game_state(this).GetCachedSize(), target, stream);
  }

  // .game.ErrorMessage msg = 2;
  if (this->_internal_has_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::msg(this),
        _Internal::msg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.JoinGameResponse)
  return target;
}

size_t JoinGameResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.JoinGameResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .game.GameState game_state = 1;
  if (this->_internal_has_game_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.game_state_);
  }

  // .game.ErrorMessage msg = 2;
  if (this->_internal_has_msg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.msg_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinGameResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    JoinGameResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinGameResponse::GetClassData() const { return &_class_data_; }


void JoinGameResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<JoinGameResponse*>(&to_msg);
  auto& from = static_cast<const JoinGameResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.JoinGameResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_game_state()) {
    _this->_internal_mutable_game_state()->::game::GameState::MergeFrom(
        from._internal_game_state());
  }
  if (from._internal_has_msg()) {
    _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
        from._internal_msg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinGameResponse::CopyFrom(const JoinGameResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.JoinGameResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinGameResponse::IsInitialized() const {
  return true;
}

void JoinGameResponse::InternalSwap(JoinGameResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinGameResponse, _impl_.msg_)
      + sizeof(JoinGameResponse::_impl_.msg_)
      - PROTOBUF_FIELD_OFFSET(JoinGameResponse, _impl_.game_state_)>(
          reinterpret_cast<char*>(&_impl_.game_state_),
          reinterpret_cast<char*>(&other->_impl_.game_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinGameResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[22]);
}

// ===================================================================

class JoinGameAsOwnerRequest::_Internal {
 public:
  static const ::game::PlayerInfo& player_info(const JoinGameAsOwnerRequest* msg);
};

const ::game::PlayerInfo&
JoinGameAsOwnerRequest::_Internal::player_info(const JoinGameAsOwnerRequest* msg) {
  return *msg->_impl_.player_info_;
}
JoinGameAsOwnerRequest::JoinGameAsOwnerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.JoinGameAsOwnerRequest)
}
JoinGameAsOwnerRequest::JoinGameAsOwnerRequest(const JoinGameAsOwnerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  JoinGameAsOwnerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_name_){}
    , decltype(_impl_.player_info_){nullptr}
    , decltype(_impl_.game_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_player_name().empty()) {
    _this->_impl_.player_name_.Set(from._internal_player_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_player_info()) {
    _this->_impl_.player_info_ = new ::game::PlayerInfo(*from._impl_.player_info_);
  }
  _this->_impl_.game_id_ = from._impl_.game_id_;
  // @@protoc_insertion_point(copy_constructor:game.JoinGameAsOwnerRequest)
}

inline void JoinGameAsOwnerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_name_){}
    , decltype(_impl_.player_info_){nullptr}
    , decltype(_impl_.game_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

JoinGameAsOwnerRequest::~JoinGameAsOwnerRequest() {
  // @@protoc_insertion_point(destructor:game.JoinGameAsOwnerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JoinGameAsOwnerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.player_info_;
}

void JoinGameAsOwnerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void JoinGameAsOwnerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:game.JoinGameAsOwnerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.player_info_ != nullptr) {
    delete _impl_.player_info_;
  }
  _impl_.player_info_ = nullptr;
  _impl_.game_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinGameAsOwnerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 game_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string player_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_player_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "game.JoinGameAsOwnerRequest.player_name"));
        } else
          goto handle_unusual;
        continue;
      // .game.PlayerInfo player_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinGameAsOwnerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.JoinGameAsOwnerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 game_id = 1;
  if (this->_internal_game_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_game_id(), target);
  }

  // string player_name = 2;
  if (!this->_internal_player_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_player_name().data(), static_cast<int>(this->_internal_player_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.JoinGameAsOwnerRequest.player_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_player_name(), target);
  }

  // .game.PlayerInfo player_info = 3;
  if (this->_internal_has_player_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::player_info(this),
        _Internal::player_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.JoinGameAsOwnerRequest)
  return target;
}

size_t JoinGameAsOwnerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.JoinGameAsOwnerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string player_name = 2;
  if (!this->_internal_player_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_player_name());
  }

  // .game.PlayerInfo player_info = 3;
  if (this->_internal_has_player_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_info_);
  }

  // uint32 game_id = 1;
  if (this->_internal_game_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinGameAsOwnerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    JoinGameAsOwnerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinGameAsOwnerRequest::GetClassData() const { return &_class_data_; }


void JoinGameAsOwnerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<JoinGameAsOwnerRequest*>(&to_msg);
  auto& from = static_cast<const JoinGameAsOwnerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.JoinGameAsOwnerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_player_name().empty()) {
    _this->_internal_set_player_name(from._internal_player_name());
  }
  if (from._internal_has_player_info()) {
    _this->_internal_mutable_player_info()->::game::PlayerInfo::MergeFrom(
        from._internal_player_info());
  }
  if (from._internal_game_id() != 0) {
    _this->_internal_set_game_id(from._internal_game_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinGameAsOwnerRequest::CopyFrom(const JoinGameAsOwnerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.JoinGameAsOwnerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinGameAsOwnerRequest::IsInitialized() const {
  return true;
}

void JoinGameAsOwnerRequest::InternalSwap(JoinGameAsOwnerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.player_name_, lhs_arena,
      &other->_impl_.player_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinGameAsOwnerRequest, _impl_.game_id_)
      + sizeof(JoinGameAsOwnerRequest::_impl_.game_id_)
      - PROTOBUF_FIELD_OFFSET(JoinGameAsOwnerRequest, _impl_.player_info_)>(
          reinterpret_cast<char*>(&_impl_.player_info_),
          reinterpret_cast<char*>(&other->_impl_.player_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinGameAsOwnerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[23]);
}

// ===================================================================

class JoinGameAsOwnerResponse::_Internal {
 public:
  static const ::game::GameState& game_state(const JoinGameAsOwnerResponse* msg);
  static const ::game::ErrorMessage& msg(const JoinGameAsOwnerResponse* msg);
};

const ::game::GameState&
JoinGameAsOwnerResponse::_Internal::game_state(const JoinGameAsOwnerResponse* msg) {
  return *msg->_impl_.game_state_;
}
const ::game::ErrorMessage&
JoinGameAsOwnerResponse::_Internal::msg(const JoinGameAsOwnerResponse* msg) {
  return *msg->_impl_.msg_;
}
JoinGameAsOwnerResponse::JoinGameAsOwnerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.JoinGameAsOwnerResponse)
}
JoinGameAsOwnerResponse::JoinGameAsOwnerResponse(const JoinGameAsOwnerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  JoinGameAsOwnerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.game_state_){nullptr}
    , decltype(_impl_.msg_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_game_state()) {
    _this->_impl_.game_state_ = new ::game::GameState(*from._impl_.game_state_);
  }
  if (from._internal_has_msg()) {
    _this->_impl_.msg_ = new ::game::ErrorMessage(*from._impl_.msg_);
  }
  // @@protoc_insertion_point(copy_constructor:game.JoinGameAsOwnerResponse)
}

inline void JoinGameAsOwnerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.game_state_){nullptr}
    , decltype(_impl_.msg_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

JoinGameAsOwnerResponse::~JoinGameAsOwnerResponse() {
  // @@protoc_insertion_point(destructor:game.JoinGameAsOwnerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JoinGameAsOwnerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.game_state_;
  if (this != internal_default_instance()) delete _impl_.msg_;
}

void JoinGameAsOwnerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void JoinGameAsOwnerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:game.JoinGameAsOwnerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.game_state_ != nullptr) {
    delete _impl_.game_state_;
  }
  _impl_.game_state_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.msg_ != nullptr) {
    delete _impl_.msg_;
  }
  _impl_.msg_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinGameAsOwnerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.GameState game_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.ErrorMessage msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinGameAsOwnerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.JoinGameAsOwnerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.GameState game_state = 1;
  if (this->_internal_has_game_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::game_state(this),
        _Internal::game_state(this).GetCachedSize(), target, stream);
  }

  // .game.ErrorMessage msg = 2;
  if (this->_internal_has_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::msg(this),
        _Internal::msg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.JoinGameAsOwnerResponse)
  return target;
}

size_t JoinGameAsOwnerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.JoinGameAsOwnerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .game.GameState game_state = 1;
  if (this->_internal_has_game_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.game_state_);
  }

  // .game.ErrorMessage msg = 2;
  if (this->_internal_has_msg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.msg_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinGameAsOwnerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    JoinGameAsOwnerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinGameAsOwnerResponse::GetClassData() const { return &_class_data_; }


void JoinGameAsOwnerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<JoinGameAsOwnerResponse*>(&to_msg);
  auto& from = static_cast<const JoinGameAsOwnerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.JoinGameAsOwnerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_game_state()) {
    _this->_internal_mutable_game_state()->::game::GameState::MergeFrom(
        from._internal_game_state());
  }
  if (from._internal_has_msg()) {
    _this->_internal_mutable_msg()->::game::ErrorMessage::MergeFrom(
        from._internal_msg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinGameAsOwnerResponse::CopyFrom(const JoinGameAsOwnerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.JoinGameAsOwnerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinGameAsOwnerResponse::IsInitialized() const {
  return true;
}

void JoinGameAsOwnerResponse::InternalSwap(JoinGameAsOwnerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinGameAsOwnerResponse, _impl_.msg_)
      + sizeof(JoinGameAsOwnerResponse::_impl_.msg_)
      - PROTOBUF_FIELD_OFFSET(JoinGameAsOwnerResponse, _impl_.game_state_)>(
          reinterpret_cast<char*>(&_impl_.game_state_),
          reinterpret_cast<char*>(&other->_impl_.game_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinGameAsOwnerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[24]);
}

// ===================================================================

class GameState::_Internal {
 public:
};

GameState::GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.GameState)
}
GameState::GameState(const GameState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_cards_){from._impl_.player_cards_}
    , decltype(_impl_.board_cards_){from._impl_.board_cards_}
    , decltype(_impl_.players_){from._impl_.players_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:game.GameState)
}

inline void GameState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_cards_){arena}
    , decltype(_impl_.board_cards_){arena}
    , decltype(_impl_.players_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GameState::~GameState() {
  // @@protoc_insertion_point(destructor:game.GameState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_cards_.~RepeatedPtrField();
  _impl_.board_cards_.~RepeatedPtrField();
  _impl_.players_.~RepeatedPtrField();
}

void GameState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameState::Clear() {
// @@protoc_insertion_point(message_clear_start:game.GameState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_cards_.Clear();
  _impl_.board_cards_.Clear();
  _impl_.players_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .game.Card player_cards = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_cards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .game.Card board_cards = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_board_cards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .game.Player players = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.GameState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .game.Card player_cards = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_cards_size()); i < n; i++) {
    const auto& repfield = this->_internal_player_cards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .game.Card board_cards = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_board_cards_size()); i < n; i++) {
    const auto& repfield = this->_internal_board_cards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .game.Player players = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.GameState)
  return target;
}

size_t GameState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.GameState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .game.Card player_cards = 1;
  total_size += 1UL * this->_internal_player_cards_size();
  for (const auto& msg : this->_impl_.player_cards_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .game.Card board_cards = 2;
  total_size += 1UL * this->_internal_board_cards_size();
  for (const auto& msg : this->_impl_.board_cards_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .game.Player players = 3;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameState::GetClassData() const { return &_class_data_; }


void GameState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameState*>(&to_msg);
  auto& from = static_cast<const GameState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.GameState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.player_cards_.MergeFrom(from._impl_.player_cards_);
  _this->_impl_.board_cards_.MergeFrom(from._impl_.board_cards_);
  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameState::CopyFrom(const GameState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.GameState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameState::IsInitialized() const {
  return true;
}

void GameState::InternalSwap(GameState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.player_cards_.InternalSwap(&other->_impl_.player_cards_);
  _impl_.board_cards_.InternalSwap(&other->_impl_.board_cards_);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[25]);
}

// ===================================================================

class MakeMoveRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MakeMoveRequest>()._impl_._has_bits_);
  static void set_has_blind_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MakeMoveRequest::MakeMoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.MakeMoveRequest)
}
MakeMoveRequest::MakeMoveRequest(const MakeMoveRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MakeMoveRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){}
    , decltype(_impl_.move_type_){}
    , decltype(_impl_.blind_size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.player_id_, &from._impl_.player_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blind_size_) -
    reinterpret_cast<char*>(&_impl_.player_id_)) + sizeof(_impl_.blind_size_));
  // @@protoc_insertion_point(copy_constructor:game.MakeMoveRequest)
}

inline void MakeMoveRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){0u}
    , decltype(_impl_.move_type_){0}
    , decltype(_impl_.blind_size_){0u}
  };
}

MakeMoveRequest::~MakeMoveRequest() {
  // @@protoc_insertion_point(destructor:game.MakeMoveRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MakeMoveRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MakeMoveRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MakeMoveRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:game.MakeMoveRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.player_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.move_type_) -
      reinterpret_cast<char*>(&_impl_.player_id_)) + sizeof(_impl_.move_type_));
  _impl_.blind_size_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MakeMoveRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .game.MoveType move_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_move_type(static_cast<::game::MoveType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 blind_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_blind_size(&has_bits);
          _impl_.blind_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MakeMoveRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.MakeMoveRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 player_id = 1;
  if (this->_internal_player_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_player_id(), target);
  }

  // .game.MoveType move_type = 2;
  if (this->_internal_move_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_move_type(), target);
  }

  // optional uint32 blind_size = 3;
  if (_internal_has_blind_size()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_blind_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.MakeMoveRequest)
  return target;
}

size_t MakeMoveRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.MakeMoveRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 player_id = 1;
  if (this->_internal_player_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_id());
  }

  // .game.MoveType move_type = 2;
  if (this->_internal_move_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_move_type());
  }

  // optional uint32 blind_size = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blind_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MakeMoveRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MakeMoveRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MakeMoveRequest::GetClassData() const { return &_class_data_; }


void MakeMoveRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MakeMoveRequest*>(&to_msg);
  auto& from = static_cast<const MakeMoveRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.MakeMoveRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_player_id() != 0) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  if (from._internal_move_type() != 0) {
    _this->_internal_set_move_type(from._internal_move_type());
  }
  if (from._internal_has_blind_size()) {
    _this->_internal_set_blind_size(from._internal_blind_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MakeMoveRequest::CopyFrom(const MakeMoveRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.MakeMoveRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MakeMoveRequest::IsInitialized() const {
  return true;
}

void MakeMoveRequest::InternalSwap(MakeMoveRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MakeMoveRequest, _impl_.blind_size_)
      + sizeof(MakeMoveRequest::_impl_.blind_size_)
      - PROTOBUF_FIELD_OFFSET(MakeMoveRequest, _impl_.player_id_)>(
          reinterpret_cast<char*>(&_impl_.player_id_),
          reinterpret_cast<char*>(&other->_impl_.player_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MakeMoveRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[26]);
}

// ===================================================================

class MakeMoveResponse::_Internal {
 public:
};

MakeMoveResponse::MakeMoveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:game.MakeMoveResponse)
}
MakeMoveResponse::MakeMoveResponse(const MakeMoveResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MakeMoveResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:game.MakeMoveResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MakeMoveResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MakeMoveResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MakeMoveResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[27]);
}

// ===================================================================

class Card::_Internal {
 public:
};

Card::Card(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:game.Card)
}
Card::Card(const Card& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Card* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.suit_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.suit_, &from._impl_.suit_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.suit_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:game.Card)
}

inline void Card::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.suit_){0}
    , decltype(_impl_.value_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Card::~Card() {
  // @@protoc_insertion_point(destructor:game.Card)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Card::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Card::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Card::Clear() {
// @@protoc_insertion_point(message_clear_start:game.Card)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.suit_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.value_) -
      reinterpret_cast<char*>(&_impl_.suit_)) + sizeof(_impl_.value_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Card::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .game.Suits suit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_suit(static_cast<::game::Suits>(val));
        } else
          goto handle_unusual;
        continue;
      // .game.Values value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_value(static_cast<::game::Values>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Card::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.Card)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .game.Suits suit = 1;
  if (this->_internal_suit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_suit(), target);
  }

  // .game.Values value = 2;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.Card)
  return target;
}

size_t Card::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.Card)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .game.Suits suit = 1;
  if (this->_internal_suit() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_suit());
  }

  // .game.Values value = 2;
  if (this->_internal_value() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Card::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Card::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Card::GetClassData() const { return &_class_data_; }


void Card::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Card*>(&to_msg);
  auto& from = static_cast<const Card&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:game.Card)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_suit() != 0) {
    _this->_internal_set_suit(from._internal_suit());
  }
  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Card::CopyFrom(const Card& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.Card)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Card::IsInitialized() const {
  return true;
}

void Card::InternalSwap(Card* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Card, _impl_.value_)
      + sizeof(Card::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(Card, _impl_.suit_)>(
          reinterpret_cast<char*>(&_impl_.suit_),
          reinterpret_cast<char*>(&other->_impl_.suit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Card::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[28]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::game::ErrorMessage*
Arena::CreateMaybeMessage< ::game::ErrorMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::ErrorMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::game::LoginRequest*
Arena::CreateMaybeMessage< ::game::LoginRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::LoginRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::game::LoginResponse*
Arena::CreateMaybeMessage< ::game::LoginResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::LoginResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::LoginRequestFirst*
Arena::CreateMaybeMessage< ::game::LoginRequestFirst >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::LoginRequestFirst >(arena);
}
template<> PROTOBUF_NOINLINE ::game::LoginRequestSecond*
Arena::CreateMaybeMessage< ::game::LoginRequestSecond >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::LoginRequestSecond >(arena);
}
template<> PROTOBUF_NOINLINE ::game::LoginResponseFirst*
Arena::CreateMaybeMessage< ::game::LoginResponseFirst >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::LoginResponseFirst >(arena);
}
template<> PROTOBUF_NOINLINE ::game::LoginResponseSecond*
Arena::CreateMaybeMessage< ::game::LoginResponseSecond >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::LoginResponseSecond >(arena);
}
template<> PROTOBUF_NOINLINE ::game::RegisterRequest*
Arena::CreateMaybeMessage< ::game::RegisterRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::RegisterRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::game::RegisterResponse*
Arena::CreateMaybeMessage< ::game::RegisterResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::RegisterResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::SaltHash*
Arena::CreateMaybeMessage< ::game::SaltHash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::SaltHash >(arena);
}
template<> PROTOBUF_NOINLINE ::game::Player*
Arena::CreateMaybeMessage< ::game::Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::Player >(arena);
}
template<> PROTOBUF_NOINLINE ::game::LobbyRequests*
Arena::CreateMaybeMessage< ::game::LobbyRequests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::LobbyRequests >(arena);
}
template<> PROTOBUF_NOINLINE ::game::LobbyResponses*
Arena::CreateMaybeMessage< ::game::LobbyResponses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::LobbyResponses >(arena);
}
template<> PROTOBUF_NOINLINE ::game::CreateGameRequest*
Arena::CreateMaybeMessage< ::game::CreateGameRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::CreateGameRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::game::CreateGameResponse*
Arena::CreateMaybeMessage< ::game::CreateGameResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::CreateGameResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::SearchGameRequest*
Arena::CreateMaybeMessage< ::game::SearchGameRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::SearchGameRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::game::SearchGameResponse*
Arena::CreateMaybeMessage< ::game::SearchGameResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::SearchGameResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::GameParameters*
Arena::CreateMaybeMessage< ::game::GameParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::GameParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::game::PlayerInfo*
Arena::CreateMaybeMessage< ::game::PlayerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::PlayerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::game::GameRequests*
Arena::CreateMaybeMessage< ::game::GameRequests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::GameRequests >(arena);
}
template<> PROTOBUF_NOINLINE ::game::GameResponses*
Arena::CreateMaybeMessage< ::game::GameResponses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::GameResponses >(arena);
}
template<> PROTOBUF_NOINLINE ::game::JoinGameRequest*
Arena::CreateMaybeMessage< ::game::JoinGameRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::JoinGameRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::game::JoinGameResponse*
Arena::CreateMaybeMessage< ::game::JoinGameResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::JoinGameResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::JoinGameAsOwnerRequest*
Arena::CreateMaybeMessage< ::game::JoinGameAsOwnerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::JoinGameAsOwnerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::game::JoinGameAsOwnerResponse*
Arena::CreateMaybeMessage< ::game::JoinGameAsOwnerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::JoinGameAsOwnerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::GameState*
Arena::CreateMaybeMessage< ::game::GameState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::GameState >(arena);
}
template<> PROTOBUF_NOINLINE ::game::MakeMoveRequest*
Arena::CreateMaybeMessage< ::game::MakeMoveRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::MakeMoveRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::game::MakeMoveResponse*
Arena::CreateMaybeMessage< ::game::MakeMoveResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::MakeMoveResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::Card*
Arena::CreateMaybeMessage< ::game::Card >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::Card >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
